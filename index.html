<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#FF4500">
    <meta name="description" content="Stain Slayer - Defend white clothes with Godrej Fab!">
    <title>Stain Slayer - Godrej Fab Game</title>
    
    <style>

/* iOS Safari specific fix */
@supports (-webkit-touch-callout: none) {
    html, body {
        background: linear-gradient(135deg, #FFD400, #FFA500) !important;
        background-attachment: fixed !important;
    }
    
    body::before {
        content: '';
        position: fixed;
        top: -100px;
        left: 0;
        right: 0;
        height: 100px;
        background: linear-gradient(135deg, #FFD400, #FFA500);
        z-index: 10000;
    }
}

/* Force viewport background for all mobile browsers */
html {
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    min-height: 100vh;
}

/* ============================================
   GAME CSS 
   ============================================ */

/* Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* BACKGROUND SYSTEM - Yellow gradient */
body {
    font-family: 'sans-serif', Arial;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    background-image: linear-gradient(135deg, #FFD400, #FFA500) !important;
    overflow: hidden;
    touch-action: manipulation;
    user-select: none;
    -webkit-user-select: none;
    height: 100vh;
}

/* GAME CONTAINER - Transparent to show background */
#gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    background: transparent !important;
    background-color: transparent !important;
}

/* Prevent images from covering the game */
#gameContainer img {
    max-width: 200px !important;
    max-height: 200px !important;
    position: relative !important;
    z-index: 999 !important;
}

/* GAME CANVAS - Sky background during gameplay */
#gameCanvas {
    background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 100%) !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    height: 100dvh;
    display: block;
    touch-action: none;
    z-index: 1000 !important;
    pointer-events: auto;
    border: none !important; 
    outline: none !important;
    box-shadow: none !important;
    border-width: 0 !important;
    border-style: none !important;
    border-color: transparent !important;
}

/* Enhanced canvas border prevention */
canvas,
#gameCanvas,
#product3DCanvas {
    border: none !important;
    outline: none !important;
    box-shadow: none !important;
    border-width: 0 !important;
    border-style: none !important;
    border-color: transparent !important;
}

/* ============================================
   SCREEN SYSTEM - Loading, Start, Results
   ============================================ */

/* LOADING SCREEN */
.loading-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    padding: 0 !important;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10000 !important;
    color: white;
}

.loading-card {
    background: linear-gradient(135deg, rgba(255, 212, 0, 0.9), rgba(255, 165, 0, 0.9));
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 215, 0, 0.3);
    max-width: 400px;
    width: 90%;
}

.loading-title {
    font-size: 2.5em;
    font-weight: bold;
    color: #0097D7;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.loading-subtitle {
    font-size: 1.2em;
    color: #1A2F85;
    margin-bottom: 30px;
    font-weight: bold;
}

.loading-progress {
    width: 100%;
    height: 8px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 20px;
}

.loading-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #FFD700, #FFA500);
    border-radius: 4px;
    transition: width 0.3s ease;
    animation: pulse 1.5s infinite;
}

.loading-tip {
    font-size: 1.1em;
    color: #1A2F85;
    font-style: italic;
}

/* START SCREEN */
.start-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    padding: 0 !important;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9000 !important;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease;
    transform: translateY(-100vh);
}

.start-screen:not(.hidden) {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    transform: translateY(0) !important;
}

.start-screen.hidden {
    opacity: 0;
    pointer-events: none;
    display: none !important;
    visibility: hidden !important;
    transform: translateY(-100vh) !important;
}

.start-card {
    background: linear-gradient(135deg, rgba(255, 212, 0, 0.9), rgba(255, 165, 0, 0.9));
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 215, 0, 0.3);
    max-width: 400px;
    width: 90%;
    color: white;
}

.fab-logo-img {
    height: 100px;
    width: auto;
    margin-bottom: 10px;
}

.game-main-title {
    font-size: 3em;
    font-weight: bold;
    color: #0097D7;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.game-subtitle {
    font-size: 1.1em;
    margin-bottom: 30px;
    line-height: 1.4;
    color: rgba(255, 255, 255, 0.9);
}

.character-preview-img {
    width: 120px;
    height: 120px;
    object-fit: contain;
    animation: float 3s ease-in-out infinite;
}

.play-button {
    background: linear-gradient(45deg, #1A2F85, #2A3F95);
    border: none;
    padding: 15px 40px;
    font-size: 1.3em;
    font-weight: bold;
    color: #FFFFFF;
    border-radius: 25px;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s ease;
    pointer-events: all;
    margin-top: 10px;
}

.play-button:hover {
    transform: scale(1.05);
}

.play-button:active {
    transform: scale(0.95);
}

/* RESULTS SCREEN */
.results-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    padding: 20px !important;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 8000 !important;
    color: white;
    visibility: hidden;
    opacity: 0;
    transform: translateY(-100vh);
    pointer-events: none;
}

.results-screen.show {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    z-index: 10000 !important;
    transform: translateY(0) !important;
    pointer-events: auto !important;
}

.results-card {
    background: linear-gradient(135deg, rgba(255, 212, 0, 0.9), rgba(255, 165, 0, 0.9)) !important;
    border-radius: 20px;
    padding: 30px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 215, 0, 0.3);
    max-width: 400px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.results-title {
    font-size: 2.2em;
    font-weight: bold;
    color: #1A2F85;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.results-score {
    font-size: 1.5em;
    color: #1A2F85;
    margin-bottom: 20px;
}

/* RESULTS STATS - Remove glassmorphic effects */
.results-stats {
    background: rgba(26, 47, 133, 0.3) !important;
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 25px;
    color: white;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border: none !important;
}

.results-stats p {
    margin: 5px 0;
    font-size: 1.1em;
}

.results-stats strong {
    color: #FFD700;
}

/* PERFORMANCE RATING - Remove glassmorphic effects */
.performance-rating-container {
    margin: 20px 0;
    text-align: center;
    background: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.performance-rating {
    font-size: 1.4em;
    font-weight: bold;
    padding: 15px;
    background: rgba(255, 255, 255, 0.1) !important;
    border-radius: 15px;
    margin: 15px 0;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* PRODUCT SECTION */
.product-section {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 25px 0;
    gap: 40px;
}

.qr-code {
    width: 90px;
    height: 90px;
    background: white;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7em;
    color: black;
    text-align: center;
    padding: 5px;
    overflow: hidden;
    transform: translateX(0);
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.qr-code canvas {
    width: 100%;
    height: 100%;
}

.fab-product {
    width: 90px;
    height: 90px;
    background: transparent;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.2s ease;
    margin-left: 5px;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* AR SECTION - Remove glassmorphic effects */
.ar-section {
    background: rgba(0, 151, 215, 0.1) !important;
    border-radius: 15px;
    padding: 20px;
    margin: 20px 0;
    border: 2px dashed rgba(0, 151, 215, 0.5) !important;
    min-height: 320px;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.ar-title {
    color: #0097D7;
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 10px;
}

.ar-description {
    font-size: 1.1em;
    color: #1A2F85;
    margin-bottom: 15px;
    text-align: center;
    line-height: 1.4;
}

.ar-description strong {
    color: #0097D7;
    font-weight: bold;
}

/* PRODUCT 3D CONTAINER - Remove glassmorphic effects */
.product-3d-container {
    width: 100%;
    max-width: 300px;
    height: 200px;
    margin: 0 auto 15px auto;
    position: relative;
    overflow: hidden;
    border-radius: 8px;
    background: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

#product3DCanvas {
    width: 100% !important;
    height: 100% !important;
    display: block;
}

/* ACTION BUTTONS - Remove glassmorphic effects */
.action-buttons {
    display: flex;
    gap: 15px;
    margin-top: 25px;
    flex-wrap: wrap;
    justify-content: center;
}

.action-button {
    padding: 12px 25px;
    border: none;
    border-radius: 25px;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.2s ease;
    font-size: 0.9em;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.action-button:hover {
    transform: scale(1.05);
}

.save-code-btn {
    background: linear-gradient(45deg, #0097D7, #00B4E6);
    color: #000;
}

.buy-fab-btn {
    background: linear-gradient(45deg, #FFD400, #FFA500);
    color: #1A2F85;
}

.whatsapp-btn {
    background: linear-gradient(45deg, #25D366, #128C7E);
    color: white;
}

.play-again-btn {
    background: linear-gradient(45deg, #1A2F85, #2A3F95);
    color: white;
    width: 100%;
    margin-top: 15px;
}

/* ============================================
   GAMEPLAY HUD SYSTEM - With glassmorphism
   ============================================ */

/* Game HUD Elements */
.hud {
    position: absolute;
    top: 15px;
    left: 15px;
    display: none;
    flex-direction: column;
    gap: 10px;
    z-index: 9999;
    pointer-events: none;
}

.hud.show {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* HUD ITEMS - Apply glassmorphism during gameplay */
.hud-item {
    background: rgba(255, 255, 255, 0.2) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    border-color: rgba(255, 255, 255, 0.3) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;
    padding: 8px 15px;
    border-radius: 15px;
    font-weight: 700;
    font-size: 14px;
    font-family: sans-serif, Arial;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
}

.hud-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s ease;
}

.hud-item:hover::before {
    left: 100%;
}

/* Score Display */
.score-display {
    font-size: 16px;
    color: #FFD700;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5) !important;
    font-family: sans-serif, Arial;
    font-weight: 800;
    position: relative;
}

.score-display::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, transparent 30%, rgba(255, 215, 0, 0.15) 50%, transparent 70%);
    animation: scoreShine 4s infinite;
    pointer-events: none;
}

/* HEALTH SYSTEM - Apply glassmorphism during gameplay */
.health-container {
    min-width: 200px;
    position: relative;
    background: rgba(255, 255, 255, 0.2) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    border-color: rgba(255, 255, 255, 0.3) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;
}

.health-label {
    font-size: 12px;
    margin-bottom: 5px;
    font-weight: 600;
    opacity: 0.9;
    font-family: sans-serif, Arial;
    color: #FFFFFF;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5) !important;
}

.health-bar {
    width: 100%;
    height: 16px;
    background: linear-gradient(145deg, rgba(255, 0, 0, 0.2), rgba(139, 0, 0, 0.3));
    border-radius: 10px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.3);
    position: relative;
    backdrop-filter: blur(5px);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.1);
}

.health-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff4757, #ffa502, #2ed573);
    transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 8px;
    position: relative;
    overflow: hidden;
    box-shadow: 0 0 8px rgba(46, 213, 115, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.health-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
    animation: healthShimmer 3s infinite;
}

.health-fill.health-critical {
    background: linear-gradient(90deg, #ff4757, #ff3838) !important;
    box-shadow: 0 0 15px rgba(255, 71, 87, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
    animation: healthCritical 0.8s infinite alternate;
}

.health-fill.health-warning {
    background: linear-gradient(90deg, #ff6b35, #ffa502) !important;
    box-shadow: 0 0 10px rgba(255, 165, 2, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
}

.health-fill.health-good {
    background: linear-gradient(90deg, #ffa502, #2ed573) !important;
    box-shadow: 0 0 8px rgba(46, 213, 115, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
}

/* GAME MESSAGES - Apply glassmorphism during gameplay */
.game-message {
    position: absolute;
    top: 120px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    background: rgba(255, 255, 255, 0.25) !important;
    backdrop-filter: blur(15px) !important;
    -webkit-backdrop-filter: blur(15px) !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;
    padding: 12px 24px;
    border-radius: 15px;
    z-index: 9999;
    pointer-events: none;
    font-family: sans-serif, Arial;
    font-weight: 700;
    font-size: 18px;
    color: #1A2F85;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3) !important;
    opacity: 0;
    transform: translateX(-50%) translateY(-10px) scale(0.9);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    max-width: 320px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.game-message.show {
    opacity: 1 !important;
    transform: translateX(-50%) translateY(0) scale(1) !important;
    visibility: visible !important;
}

.game-message.fade-out {
    opacity: 0;
    transform: translateX(-50%) translateY(10px) scale(0.9);
}

.game-message::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.2), transparent);
    animation: messageShine 3s infinite;
}

/* POWER INDICATOR - Keep original green glassmorphic */
.power-indicator {
    background: rgba(0, 255, 127, 0.2) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    border: 1px solid rgba(0, 255, 127, 0.4) !important;
    border-color: rgba(0, 255, 127, 0.4) !important;
    padding: 6px 12px;
    border-radius: 12px;
    opacity: 0;
    transform: translateX(100px) scale(0.9);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    font-weight: 700;
    font-size: 12px;
    box-shadow: 0 3px 15px rgba(0, 255, 127, 0.2);
    font-family: sans-serif, Arial;
    color: #FFFFFF;
    position: relative;
    overflow: hidden;
}

.power-indicator::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0, 255, 127, 0.3), transparent);
    transition: left 0.6s ease;
}

.power-indicator.active {
    opacity: 1;
    transform: translateX(0) scale(1);
    animation: powerPulse 2s ease-in-out infinite alternate;
    border-color: rgba(0, 255, 127, 0.4) !important;
    border: 1px solid rgba(0, 255, 127, 0.4) !important;
}

.power-indicator.active::before {
    left: 100%;
}

.power-indicator:hover,
.power-indicator:focus {
    border-color: rgba(0, 255, 127, 0.4) !important;
    border: 1px solid rgba(0, 255, 127, 0.4) !important;
}

/* ============================================
   ADDITIONAL GAME ELEMENTS
   ============================================ */

/* Blinkit Button */
.blinkit-button {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: #1A2F85;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    font-weight: bold;
    cursor: pointer;
    pointer-events: all;
    transition: transform 0.2s ease;
}

.blinkit-button:hover {
    transform: scale(1.1);
}

/* AUDIO TOGGLE - Apply glassmorphism during gameplay */
.audio-toggle {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 50px;
    height: 50px;
    background: rgba(255, 255, 255, 0.2) !important;
    backdrop-filter: blur(15px) !important;
    -webkit-backdrop-filter: blur(15px) !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;
    border-radius: 50%;
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 9999;
    transition: all 0.3s ease;
    touch-action: manipulation !important;
    -webkit-touch-callout: none !important;
    -webkit-user-select: none !important;
    user-select: none !important;
    pointer-events: none;
    -webkit-tap-highlight-color: transparent;
}

.audio-toggle.show {
    display: flex !important;
    pointer-events: auto !important;
    visibility: visible !important;
    opacity: 1 !important;
}

.audio-toggle:hover {
    background: rgba(255, 255, 255, 0.3) !important;
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
}

.audio-toggle.muted {
    opacity: 0.7;
    background: linear-gradient(145deg, rgba(255, 71, 87, 0.8), rgba(139, 0, 0, 0.6)) !important;
}

.audio-toggle.muted:hover {
    background: linear-gradient(145deg, rgba(255, 71, 87, 0.9), rgba(139, 0, 0, 0.8)) !important;
}

.audio-icon {
    font-size: 18px;
    color: #FFD700;
    transition: color 0.3s ease;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}

.audio-toggle.muted .audio-icon {
    color: #FFFFFF;
}

.audio-toggle.active {
    animation: rallyPulse 2s infinite;
}

.audio-menu {
    position: fixed;
    background: linear-gradient(145deg, rgba(26, 47, 133, 0.95), rgba(0, 151, 215, 0.9));
    border-radius: 10px;
    padding: 10px;
    z-index: 10000;
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 215, 0, 0.3);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    min-width: 150px;
}

.audio-menu-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.2s ease;
    color: #FFD700;
    font-size: 14px;
    font-weight: 500;
}

.audio-menu-item:hover {
    background: rgba(255, 215, 0, 0.2);
}

.audio-menu-icon {
    margin-right: 8px;
    font-size: 16px;
}

/* Achievement Feedback */
.score-boost {
    animation: scoreBoost 0.8s ease-out;
}

.accuracy-perfect {
    animation: accuracyPerfect 1.2s ease-out;
}

/* ============================================
   GAMEPLAY STATE ISOLATION
   ============================================ */

/* Ensure complete isolation during gameplay */
body.gameplay .results-screen,
body.gameplay .start-screen {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    transform: translateY(-200vh) !important;
    z-index: -999 !important;
}

body.gameplay .start-card,
body.gameplay .results-card,
body.gameplay .results-stats strong {
    visibility: hidden !important;
    opacity: 0 !important;
}

/* ============================================
   ANIMATIONS
   ============================================ */

@keyframes pulse {
    0%, 100% {
        opacity: 1;
        transform: scale(1);
    }
    50% {
        opacity: 0.7;
        transform: scale(1.05);
    }
}

@keyframes float {
    0%, 100% {
        transform: translateY(0px);
    }
    50% {
        transform: translateY(-10px);
    }
}

@keyframes scoreShine {
    0% {
        transform: translateX(-100%);
    }
    50% {
        transform: translateX(-100%);
    }
    100% {
        transform: translateX(100%);
    }
}

@keyframes healthShimmer {
    0% {
        left: -100%;
    }
    50% {
        left: -100%;
    }
    100% {
        left: 100%;
    }
}

@keyframes healthCritical {
    0% {
        filter: brightness(1);
    }
    100% {
        filter: brightness(1.2);
    }
}

@keyframes messageShine {
    0% {
        left: -100%;
    }
    50% {
        left: -100%;
    }
    100% {
        left: 100%;
    }
}

@keyframes powerPulse {
    0% {
        box-shadow: 0 3px 15px rgba(0, 255, 127, 0.2);
    }
    100% {
        box-shadow: 0 5px 25px rgba(0, 255, 127, 0.4);
    }
}

@keyframes rallyPulse {
    0% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), 0 0 0 0 rgba(255, 215, 0, 0.7);
    }
    50% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), 0 0 0 8px rgba(255, 215, 0, 0);
    }
    100% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), 0 0 0 0 rgba(255, 215, 0, 0);
    }
}

@keyframes scoreBoost {
    0% {
        transform: scale(1);
        color: #FFD700;
    }
    50% {
        transform: scale(1.15);
        color: #00FFFF;
        text-shadow: 0 0 10px #00FFFF;
    }
    100% {
        transform: scale(1);
        color: #FFD700;
    }
}

@keyframes accuracyPerfect {
    0% {
        transform: scale(1);
    }
    25% {
        transform: scale(1.1);
        color: #00FF00;
        text-shadow: 0 0 15px #00FF00;
    }
    50% {
        transform: scale(1.05);
    }
    75% {
        transform: scale(1.1);
        color: #00FF00;
        text-shadow: 0 0 15px #00FF00;
    }
    100% {
        transform: scale(1);
        color: inherit;
    }
}

/* ============================================
   MOBILE RESPONSIVE STYLES
   ============================================ */

@media (max-width: 768px) {
    .game-main-title {
        font-size: 2em;
    }

    .play-button {
        font-size: 1.1em;
        padding: 12px 30px;
    }

    .results-card {
        padding: 25px;
        margin: 10px;
    }

    .action-buttons {
        flex-direction: row;
        gap: 10px;
        flex-wrap: wrap;
    }

    .action-button {
        flex: 1;
        min-width: 120px;
        max-width: 150px;
        padding: 12px 15px;
        font-size: 0.9em;
        margin: 0;
    }

    .save-code-btn,
    .buy-fab-btn {
        flex: 1;
        max-width: 140px;
    }

    .whatsapp-btn {
        max-width: 200px;
        margin: 0 auto;
    }

    .play-again-btn {
        width: 90%;
        max-width: 300px;
        margin: 15px auto 0;
    }

    .product-section {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 20px 0;
        gap: 30px;
        width: 100%;
        padding: 0 20px;
    }

    .qr-code {
        margin: 0;
        transform: translateX(-2px);
        width: 85px;
        height: 85px;
    }

    .fab-product {
        margin: 0;
        margin-left: 25px;
        width: 85px;
        height: 85px;
    }

    .results-stats {
        padding: 15px;
        font-size: 0.9em;
    }

    .results-score {
        font-size: 1.3em;
    }

    .ar-section {
        min-height: 280px;
        padding: 15px;
        margin: 15px 0;
    }

    .product-3d-container {
        max-width: 250px;
        height: 180px;
    }

    .ar-description {
        font-size: 1.0em;
    }

    /* Mobile responsive glassmorphism */
    .hud-item,
    .health-container,
    .audio-toggle {
        background: rgba(255, 255, 255, 0.25) !important;
        backdrop-filter: blur(8px) !important;
        -webkit-backdrop-filter: blur(8px) !important;
    }
    
    .game-message {
        background: rgba(255, 255, 255, 0.3) !important;
        backdrop-filter: blur(12px) !important;
        -webkit-backdrop-filter: blur(12px) !important;
    }

    .hud-item,
    .level-info,
    .health-container {
        font-size: 12px;
        padding: 6px 12px;
        border: 1px solid rgba(255, 255, 255, 0.8) !important;
        border-color: rgba(255, 255, 255, 0.8) !important;
    }

    .power-indicator {
        font-size: 12px;
        padding: 6px 12px;
        background: rgba(0, 255, 127, 0.25) !important;
        backdrop-filter: blur(8px) !important;
        -webkit-backdrop-filter: blur(8px) !important;
        border: 1px solid rgba(0, 255, 127, 0.8) !important;
        border-color: rgba(0, 255, 127, 0.8) !important;
    }

    .health-bar {
        height: 14px;
        min-width: 150px;
    }

    #gameCanvas {
        border: none !important;
        outline: none !important;
        box-shadow: none !important;
        border-width: 0 !important;
        border-style: none !important;
        border-color: transparent !important;
    }

    .game-message {
        top: 140px;
        font-size: 14px;
        padding: 8px 16px;
        max-width: 250px;
    }

    .audio-toggle {
        width: 45px;
        height: 45px;
        bottom: 15px;
        left: 15px;
    }

    .audio-icon {
        font-size: 16px;
    }

    @keyframes scoreBoost {
        0% {
            transform: scale(1);
            color: #FFD700;
        }
        50% {
            transform: scale(1.1);
            color: #00FFFF;
            text-shadow: 0 0 8px #00FFFF;
        }
        100% {
            transform: scale(1);
            color: #FFD700;
        }
    }

    @keyframes accuracyPerfect {
        0% {
            transform: scale(1);
        }
        25% {
            transform: scale(1.08);
            color: #00FF00;
            text-shadow: 0 0 12px #00FF00;
        }
        50% {
            transform: scale(1.04);
        }
        75% {
            transform: scale(1.08);
            color: #00FF00;
            text-shadow: 0 0 12px #00FF00;
        }
        100% {
            transform: scale(1);
            color: inherit;
        }
    }
}

/* Final safety overrides */
.start-card,
.results-card {
    transform: translateZ(0);
}

/* Prevent any unwanted background inheritance */
.results-screen * {
    backdrop-filter: inherit;
    -webkit-backdrop-filter: inherit;
}
</style>

    <script src="https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
   <div id="gameContainer">
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-card">
            <div class="fab-logo">
                <img src="https://assets.codepen.io/t-24779/FAB-Liquid.png" alt="FAB Liquid" class="fab-logo-img">
            </div>
            <h1 class="loading-title">Stain Slayer</h1>
            <h2 class="loading-subtitle">Loading Game...</h2>
            <div class="loading-progress">
                <div class="loading-progress-fill" id="progressFill"></div>
            </div>
            <p class="loading-tip">Protect everything - in politics and in laundry!</p>
        </div>
    </div>
</div>

    <div id="startScreen" class="start-screen hidden">
        <div class="start-card">
            <div class="fab-logo">
                <img src="https://assets.codepen.io/t-24779/FAB-Liquid.png" alt="FAB Liquid" class="fab-logo-img">
            </div>
            <h1 class="game-main-title">Stain Slayer</h1>
            <div class="character-preview">
                <img src="https://assets.codepen.io/t-24779/game-start-image.png" alt="Game Character" class="character-preview-img">
            </div>
            <p class="game-subtitle">
                <strong>Block stains, score lasting freshness!</strong>
            </p>
            <button id="startButton" class="play-button">Play Game</button>
        </div>
    </div>

    <div id="resultsScreen" class="results-screen">
        <div class="results-card">
            <h2 class="results-title">Game Over</h2>
            <div class="results-score">Score: <span id="finalScore">0</span></div>
            
            <div class="results-stats">
                <p>Your defense lasted <strong><span id="sessionTime">0</span> seconds!</strong></p>
                <p>Accuracy: <strong><span id="accuracyPercent">0</span>% (<span id="hitStats">0/0</span>)</strong></p>
                <p>Projectiles Blocked: <strong><span id="blockedCount">0</span></strong></p>
            </div>
            <!-- Add performance rating display -->
            <div class="performance-rating-container">
            <div id="performanceRating" class="performance-rating"></div>
            </div>

            <div class="product-section">
                <div class="qr-code" id="qrCode">
                    <!-- QR code will be generated here -->
                </div>
                <div class="fab-product" onclick="buyFabProduct()">
                    <img src="https://assets.codepen.io/t-24779/fab-detergent-india.png" alt="FAB Detergent" style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;">
                </div>
            </div>

            <div class="action-buttons">
                <button class="action-button save-code-btn" onclick="saveGameCode()">Save Code</button>
                <button class="action-button buy-fab-btn" onclick="buyFabProduct()">Stay Fab</button>
            </div>

            <div class="ar-section">
               <div class="ar-title">Interactive Product Showcase</div>
               <p class="ar-description">
                  Dono side Fab ka swag!<br>
                  <strong>Drag to rotate â€¢ Scroll to zoom in/out</strong>
              </p>
           <div class="product-3d-container" id="product3DContainer">
                 <canvas id="product3DCanvas"></canvas>
           <div class="product-3d-controls">
        </div>
    </div>
</div>
            <div class="action-buttons">
    <button class="action-button whatsapp-btn" onclick="shareOnWhatsApp()">WhatsApp</button>
</div>

<button class="action-button play-again-btn" onclick="playAgain()">Play Again</button>
</div>
</div>

<canvas id="gameCanvas" width="1400" height="800"></canvas>

<!-- Game HUD Elements -->
<div class="hud" id="gameHUD">
    <div class="hud-item">
        <div class="score-display">Score: <span id="score">0</span></div>
    </div>
    
    <div class="hud-item health-container">
        <div class="health-label">Politician's Reputation</div>
        <div class="health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
    </div>
    
    <!-- Audio toggle integrated into HUD -->
    <div id="audioToggle" class="audio-toggle hud-item" title="Toggle Game Audio">
        <span class="audio-icon">ðŸ”Š</span>
    </div>
</div>

<div class="game-message" id="gameMessage">
    <span id="messageText"></span>
</div>

<div class="power-indicators" id="powerIndicators">
    <div class="power-indicator" id="shieldPower">Fab Shield Active</div>
    <div class="power-indicator" id="speedPower">Speed Boost</div>
    <div class="power-indicator" id="slowmoPower">Slow Motion</div>
</div>
    
    <button id="blinkitButton" class="blinkit-button">
        Buy Fab on Blinkit
    </button>
</div>

<!-- Eruda script from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/eruda/2.4.1/eruda.min.js"></script>

    <!-- Initialize Eruda -->
    <script>
      eruda.init();
    </script>
    
    <script>

/**
 * Stain Slayer Audio Manager
 */
class StainSlayerAudioManager {
    constructor(gameInstance) {
        this.game = gameInstance;
        this.audioContext = null;
        this.soundBuffers = new Map();
        this.activeSources = new Map();
        this.isEnabled = true;
        this.isMuted = false;
        this.masterVolume = 0.7;
        this.sfxVolume = 0.8;
        this.musicVolume = 0.5;
        this.maxConcurrentSounds = 12;
        this.isInitialized = false;
        this.backgroundMusic = null;
        this.musicPlaying = false;
        this.crowdSources = [];
        
        // Performance tracking
        this.soundCount = 0;
        this.lastCleanup = Date.now();
    }

    /**
     * Load tier 2 sounds (placeholder method)
    */loadTier2Sounds() {
    console.log('Tier 2 sounds loading - placeholder implementation');
    //Placeholder for loading additional sound assets 
}
   async initializeAudio() {
    if (this.isInitialized) return;
    
    // Skip audio entirely on problematic mobile browsers
    if (this.game.isMobile && this.isProblematicMobileBrowser()) {
        console.log('Skipping audio on problematic mobile browser');
        this.isEnabled = false;
        this.isInitialized = true;
        return;
    }
    
    try {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Mobile-specific audio unlock with timeout and cleanup
        if (this.audioContext.state === 'suspended') {
            console.log('Audio context suspended, attempting unlock...');
            
            // Create a promise that resolves with success/failure
            const unlockPromise = new Promise((resolve) => {
                let isUnlocked = false;
                
                const unlockAudio = async () => {
                    if (isUnlocked) return; // Prevent multiple calls
                    isUnlocked = true;
                    
                    try {
                        await this.audioContext.resume();
                        console.log('Audio unlocked successfully');
                        resolve(true);
                    } catch (error) {
                        console.warn('Failed to unlock audio:', error);
                        resolve(false);
                    }
                };
                
                // Single cleanup function
                const cleanup = () => {
                    document.removeEventListener('touchstart', unlockHandler);
                    document.removeEventListener('touchend', unlockHandler);
                    document.removeEventListener('click', unlockHandler);
                };
                
                const unlockHandler = () => {
                    unlockAudio();
                    cleanup();
                };
                
                // Add event listeners with automatic cleanup
                document.addEventListener('touchstart', unlockHandler, { once: true, passive: true });
                document.addEventListener('touchend', unlockHandler, { once: true, passive: true });
                document.addEventListener('click', unlockHandler, { once: true, passive: true });
                
                // Timeout fallback to prevent hanging
                setTimeout(() => {
                    if (!isUnlocked) {
                        console.warn('Audio unlock timed out');
                        cleanup();
                        resolve(false);
                    }
                }, 3000); // 3 second timeout
            });
            
            // Wait for unlock attempt
            const unlockSuccess = await unlockPromise;
            if (!unlockSuccess) {
                console.warn('Audio unlock failed, disabling audio');
                this.isEnabled = false;
            }
        }
        
        this.isInitialized = true;
        console.log('Audio system initialized for:', this.game.isMobile ? 'MOBILE' : 'DESKTOP');
        
        // Apply mobile optimizations
        if (this.game.isMobile) {
            this.maxConcurrentSounds = 2; // Reduced from 4
            this.sfxVolume *= 0.4; // Much lower volume
            this.musicVolume *= 0.3;
            console.log('Aggressive mobile audio optimizations applied');
        }
        
        // Generate sound buffers (but skip on low-end devices)
        if (!this.isLowEndDevice()) {
            this.generateNoiseBuffers();
        }
        
    } catch (error) {
        console.warn('Audio initialization failed, disabling audio:', error);
        this.isEnabled = false;
        this.isInitialized = true;
    }
}

/**
 * Create StereoPanner with clamped pan value
 * @param {number} pan - Pan value (-1 to 1)
 * @returns {StereoPannerNode} Configured panner
 */
createStereoPanner(pan = 0) {
    if (!this.audioContext) return null;
    
    const panner = this.audioContext.createStereoPanner();
    const clampedPan = Math.max(-1, Math.min(1, pan || 0));
    panner.pan.setValueAtTime(clampedPan, this.audioContext.currentTime);
    return panner;
}

/**
 * Clamp pan value to valid range
 * @param {number} pan - Pan value
 * @returns {number} Clamped pan value
 */
clampPanValue(pan) {
    return Math.max(-1, Math.min(1, pan || 0));
}

    isProblematicMobileBrowser() {
    const ua = navigator.userAgent.toLowerCase();
    // Disable on older Android WebView or known problematic browsers
    return ua.includes('android 4') || 
           ua.includes('android 5') || 
           ua.includes('samsungbrowser/') ||
           ua.includes('miuibrowser/') ||
           (ua.includes('chrome/') && ua.includes('mobile') && parseInt(ua.match(/chrome\/(\d+)/)[1]) < 70);
}

isLowEndDevice() {
    // Check for low memory devices
    if (navigator.deviceMemory && navigator.deviceMemory < 2) {
        return true;
    }
    
    // Check for older mobile devices
    const ua = navigator.userAgent.toLowerCase();
    if (ua.includes('android') && !ua.includes('android 1')) {
        const match = ua.match(/android (\d+)/);
        if (match && parseInt(match[1]) < 8) {
            return true;
        }
    }
    
    return false;
}     


    generateNoiseBuffers() {
    if (!this.audioContext) return;
    
    try {
        // Reduce buffer sizes for mobile
        const bufferDurations = this.game.isMobile ? 
            { short: 0.05, medium: 0.1, long: 0.3 } :
            { short: 0.1, medium: 0.3, long: 1.0 };
            
        this.noiseBuffers = {
            short: this.generateNoiseBuffer(bufferDurations.short),
            medium: this.generateNoiseBuffer(bufferDurations.medium),
            long: this.generateNoiseBuffer(bufferDurations.long)
        };
        console.log('Noise buffers generated successfully');
    } catch (error) {
        console.warn('Failed to generate noise buffers:', error);
        this.noiseBuffers = { short: null, medium: null, long: null };
        // Disable audio if buffer generation fails
        this.isEnabled = false;
    }
}

generateNoiseBuffer(duration) {
    if (!this.audioContext) return null;
    
    try {
        const sampleRate = this.audioContext.sampleRate;
        const bufferSize = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, bufferSize, sampleRate);
        const output = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
        }
        
        return buffer;
    } catch (error) {
        console.warn('Failed to generate single noise buffer:', error);
        return null;
    }
}

    // PROJECTILE-SPECIFIC IMPACT SOUNDS
    createProjectileImpact(projectileType, intensity = 1.0, panPosition = 0) {
        if (!this.isEnabled || this.isMuted || !this.audioContext) return;
        
        const baseVolume = this.masterVolume * this.sfxVolume * 0.8;
        
        switch(projectileType) {
            case 'tomato':
                this.createWetSplat(baseVolume, panPosition, intensity);
                break;
            case 'egg':
                this.createEggCrack(baseVolume, panPosition, intensity);
                break;
            case 'shoe':
                this.createLeatherThump(baseVolume, panPosition, intensity);
                break;
            case 'bottle':
                this.createGlassShatter(baseVolume, panPosition, intensity);
                break;
            case 'stone':
                this.createRockImpact(baseVolume, panPosition, intensity);
                break;
            case 'banana':
                this.createSoftImpact(baseVolume, panPosition, intensity);
                break;
            case 'apple':
                this.createFruitImpact(baseVolume, panPosition, intensity);
                break;
            default:
                this.createGenericImpact(baseVolume, panPosition, intensity);
        }
    }

    createWetSplat(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Wet splat using filtered noise
        const noiseSource = this.audioContext.createBufferSource();
        const filter = this.audioContext.createBiquadFilter();
        const gainNode = this.audioContext.createGain();
        const panner = this.audioContext.createStereoPanner();
        
        noiseSource.buffer = this.noiseBuffers.short;
        noiseSource.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(panner);
        panner.connect(this.audioContext.destination);
        
        // Low-pass filter for wet, muffled sound
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(600 * intensity, now);
        filter.frequency.exponentialRampToValueAtTime(150, now + 0.1);
        filter.Q.setValueAtTime(3, now);
        
        // Quick splat envelope
        gainNode.gain.setValueAtTime(volume * intensity, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(noiseSource, now + 0.12);
        noiseSource.start(now);
        noiseSource.stop(now + 0.12);
    }

    createEggCrack(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Sharp crack followed by liquid splash
        const crackOsc = this.audioContext.createOscillator();
        const crackGain = this.audioContext.createGain();
        const crackFilter = this.audioContext.createBiquadFilter();
        const panner1 = this.audioContext.createStereoPanner();
        
        crackOsc.connect(crackFilter);
        crackFilter.connect(crackGain);
        crackGain.connect(panner1);
        panner1.connect(this.audioContext.destination);
        
        // High-frequency crack
        crackOsc.frequency.setValueAtTime(1800 * intensity, now);
        crackOsc.frequency.exponentialRampToValueAtTime(3500 * intensity, now + 0.02);
        crackOsc.type = 'square';
        
        crackFilter.type = 'bandpass';
        crackFilter.frequency.setValueAtTime(2200, now);
        crackFilter.Q.setValueAtTime(8, now);
        
        crackGain.gain.setValueAtTime(volume * 0.9, now);
        crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.04);
        
        panner1.pan.setValueAtTime(pan, now);
        
        this.trackAndCleanupSource(crackOsc, now + 0.04);
        crackOsc.start(now);
        crackOsc.stop(now + 0.04);
        
        // Delayed liquid splash
        setTimeout(() => {
            this.createWetSplat(volume * 0.4, pan, intensity * 0.7);
        }, 30);
    }

    createLeatherThump(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Deep leather thump with sub-bass
        const thumpOsc = this.audioContext.createOscillator();
        const subOsc = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const subGain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const panner = this.audioContext.createStereoPanner();
        
        thumpOsc.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(panner);
        
        subOsc.connect(subGain);
        subGain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        // Main thump frequency
        thumpOsc.frequency.setValueAtTime(100 * intensity, now);
        thumpOsc.frequency.exponentialRampToValueAtTime(45, now + 0.25);
        thumpOsc.type = 'triangle';
        
        // Sub-bass component
        subOsc.frequency.setValueAtTime(35 * intensity, now);
        subOsc.type = 'sine';
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(250, now);
        filter.Q.setValueAtTime(2, now);
        
        gainNode.gain.setValueAtTime(volume, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        
        subGain.gain.setValueAtTime(volume * 0.7, now);
        subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(thumpOsc, now + 0.35);
        this.trackAndCleanupSource(subOsc, now + 0.3);
        
        thumpOsc.start(now);
        thumpOsc.stop(now + 0.35);
        subOsc.start(now);
        subOsc.stop(now + 0.3);
    }

    createGlassShatter(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Multiple frequency components for realistic glass break
        for (let i = 0; i < 6; i++) {
            const osc = this.audioContext.createOscillator();
            const gain = this.audioContext.createGain();
            const filter = this.audioContext.createBiquadFilter();
            const panner = this.audioContext.createStereoPanner();
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(panner);
            panner.connect(this.audioContext.destination);
            
            const freq = (700 + i * 350) * intensity;
            osc.frequency.setValueAtTime(freq, now + i * 0.008);
            osc.frequency.exponentialRampToValueAtTime(freq * 0.2, now + 0.18 + i * 0.01);
            osc.type = i % 2 === 0 ? 'square' : 'sawtooth';
            
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(500, now);
            filter.Q.setValueAtTime(4, now);
            
            const vol = volume * (0.9 - i * 0.12);
            gain.gain.setValueAtTime(vol, now + i * 0.008);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.22 + i * 0.015);
            
            panner.pan.setValueAtTime(pan + (Math.random() - 0.5) * 0.3, now);
            
            this.trackAndCleanupSource(osc, now + 0.25 + i * 0.015);
            osc.start(now + i * 0.008);
            osc.stop(now + 0.25 + i * 0.015);
        }
    }

    createRockImpact(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Heavy rock impact with noise burst
        const noiseSource = this.audioContext.createBufferSource();
        const rockOsc = this.audioContext.createOscillator();
        const filter = this.audioContext.createBiquadFilter();
        const rockFilter = this.audioContext.createBiquadFilter();
        const gainNode = this.audioContext.createGain();
        const rockGain = this.audioContext.createGain();
        const panner = this.audioContext.createStereoPanner();
        
        // Noise component
        noiseSource.buffer = this.noiseBuffers.short;
        noiseSource.connect(filter);
        filter.connect(gainNode);
        
        // Rock thud component
        rockOsc.connect(rockFilter);
        rockFilter.connect(rockGain);
        
        gainNode.connect(panner);
        rockGain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        // Filter noise for rocky texture
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(800, now);
        filter.Q.setValueAtTime(5, now);
        
        // Deep rock thud
        rockOsc.frequency.setValueAtTime(80 * intensity, now);
        rockOsc.frequency.exponentialRampToValueAtTime(40, now + 0.2);
        rockOsc.type = 'triangle';
        
        rockFilter.type = 'lowpass';
        rockFilter.frequency.setValueAtTime(200, now);
        
        gainNode.gain.setValueAtTime(volume * 0.6, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        
        rockGain.gain.setValueAtTime(volume, now);
        rockGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(noiseSource, now + 0.08);
        this.trackAndCleanupSource(rockOsc, now + 0.25);
        
        noiseSource.start(now);
        noiseSource.stop(now + 0.08);
        rockOsc.start(now);
        rockOsc.stop(now + 0.25);
    }

    createSoftImpact(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Soft fruit impact
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const panner = this.audioContext.createStereoPanner();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        osc.frequency.setValueAtTime(200 * intensity, now);
        osc.frequency.exponentialRampToValueAtTime(120, now + 0.15);
        osc.type = 'triangle';
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(400, now);
        filter.Q.setValueAtTime(1, now);
        
        gain.gain.setValueAtTime(volume * 0.7, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(osc, now + 0.18);
        osc.start(now);
        osc.stop(now + 0.18);
    }

    createFruitImpact(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Crisp fruit impact
        const osc1 = this.audioContext.createOscillator();
        const osc2 = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const panner = this.audioContext.createStereoPanner();
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        osc1.frequency.setValueAtTime(300 * intensity, now);
        osc1.frequency.exponentialRampToValueAtTime(180, now + 0.12);
        osc1.type = 'triangle';
        
        osc2.frequency.setValueAtTime(600 * intensity, now);
        osc2.frequency.exponentialRampToValueAtTime(400, now + 0.08);
        osc2.type = 'sine';
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, now);
        filter.Q.setValueAtTime(2, now);
        
        gain.gain.setValueAtTime(volume * 0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(osc1, now + 0.15);
        this.trackAndCleanupSource(osc2, now + 0.15);
        
        osc1.start(now);
        osc2.start(now);
        osc1.stop(now + 0.15);
        osc2.stop(now + 0.15);
    }

    createGenericImpact(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Generic punch impact
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const panner = this.audioContext.createStereoPanner();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        osc.frequency.setValueAtTime(400 * intensity, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        osc.type = 'square';
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(600, now);
        filter.Q.setValueAtTime(3, now);
        
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        this.trackAndCleanupSource(osc, now + 0.12);
        osc.start(now);
        osc.stop(now + 0.12);
    }

    // CUSTOM GAME SOUNDS
    createLayeredEliminate(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Layer 1: Main punch
        const osc1 = this.audioContext.createOscillator();
        const gain1 = this.audioContext.createGain();
        const panner1 = this.audioContext.createStereoPanner();
        
        osc1.connect(gain1);
        gain1.connect(panner1);
        panner1.connect(this.audioContext.destination);
        
        osc1.frequency.setValueAtTime(880 * intensity, now);
        osc1.type = 'square';
        gain1.gain.setValueAtTime(volume * 0.7, now);
        gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        panner1.pan.setValueAtTime(pan, now);
        
        // Layer 2: High sparkle
        const osc2 = this.audioContext.createOscillator();
        const gain2 = this.audioContext.createGain();
        const panner2 = this.audioContext.createStereoPanner();
        
        osc2.connect(gain2);
        gain2.connect(panner2);
        panner2.connect(this.audioContext.destination);
        
        osc2.frequency.setValueAtTime(1320 * intensity, now);
        osc2.type = 'sine';
        gain2.gain.setValueAtTime(volume * 0.4, now);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        panner2.pan.setValueAtTime(-pan, now);
        
        // Layer 3: Bass foundation
        const osc3 = this.audioContext.createOscillator();
        const gain3 = this.audioContext.createGain();
        const panner3 = this.audioContext.createStereoPanner();
        
        osc3.connect(gain3);
        gain3.connect(panner3);
        panner3.connect(this.audioContext.destination);
        
        osc3.frequency.setValueAtTime(440 * intensity, now);
        osc3.type = 'triangle';
        gain3.gain.setValueAtTime(volume * 0.3, now);
        gain3.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        panner3.pan.setValueAtTime(pan * 0.5, now);
        
        this.trackAndCleanupSource(osc1, now + 0.15);
        this.trackAndCleanupSource(osc2, now + 0.1);
        this.trackAndCleanupSource(osc3, now + 0.2);
        
        osc1.start(now);
        osc2.start(now);
        osc3.start(now);
        osc1.stop(now + 0.15);
        osc2.stop(now + 0.1);
        osc3.stop(now + 0.2);
    }

    createPunchyCombo(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Frequency sweep with filter movement
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const panner = this.audioContext.createStereoPanner();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        osc.frequency.setValueAtTime(800 * intensity, now);
        osc.frequency.exponentialRampToValueAtTime(1600 * intensity, now + 0.25);
        osc.type = 'sawtooth';
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, now);
        filter.frequency.exponentialRampToValueAtTime(3200, now + 0.25);
        filter.Q.setValueAtTime(4, now);
        
        gain.gain.setValueAtTime(volume * 0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        
        panner.pan.setValueAtTime(-pan, now);
        panner.pan.linearRampToValueAtTime(Math.max(-1, Math.min(1, pan)), now + 0.25);
        
        this.trackAndCleanupSource(osc, now + 0.25);
        osc.start(now);
        osc.stop(now + 0.25);
    }

    createModernPop(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Sharp attack pop
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const panner = this.audioContext.createStereoPanner();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        osc.frequency.setValueAtTime(1000 * intensity, now);
        osc.frequency.exponentialRampToValueAtTime(2000 * intensity, now + 0.02);
        osc.frequency.exponentialRampToValueAtTime(500 * intensity, now + 0.1);
        osc.type = 'square';
        
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1500, now);
        filter.Q.setValueAtTime(6, now);
        
        gain.gain.setValueAtTime(volume * 0.9, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(osc, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    }

    createSwooshSound(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Whoosh effect with noise
        const noiseSource = this.audioContext.createBufferSource();
        const filter = this.audioContext.createBiquadFilter();
        const gain = this.audioContext.createGain();
        const panner = this.createStereoPanner(-pan);
        
        noiseSource.buffer = this.noiseBuffers.short;
        noiseSource.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(800, now);
        filter.frequency.exponentialRampToValueAtTime(200, now + 0.15);
        filter.Q.setValueAtTime(10, now);
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(volume * 0.5, now + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        
        panner.pan.setValueAtTime(-pan, now);
        panner.pan.linearRampToValueAtTime(this.clampPanValue(pan), now + 0.15);
        
        this.trackAndCleanupSource(noiseSource, now + 0.15);
        noiseSource.start(now);
        noiseSource.stop(now + 0.15);
    }

    createDangerSound(volume, pan, intensity) {
        const now = this.audioContext.currentTime;
        
        // Low warning drone
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const panner = this.audioContext.createStereoPanner();
        
        // LFO for tremolo effect
        lfo.connect(lfoGain);
        lfoGain.connect(gain.gain);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        osc.frequency.setValueAtTime(220 * intensity, now);
        osc.type = 'square';
        
        lfo.frequency.setValueAtTime(8, now);
        lfo.type = 'sine';
        lfoGain.gain.setValueAtTime(volume * 0.3, now);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(600, now);
        filter.Q.setValueAtTime(3, now);
        
        gain.gain.setValueAtTime(volume * 0.8, now);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(osc, now + 0.5);
        this.trackAndCleanupSource(lfo, now + 0.5);
        
        lfo.start(now);
        osc.start(now);
        lfo.stop(now + 0.5);
        osc.stop(now + 0.5);
    }

    // SHIELD AND POWER EFFECTS
    createShieldActivation(volume, pan) {
        const now = this.audioContext.currentTime;
        
        // Sci-fi shield with metallic resonance
        const mainOsc = this.audioContext.createOscillator();
        const harmonic1 = this.audioContext.createOscillator();
        const harmonic2 = this.audioContext.createOscillator();
        
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const delay = this.audioContext.createDelay();
        const delayGain = this.audioContext.createGain();
        const panner = this.audioContext.createStereoPanner();
        
        mainOsc.connect(gainNode);
        harmonic1.connect(gainNode);
        harmonic2.connect(gainNode);
        gainNode.connect(filter);
        filter.connect(delay);
        delay.connect(delayGain);
        delayGain.connect(panner);
        filter.connect(panner);
        panner.connect(this.audioContext.destination);
        
        // Frequency sweep upward
        mainOsc.frequency.setValueAtTime(150, now);
        mainOsc.frequency.exponentialRampToValueAtTime(600, now + 0.25);
        harmonic1.frequency.setValueAtTime(300, now);
        harmonic1.frequency.exponentialRampToValueAtTime(1200, now + 0.25);
        harmonic2.frequency.setValueAtTime(450, now);
        harmonic2.frequency.exponentialRampToValueAtTime(1800, now + 0.25);
        
        mainOsc.type = 'triangle';
        harmonic1.type = 'sine';
        harmonic2.type = 'sine';
        
        // Metallic filter sweep
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(300, now);
        filter.frequency.exponentialRampToValueAtTime(900, now + 0.25);
        filter.Q.setValueAtTime(6, now);
        
        // Echo effect
        delay.delayTime.setValueAtTime(0.04, now);
        delayGain.gain.setValueAtTime(0.25, now);
        
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(volume, now + 0.04);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(mainOsc, now + 0.3);
        this.trackAndCleanupSource(harmonic1, now + 0.3);
        this.trackAndCleanupSource(harmonic2, now + 0.3);
        
        mainOsc.start(now);
        harmonic1.start(now);
        harmonic2.start(now);
        mainOsc.stop(now + 0.3);
        harmonic1.stop(now + 0.3);
        harmonic2.stop(now + 0.3);
    }

    createSlowMotionEffect(volume, pan) {
        const now = this.audioContext.currentTime;
        
        // Time distortion effect
        const osc1 = this.audioContext.createOscillator();
        const osc2 = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const lfo = this.audioContext.createOscillator();
        const lfoGain = this.audioContext.createGain();
        const panner = this.audioContext.createStereoPanner();
        
        // LFO for frequency modulation
        lfo.connect(lfoGain);
        lfoGain.connect(osc1.frequency);
        lfoGain.connect(osc2.frequency);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        // Deep bass drone
        osc1.frequency.setValueAtTime(60, now);
        osc2.frequency.setValueAtTime(90, now);
        osc1.type = 'sine';
        osc2.type = 'triangle';
        
        // LFO for wobble effect
        lfo.frequency.setValueAtTime(8, now);
        lfo.type = 'sine';
        lfoGain.gain.setValueAtTime(10, now);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, now);
        filter.frequency.linearRampToValueAtTime(100, now + 1.5);
        filter.Q.setValueAtTime(4, now);
        
        gain.gain.setValueAtTime(volume, now);
        gain.gain.linearRampToValueAtTime(volume * 0.7, now + 1.5);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(osc1, now + 1.5);
        this.trackAndCleanupSource(osc2, now + 1.5);
        this.trackAndCleanupSource(lfo, now + 1.5);
        
        lfo.start(now);
        osc1.start(now);
        osc2.start(now);
        lfo.stop(now + 1.5);
        osc1.stop(now + 1.5);
        osc2.stop(now + 1.5);
    }

    createHealthCritical(volume, pan) {
        const now = this.audioContext.currentTime;
        
        // Urgent heartbeat warning
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                const panner = this.audioContext.createStereoPanner();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(panner);
                panner.connect(this.audioContext.destination);
                
                osc.frequency.setValueAtTime(80, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.audioContext.currentTime + 0.1);
                osc.type = 'triangle';
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, this.audioContext.currentTime);
                filter.Q.setValueAtTime(5, this.audioContext.currentTime);
                
                gain.gain.setValueAtTime(volume * 0.9, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                
                panner.pan.setValueAtTime(pan, this.audioContext.currentTime);
                
                this.trackAndCleanupSource(osc, this.audioContext.currentTime + 0.15);
                osc.start(this.audioContext.currentTime);
                osc.stop(this.audioContext.currentTime + 0.15);
            }, i * 200);
        }
    }

    createUIClick(volume, pan) {
        const now = this.audioContext.currentTime;
        
        // Clean UI click
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const panner = this.audioContext.createStereoPanner();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
        osc.type = 'triangle';
        
        filter.type = 'highpass';
        filter.frequency.setValueAtTime(400, now);
        
        gain.gain.setValueAtTime(volume * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        
        panner.pan.setValueAtTime(this.clampPanValue(pan), now);
        
        this.trackAndCleanupSource(osc, now + 0.08);
        osc.start(now);
        osc.stop(now + 0.08);
    }

    createComboAchievement(volume, pan) {
        const now = this.audioContext.currentTime;
        
        // Satisfying achievement chime
        const frequencies = [523, 659, 784, 1047]; // C-E-G-C chord
        
        frequencies.forEach((freq, index) => {
            const osc = this.audioContext.createOscillator();
            const gain = this.audioContext.createGain();
            const filter = this.audioContext.createBiquadFilter();
            const panner = this.audioContext.createStereoPanner();
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(panner);
            panner.connect(this.audioContext.destination);
            
            osc.frequency.setValueAtTime(freq, now + index * 0.05);
            osc.type = 'triangle';
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(freq * 2, now);
            filter.Q.setValueAtTime(1, now);
            
            const noteVolume = volume * (1 - index * 0.1);
            gain.gain.setValueAtTime(noteVolume, now + index * 0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5 + index * 0.05);
            
            panner.pan.setValueAtTime(pan + (index - 1.5) * 0.2, now);
            
            this.trackAndCleanupSource(osc, now + 0.6 + index * 0.05);
            osc.start(now + index * 0.05);
            osc.stop(now + 0.6 + index * 0.05);
        });
    }

    createVictorySound(volume, pan) {
        const now = this.audioContext.currentTime;
        
        // Triumphant fanfare
        const melody = [523, 659, 784, 1047, 1319]; // C-E-G-C-E ascending
        
        melody.forEach((freq, index) => {
            const osc = this.audioContext.createOscillator();
            const gain = this.audioContext.createGain();
            const filter = this.audioContext.createBiquadFilter();
            const panner = this.audioContext.createStereoPanner();
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(panner);
            panner.connect(this.audioContext.destination);
            
            osc.frequency.setValueAtTime(freq, now + index * 0.08);
            osc.type = 'triangle';
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(freq * 1.5, now);
            filter.Q.setValueAtTime(2, now);
            
            gain.gain.setValueAtTime(volume, now + index * 0.08);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4 + index * 0.08);
            
            panner.pan.setValueAtTime(this.clampPanValue(pan), now);
            
            this.trackAndCleanupSource(osc, now + 0.5 + index * 0.08);
            osc.start(now + index * 0.08);
            osc.stop(now + 0.5 + index * 0.08);
        });
    }

    // CROWD AND AMBIENT SOUNDS
    createCrowdMurmur() {
        if (!this.isEnabled || this.isMuted || !this.audioContext) return;
        
        const now = this.audioContext.currentTime;
        const volume = this.masterVolume * this.musicVolume * 0.3;
        
        // Create multiple layered noise sources for crowd effect
        for (let i = 0; i < 3; i++) {
            const noiseSource = this.audioContext.createBufferSource();
            const filter = this.audioContext.createBiquadFilter();
            const gain = this.audioContext.createGain();
            const panner = this.audioContext.createStereoPanner();
            
            noiseSource.buffer = this.noiseBuffers.long;
            noiseSource.loop = true;
            
            noiseSource.connect(filter);
            filter.connect(gain);
            gain.connect(panner);
            panner.connect(this.audioContext.destination);
            
            // Different frequency ranges for crowd layers
            const filterFreq = 200 + i * 300;
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(filterFreq, now);
            filter.Q.setValueAtTime(2, now);
            
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume * (0.8 - i * 0.2), now + 2);
            
            // Pan crowd across stereo field
            panner.pan.setValueAtTime((i - 1) * 0.6, now);
            
            noiseSource.start(now);
            
            // Store for cleanup
            this.crowdSources.push(noiseSource);
        }
    }

    stopCrowdMurmur() {
        if (this.crowdSources) {
            this.crowdSources.forEach(source => {
                try {
                    source.stop();
                } catch (e) {
                    // Source may be stopped
                }
            });
            this.crowdSources = [];
        }
    }

    // PUBLIC INTERFACE METHODS
    playSound(soundName, options = {}) {
        if (!this.isEnabled || this.isMuted || !this.audioContext) return;

        const volume = (options.volume || 1) * this.sfxVolume * this.masterVolume;
        const pan = options.pan || 0;
        const intensity = options.intensity || 1;

        switch(soundName) {
            case 'ui_click':
                this.createUIClick(volume, pan);
                break;
            case 'shield_activate':
                this.createShieldActivation(volume, pan);
                break;
            case 'projectile_hit':
                this.createGenericImpact(volume, pan, intensity);
                break;
            case 'politician_hit':
                this.createGenericImpact(volume * 1.2, pan, intensity);
                break;
            case 'health_critical':
                this.createHealthCritical(volume, pan);
                break;
            case 'combo_achievement':
                this.createComboAchievement(volume, pan);
                break;
            case 'victory_sound':
                this.createVictorySound(volume, pan);
                break;
            case 'slowmo_activate':
                this.createSlowMotionEffect(volume, pan);
                break;
            case 'crowd_murmur':
                this.createCrowdMurmur();
                break;
            case 'eliminate':
                this.createLayeredEliminate(volume, pan, intensity);
                break;
            case 'combo':
                this.createPunchyCombo(volume, pan, intensity);
                break;
            case 'pop':
                this.createModernPop(volume, pan, intensity);
                break;
            case 'swoosh':
                this.createSwooshSound(volume, pan, intensity);
                break;
            case 'danger':
                this.createDangerSound(volume, pan, intensity);
                break;
            case 'miss':
                this.createModernPop(volume * 0.5, pan, intensity * 0.7);
                break;
            case 'projectile_whoosh':
                this.createSwooshSound(volume, pan, intensity);
                break;
            case 'power_up_collect':
                this.createComboAchievement(volume, pan);
                break;
            default:
                console.warn(`Unknown sound: ${soundName}`);
        }
    }

    playProjectileSound(projectileType, x, options = {}) {
        if (!this.isEnabled || this.isMuted || !this.audioContext) return;

        const gameWidth = this.game.gameWidth || 1400;
        const pan = (x / gameWidth - 0.5) * 2;
        const volume = (options.volume || 1) * this.sfxVolume * this.masterVolume;
        const intensity = options.intensity || 1;

        this.createProjectileImpact(projectileType, intensity, pan);
    }

    playPositionalSound(soundName, x, options = {}) {
    const gameWidth = this.game.gameWidth || 1400;
    const pan = this.clampPanValue((x / gameWidth - 0.5) * 2);
    
    this.playSound(soundName, {
        ...options,
        pan: pan
    });
}

    // UTILITY METHODS
    trackAndCleanupSource(source, stopTime) {
        const sourceId = Date.now() + Math.random();
        this.activeSources.set(sourceId, source);
        this.soundCount++;
        
        source.onended = () => {
            this.activeSources.delete(sourceId);
            this.soundCount--;
        };
        
        // Cleanup old sources periodically
        if (Date.now() - this.lastCleanup > 5000) {
            this.cleanupSources();
            this.lastCleanup = Date.now();
        }
    }

    cleanupSources() {
        // Remove ended sources
        this.activeSources.forEach((source, id) => {
            try {
                if (source.playbackState === 3) { // FINISHED_STATE
                    this.activeSources.delete(id);
                }
            } catch (e) {
                this.activeSources.delete(id);
            }
        });
    }

    setMasterVolume(volume) {
        this.masterVolume = Math.max(0, Math.min(1, volume));
    }

    toggleMute() {
        this.isMuted = !this.isMuted;
        if (this.isMuted) {
            this.stopAllSounds();
        }
        return this.isMuted;
    }

    stopAllSounds() {
        this.activeSources.forEach(source => {
            try {
                source.stop();
            } catch (e) {
                // Source might be stopped
            }
        });
        this.activeSources.clear();
        this.stopCrowdMurmur();
    }

    playBackgroundAudio() {
        this.createCrowdMurmur();
    }

    destroy() {
        this.stopAllSounds();
        if (this.audioContext) {
            this.audioContext.close();
        }
        this.soundBuffers.clear();
    }
}

class StainSlayerGame {
    constructor() {
        // Core game elements
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Game state management
        this.gameStates = {
            LOADING: 'loading',
            START_SCREEN: 'start_screen',
            GAMEPLAY: 'gameplay',
            GAME_OVER: 'game_over',
            PAUSED: 'paused'
        };
        
        // Game state variables
        this.currentState = this.gameStates.LOADING;
        this.score = 0;
        this.level = 1;
        this.wave = 1;
        this.politicianHealth = 100;
        this.maxHealth = 100;
        this.projectilesBlocked = 0;
        this.projectilesMissed = 0;
        this.survivedWaves = 0;
        this.isRunning = false;
        this.sessionStartTime = Date.now();
        this.lastFrameTime = 0;
        
        // Character definitions
        this.aide = {
            x: 600,
            y: 450,
            width: 80,
            height: 120,
            speed: 350,
            shield: false,
            shieldCooldown: 0,
            bounceY: 0,
            facingDirection: 1,
            armAnimation: 0,
            expression: 'determined'
        };
        
        this.politician = {
            x: 700,
            y: 340,
            width: 100,
            height: 150,
            hitbox: { x: 710, y: 400, width: 60, height: 80 },
            armAnimation: 0,
            expression: 'speaking',
            stains: [],
            reactionState: 'normal',
            reactionTimer: 0,
            animationSpeed: 1.0
            
        };

        this.aide = {
            x: 600,
            y: 450,
            width: 80,
            height: 120,
            speed: 350,
            shield: false,
            shieldCooldown: 0,
            bounceY: 0,
            facingDirection: 1,
            armAnimation: 0,
            expression: 'determined',
            spriteFlipped: false,
            shieldEnergy: 100,
            maxShieldEnergy: 100
        };

        this.hinglishMessages = [
            "Leader yaa anda plate?",
            "Vote maango, tamatar lo!",
            "Kurta hai ya dustbin?",
            "Shooter nahi, joota hai!",
            "Ande-tamatar ki aarti!",
            "Public ka washing powder!",
            "Free anda-tamatar makeup!",
            "Democracy ka asli fashion!"
        ];
        
        // Performance tracking
        this.politician.lastPosition = null;
        this.politician.lastAnimationFrame = null;
        this.politician.animationTimer = 0;
        this.aide.animationTimer = 0;
        
        // Game objects
        this.projectiles = [];
        this.particles = [];
        this.trailParticles = [];
        this.cameraShake = { x: 0, y: 0, intensity: 0 };

        // Crowd animation system
        this.crowdAnimation = {
            time: 0,
            waveSpeed: 0.003,
            waveAmplitude: 2,
            sectionOffsets: [0, 0.5, 1.0, 1.5, 2.0] // Different sections sway differently
        };
        
        // Input handling
        this.keys = {};
        this.mouse = { x: 0, y: 0 };
        this.touchControls = {
            up: false,
            down: false,
            left: false,
            right: false,
            shield: false,
            slowmo: false
        };
        
        // Timing system
        this.lastTime = 0;
        this.deltaTime = 0;
        this.projectileSpawnTimer = 0;
        this.projectileSpawnRate = 1200;
        this.waveTimer = 0;
        this.waveDuration = 25000;

        // Wave-based spawning system
        this.waveSpawning = {
            isActive: false,
            intensity: 1,
            burstCount: 0,
            maxBursts: 3,
            burstTimer: 0,
            burstInterval: 800,
            restTimer: 0,
            restDuration: 2000
        };
        
        // Power system
        this.activePowers = {
            shield: 0,
            speed: 0,
            slowmo: 0
        };
        
        // Debug system
        this.debug = {
            enabled: true,
            logLevel: 'info',
            trackFunctions: true,
            trackPerformance: true,
            showFlagOutlines: false
        };

        // Sprite system
        this.spriteSystem = {
            loaded: false,
            images: {},
            animations: {},
            currentFrames: {}
        };

        // Particle system
        this.particleTypes = {
            impact: { life: 1.5, gravity: 200, bounce: 0.4, sparkle: false },
            sparkle: { life: 2.0, gravity: 0, bounce: 0, sparkle: true },
            explosion: { life: 1.0, gravity: 150, bounce: 0.3, sparkle: false },
            trail: { life: 0.8, gravity: 50, bounce: 0, sparkle: false },
            atmospheric: { life: 10.0, gravity: 5, bounce: 0, sparkle: false }
        };

         // Message system
         this.messageSystem = {
            isActive: false,
            currentMessage: '',
            messageTimer: 0,
            messageDuration: 4000,
            messages: {
        powerUp: [
            "Fab Shield ON, boss!",
            "Ab stains ki vaat!",
            "Shine mode activated!"
        ],
        defense: [
            "Koi daag abhi nahi!",
            "Ande-tamatar? Fab bachayega!",
            "Fab guard = full tight!",
            "Lightning Reflexes!",
            "PERFECT ACCURACY!"
        ],
        victory: [
            "Stains down, tu shine karega!",
            "Freshness jeet gaya bhai!",
            "Daag gaye, Fab jeeta!"
        ],
        combo: [
            "Combo master hai tu!",
            "Block pe block, zabardast!",
            "Defense level pro!",
            "Great 5 Streak! Keep going!",
            "AMAZING 10 Streak! On fire!",
            "EPIC 15 Streak! Unstoppable!",
            "LEGENDARY 20 Streak! Master Defender!"
        ],
        close: [
            "Bachke rahna bhai!",
            "Close call tha yaar!",
            "Phew! Safe ho gaye!"
        ],
        wave: [
            "Nayi wave aa rahi hai!",
            "Ready raho defense ke liye!",
            "Agle level ki taiyaari!"
        ]
    },
    lastMessageType: '',
    comboCount: 0,
    lastComboTime: 0
};

       // Reaction system
            this.reactionSystem = {
            politician: {
            currentReaction: 'normal',
            reactionTimer: 0,
            sweatDrops: [],
            reactionCircles: [],
            lastHitTime: 0,
            stressLevel: 0 // 0-100 scale
        },
        aide: {
            currentReaction: 'alert',
            confidenceLevel: 100, // 0-100 scale
            lastSuccessTime: 0,
            victoryPose: false,
            victoryTimer: 0
        } 
        };

        // Atmospheric background system
        this.atmosphericSystem = {
            particles: [],
            maxParticles: 40,
            skyGradient: {
            time: 0,
            baseHue: 200,
            intensity: 0
        },
            parallaxLayers: {
            far: { x: 0, speed: 0.1 },
            mid: { x: 0, speed: 0.3 },
            near: { x: 0, speed: 0.5 }
        },
            wind: {
            strength: 0.5,
            direction: 1,
            time: 0
        }
        };

        // Projectile visual system
           this.projectileEffects = {
            warningIndicators: [],
            impactPredictions: [],
            trailSystem: {
            enabled: true,
            maxTrailLength: 8,
            fadeRate: 0.15
       },
           threatLevels: {
           low: { color: '#90EE90', threshold: 15 },
           medium: { color: '#FFD700', threshold: 25 },
           high: { color: '#FF6347', threshold: 35 },
          critical: { color: '#FF0000', threshold: 50 }
       }
       };

       // Screen effects and visual juice system
          this.screenEffects = {
          shake: {
          intensity: 0,
          duration: 0,
          type: 'impact', // impact, explosion, critical
          decayRate: 20
        },
          flash: {
          active: false,
          color: '#FFFFFF',
          intensity: 0,
          duration: 0,
         fadeRate: 5
        },
    colorOverlay: {
        active: false,
        color: '#FF0000',
        intensity: 0,
        duration: 0,
        fadeRate: 3
    },
    slowMotion: {
        active: false,
        distortionIntensity: 0,
        chromaShift: 0,
        vignette: 0
    },
    comboEffects: {
        multiplier: 1,
        streakCount: 0,
        lastHitTime: 0,
        glowIntensity: 0
    }
};
        // Performance optimization
        this.crowdCache = null;
        this.lastCrowdUpdate = 0;
        
        this.init();
        this.analytics = new StainSlayerAnalytics(this);
        this.audioManager = new StainSlayerAudioManager(this);
    }
    
    /**
     * Debug logging system
     * @param {string} level - Log level (error, warn, info, debug)
     * @param {string} message - Log message
     * @param {*} data - Optional data to log
     */
    debugLog(level, message, data = null) {
        if (!this.debug.enabled) return;
        
        const levels = { error: 0, warn: 1, info: 2, debug: 3 };
        if (levels[level] <= levels[this.debug.logLevel]) {
            const timestamp = new Date().toISOString().substr(11, 12);
            console.log(`[${timestamp}] [${level.toUpperCase()}] ${message}`, data || '');
        }
    }

    /**
     * Toggle flag debug visualization
     * @returns {boolean} Current debug state
     */
    toggleFlagDebug() {
        this.debug.showFlagOutlines = !this.debug.showFlagOutlines;
        console.log('Flag debug outlines:', this.debug.showFlagOutlines ? 'ENABLED' : 'DISABLED');
        return this.debug.showFlagOutlines;
    }

    /**
     * Initialize game systems
     */
    init() {
    // Enhanced mobile detection
    const userAgentMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const screenSizeMobile = window.innerWidth < 768;
    const touchDevice = 'ontouchstart' in window;
    const lowMemory = navigator.deviceMemory && navigator.deviceMemory < 4; // Less than 4GB RAM
    
    this.isMobile = userAgentMobile || screenSizeMobile || touchDevice;
    this.isLowEndDevice = lowMemory || this.isMobile;
    
    // Ultra-conservative mobile optimizations
    this.mobileOptimizations = {
        maxParticles: this.isLowEndDevice ? 3 : 10,
        maxTrailParticles: this.isLowEndDevice ? 2 : 5,
        maxProjectiles: this.isLowEndDevice ? 1 : 2,
        frameSkip: this.isLowEndDevice ? 3 : 2, // Skip more frames
        skipScreenEffects: true,
        skipAtmospheric: true,
        skipEnhancedTrails: true,
        skipAnalytics: this.isLowEndDevice
    };
    
    if (this.isMobile) {
        console.log('Mobile device detected with aggressive optimizations');
        console.log('Optimizations:', this.mobileOptimizations);
    }
    
    this.setupCanvas();
    this.setupEventListeners();
    this.initSpriteSystem();
    this.loadSprites();
    this.loadAssets();
    this.initBackgroundAssets();
    this.initAtmosphericParticles();
}
    /**
     * Initialize background assets
     */
    initBackgroundAssets() {
        this.backgroundAssets = {
            buildings: 'https://assets.codepen.io/t-24779/indian-village.png',
            stage: 'https://assets.codepen.io/t-24779/political-stage-detailed.png',
            ground: 'https://assets.codepen.io/t-24779/village-ground-texture.png',
            crowdBg: 'https://assets.codepen.io/t-24779/crowd-back-ground.png',
            crowdFg: 'https://assets.codepen.io/t-24779/crowd-foreground-layer.png',
    
        };

        this.backgroundImages = {};
        this.backgroundsLoaded = false;
        this.loadBackgroundAssets();
    }

    /**
 * Initialize atmospheric particle system
 */
initAtmosphericParticles() {
    this.atmosphericSystem.particles = [];

     // ADD THIS CHECK BEFORE THE LOOP:
    if (this.isMobile) {
        this.atmosphericSystem.maxParticles = 0;
        console.log('Mobile: Atmospheric particles disabled');
        return;
    }
    
    // Create initial dust particles
    for (let i = 0; i < this.atmosphericSystem.maxParticles; i++) {
        this.createAtmosphericParticle();
    }
    
    console.log(`Initialized ${this.atmosphericSystem.maxParticles} atmospheric particles`);
}

/**
 * Create a single atmospheric particle
 */
createAtmosphericParticle() {
    const particle = {
        x: Math.random() * (this.gameWidth + 200) - 100,
        y: Math.random() * this.gameHeight * 0.6, // Stay in sky area
        vx: (Math.random() - 0.5) * 20 + 10, // Gentle drift
        vy: (Math.random() - 0.5) * 10,
        size: 0.5 + Math.random() * 2,
        opacity: 0.2 + Math.random() * 0.4,
        life: 10 + Math.random() * 20, // Long-lived particles
        maxLife: 30,
        type: Math.random() < 0.8 ? 'dust' : 'pollen',
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 0.01 + Math.random() * 0.02
    };
    
    this.atmosphericSystem.particles.push(particle);
}

    /**
     * Load background assets
     */
    loadBackgroundAssets() {
        const assetKeys = Object.keys(this.backgroundAssets);
        let loadedCount = 0;
        
        assetKeys.forEach(key => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                this.backgroundImages[key] = img;
                loadedCount++;
                
                if (loadedCount === assetKeys.length) {
                    this.backgroundsLoaded = true;
                    console.log('All background assets loaded successfully');
                }
            };
            
            img.onerror = () => {
                console.warn(`Failed to load background asset: ${key}`);
                loadedCount++;
                
                if (loadedCount === assetKeys.length) {
                    this.backgroundsLoaded = false;
                    console.log('Background asset loading completed with some failures');
                }
            };
            
            img.src = this.backgroundAssets[key];
        });
    }

    /**
     * Draw background asset helper
     * @param {string} assetKey - Asset key
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width
     * @param {number} height - Height
     * @returns {boolean} Success status
     */
    drawBackgroundAsset(assetKey, x, y, width, height) {
        if (this.backgroundsLoaded && this.backgroundImages[assetKey]) {
            this.ctx.drawImage(this.backgroundImages[assetKey], x, y, width, height);
            return true;
        }
        return false;
    }

    /**
     * Setup canvas with responsive design
     */
   setupCanvas() {
    const resizeCanvas = () => {
        try {
            let containerWidth, containerHeight;
            
            if (this.isMobile) {
                containerWidth = Math.min(window.innerWidth, 800); // Cap mobile width
                containerHeight = Math.min(window.innerHeight, 600); // Cap mobile height
                
                // Handle mobile viewport issues more safely
                if (window.visualViewport && window.visualViewport.height) {
                    containerHeight = Math.min(window.visualViewport.height, 600);
                }
            } else {
                containerWidth = window.innerWidth;
                containerHeight = window.innerHeight;
            }
            
            this.canvas.width = containerWidth;
            this.canvas.height = containerHeight;
            this.canvas.style.width = containerWidth + 'px';
            this.canvas.style.height = containerHeight + 'px';
            
            this.gameWidth = containerWidth;
            this.gameHeight = containerHeight;
            
            this.canvasRect = this.canvas.getBoundingClientRect();
            
        } catch (error) {
            console.error('Canvas resize error:', error);
            // Fallback dimensions
            this.canvas.width = 800;
            this.canvas.height = 600;
            this.gameWidth = 800;
            this.gameHeight = 600;
        }
    };
    
    resizeCanvas();
    
    // Debounced resize for mobile with error handling
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            try {
                resizeCanvas();
                if (this.currentState === this.gameStates.GAMEPLAY) {
                    this.repositionCharacters();
                }
            } catch (error) {
                console.error('Resize handler error:', error);
            }
        }, this.isMobile ? 300 : 100); // Longer delay on mobile
    });
}
    /**
     * Setup event listeners for input handling
     */
setupEventListeners() {
    // Keyboard events (unchanged)
    window.addEventListener('keydown', (e) => {
        this.keys[e.code] = true;
        if (e.code === 'Space') {
            e.preventDefault();
            this.activateSlowMotion();
        }
    });
    
    window.addEventListener('keyup', (e) => {
        this.keys[e.code] = false;
    });
    
    // Mouse events (unchanged)
    this.canvas.addEventListener('mousedown', (e) => {
        this.activateShield();
    });
    
    this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
        this.mouse.y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
    });
    
    // SIMPLIFIED MOBILE TOUCH HANDLERS
    let touchActive = false;
    let lastTouchX = 0;
    let lastTouchY = 0;

    this.canvas.addEventListener('touchstart', (e) => {
        try {
            e.preventDefault();
            e.stopPropagation();
            
            if (e.touches.length !== 1 || touchActive) return;
            
            touchActive = true;
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            
            // Simple position update
            this.mouse.x = (touch.clientX - rect.left) * (this.canvas.width / rect.width);
            this.mouse.y = (touch.clientY - rect.top) * (this.canvas.height / rect.height);
            
            // Always activate shield on touch
            this.activateShield();
            
        } catch (error) {
            touchActive = false;
        }
    }, { passive: false });

    this.canvas.addEventListener('touchmove', (e) => {
        try {
            e.preventDefault();
            e.stopPropagation();
            
            if (e.touches.length !== 1 || !touchActive) return;
            
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            
            // Update mouse position for shield following
            this.mouse.x = (touch.clientX - rect.left) * (this.canvas.width / rect.width);
            this.mouse.y = (touch.clientY - rect.top) * (this.canvas.height / rect.height);
            
            // SIMPLE movement detection - no complex calculations
            const deltaX = touch.clientX - lastTouchX;
            const deltaY = touch.clientY - lastTouchY;
            
            // Clear all movement first
            this.keys['KeyW'] = this.keys['ArrowUp'] = false;
            this.keys['KeyS'] = this.keys['ArrowDown'] = false;
            this.keys['KeyA'] = this.keys['ArrowLeft'] = false;
            this.keys['KeyD'] = this.keys['ArrowRight'] = false;
            
            // Only set movement if significant change
            if (Math.abs(deltaX) > 20 || Math.abs(deltaY) > 20) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Horizontal movement
                    if (deltaX < 0) {
                        this.keys['KeyA'] = this.keys['ArrowLeft'] = true;
                    } else {
                        this.keys['KeyD'] = this.keys['ArrowRight'] = true;
                    }
                } else {
                    // Vertical movement
                    if (deltaY < 0) {
                        this.keys['KeyW'] = this.keys['ArrowUp'] = true;
                    } else {
                        this.keys['KeyS'] = this.keys['ArrowDown'] = true;
                    }
                }
            }
            
        } catch (error) {
            // Clear movement on any error
            this.keys['KeyW'] = this.keys['ArrowUp'] = false;
            this.keys['KeyS'] = this.keys['ArrowDown'] = false;
            this.keys['KeyA'] = this.keys['ArrowLeft'] = false;
            this.keys['KeyD'] = this.keys['ArrowRight'] = false;
        }
    }, { passive: false });

    this.canvas.addEventListener('touchend', (e) => {
        try {
            e.preventDefault();
            e.stopPropagation();
            
            touchActive = false;
            
            // Clear ALL movement keys immediately
            this.keys['KeyW'] = this.keys['ArrowUp'] = false;
            this.keys['KeyS'] = this.keys['ArrowDown'] = false;
            this.keys['KeyA'] = this.keys['ArrowLeft'] = false;
            this.keys['KeyD'] = this.keys['ArrowRight'] = false;
            
        } catch (error) {
            touchActive = false;
        }
    }, { passive: false });
    
    // Add touchcancel handler to reset state if touch is interrupted
    this.canvas.addEventListener('touchcancel', (e) => {
        try {
            touchActive = false;
            
            // Clear all movement keys
            this.keys['KeyW'] = this.keys['ArrowUp'] = false;
            this.keys['KeyS'] = this.keys['ArrowDown'] = false;
            this.keys['KeyA'] = this.keys['ArrowLeft'] = false;
            this.keys['KeyD'] = this.keys['ArrowRight'] = false;
            
        } catch (error) {
            console.warn('Touch cancel error:', error);
        }
    }, { passive: false });
    
    // UI button events (unchanged)
    const startButton = document.getElementById('startButton');
    const blinkitButton = document.getElementById('blinkitButton');
    
    if (startButton) {
        startButton.addEventListener('click', () => this.startGame());
    }
    
    if (blinkitButton) {
        blinkitButton.addEventListener('click', () => this.openBlinkit());
    }

    // SAFER Audio toggle click handler
    const audioToggle = document.getElementById('audioToggle');
    if (audioToggle) {
        audioToggle.addEventListener('click', (e) => {
            try {
                e.preventDefault();
                e.stopPropagation();
                
                if (this.audioManager) {
                    const isMuted = this.audioManager.toggleMute();
                    const audioIcon = audioToggle.querySelector('.audio-icon');
                    
                    if (audioIcon) {
                        audioIcon.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
                    }
                    
                    audioToggle.classList.toggle('muted', isMuted);
                    
                    // Play UI feedback sound when unmuting (with error handling)
                    if (!isMuted && this.audioManager.isEnabled) {
                        setTimeout(() => {
                            try {
                                this.audioManager.playSound('pop', { volume: 0.5 });
                            } catch (audioError) {
                                console.warn('Audio feedback failed:', audioError);
                            }
                        }, 100);
                    }
                }
            } catch (error) {
                console.warn('Audio toggle error:', error);
            }
        });
    }
        
    if (this.isMobile) {
        // Handle page visibility changes (when user switches tabs/apps)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden - stopping game loop');
                this.isRunning = false;
                this.stopGameLoop();
                
                // Clear all inputs when app loses focus
                this.keys = {};
                
            } else if (this.currentState === this.gameStates.GAMEPLAY) {
                console.log('Page visible - game was paused');
                // Don't auto-restart, let user tap to continue
            }
        });
        
        // Handle window focus/blur
        window.addEventListener('blur', () => {
            console.log('Window blur - clearing input states');
            this.keys = {};
        });
        
        window.addEventListener('focus', () => {
            console.log('Window focus - resetting input states');
            this.keys = {};
        });
        
        // Handle page hide (iOS Safari specific)
        window.addEventListener('pagehide', () => {
            console.log('Page hide - emergency stop');
            this.isRunning = false;
            this.stopGameLoop();
        });
        
        // Handle page show (when returning from background)
        window.addEventListener('pageshow', () => {
            console.log('Page show - clearing states');
            this.keys = {};
        });
    }
}
    /**
     * Load game assets with progress tracking
     */
    loadAssets() {
    let progress = 0;
    const progressFill = document.getElementById('progressFill');
    
    // Array of 10 
    const loadingTips = [
        "Daag vs Fab - epic battle shuru! #FabKaPower #StainSlayer",
        "Politician ka kurta bachao, democracy bachao! #CleanPolitics #FabDefender", 
        "Ande-tamatar ready hai, tu ready hai? #GameOn #FabProtection",
        "Safed kapde = politician ki izzat! #WhiteShirt #FabMagic",
        "Rally mein stains, ghar mein Fab! #DoubleProtection #FabLife",
        "Neta ji ka reputation tera haath mein! #DefendTheLeader #FabShield",
        "Public ka gussa vs Fab ka power! #StainWars #FabVictory",
        "Democracy dirty, lekin kapde clean! #PoliticsVsFab #CleanGame",
        "Tomato missile incoming - Fab shield ready? #StainAttack #FabReady",
        "Game khelo, Fab sikho, hero bano! #GamingLife #FabHero"
    ];
    
    // Select random tip and update the loading tip element
    const randomTip = loadingTips[Math.floor(Math.random() * loadingTips.length)];
    const loadingTipElement = document.querySelector('.loading-tip');
    if (loadingTipElement) {
        loadingTipElement.textContent = randomTip;
    }
    
    const updateProgress = () => {
        progress += 20;
        if (progressFill) {
            progressFill.style.width = progress + '%';
        }
        
        if (progress >= 100) {
            setTimeout(() => this.onAllAssetsLoaded(), 500);
        } else {
            setTimeout(updateProgress, 200);
        }
    };
    
    setTimeout(updateProgress, 300);
}
    
  /**
     * Handle completion of asset loading
     */
   onAllAssetsLoaded() {
    const loadingScreen = document.getElementById('loadingScreen');
    const startScreen = document.getElementById('startScreen');
    
    if (loadingScreen) {
        loadingScreen.style.display = 'none';
        loadingScreen.style.zIndex = '1'; 
    }
    
    if (startScreen) {
        startScreen.classList.remove('hidden');
        startScreen.style.zIndex = '5000'; // Above canvas
    }
    
    this.currentState = this.gameStates.START_SCREEN;
}

    /**
     * Start the game
     */
 startGame() {
    this.debugLog('info', 'startGame() called');
    
    try {
        const startScreen = document.getElementById('startScreen');
        if (startScreen) {
            startScreen.classList.add('hidden');
        }
        
        // CHANGE: Hide body background immediately to prevent yellow flash
        document.body.style.background = 'transparent';
        
        this.currentState = this.gameStates.GAMEPLAY;
        this.isRunning = true;
        this.sessionStartTime = Date.now();

        // Initialize audio system
        if (this.audioManager && !this.audioManager.isInitialized) {
            this.audioManager.initializeAudio();
        }

        // Start background audio
        setTimeout(() => {
            if (this.audioManager) {
                this.audioManager.playBackgroundAudio();
                this.audioManager.loadTier2Sounds();
            }
        }, 1000);
        
        // CHANGE: More aggressive canvas hiding
        this.canvas.style.display = 'none !important';
        this.canvas.style.visibility = 'hidden !important';
        this.canvas.style.opacity = '0 !important';
        
        // Show HUD elements including audio toggle
        const elements = ['gameHUD', 'powerIndicators'];
        elements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.classList.add('show');
            }
        });
        
        // CORRECTED: Properly show audio toggle during gameplay
        const audioToggle = document.getElementById('audioToggle');
        if (audioToggle) {
            audioToggle.classList.add('show');
            audioToggle.style.display = 'flex';
            audioToggle.style.pointerEvents = 'auto';
            audioToggle.style.zIndex = '9999'; 
        }
        
        this.resetGameState();
        
        // CHANGE: Wait for HUD animation to complete
setTimeout(() => {
    // Verify HUD is actually visible and fully rendered
    const gameHUD = document.getElementById('gameHUD');
    const scoreEl = document.getElementById('score');
    const hudReady = gameHUD && 
                   gameHUD.classList.contains('show') && 
                   scoreEl &&
                   getComputedStyle(gameHUD).opacity !== '0' &&
                   parseFloat(getComputedStyle(gameHUD).opacity) >= 1.0;
    
    if (hudReady) {
        console.log('HUD confirmed ready, showing canvas');
        this.canvas.style.display = 'block';
        this.canvas.style.visibility = 'visible';
        this.canvas.style.opacity = '1';
        this.startGameLoop();
    } else {
        console.log('HUD not ready, waiting longer...');
        // Additional wait with retry
        setTimeout(() => {
            console.log('Secondary timeout - showing canvas anyway');
            this.canvas.style.display = 'block';
            this.canvas.style.visibility = 'visible';
            this.canvas.style.opacity = '1';
            this.startGameLoop();
        }, 200);
    }
}, 400); // Increased delay to 400ms total
        
        this.debugLog('info', 'startGame() completed successfully');
    } catch (error) {
        this.debugLog('error', 'startGame() failed', error);
        throw error;
    }
}
    /**
     * Reset game state to initial values
     */
   resetGameState() {
    // Reset score and stats
    this.score = 0;
    this.level = 1;
    this.wave = 1;
    this.politicianHealth = 100;
    this.projectilesBlocked = 0;
    this.projectilesMissed = 0;
    this.survivedWaves = 0;
    
    // Clear game objects
    this.projectiles = [];
    this.particles = [];
    this.trailParticles = [];
    this.projectileSpawnTimer = 1.2;
    this.waveTimer = 0;
    this.cameraShake = { x: 0, y: 0, intensity: 0 };
    
    // Position characters
    const centerX = this.gameWidth / 2;
    const groundY = this.gameHeight * 0.65;
    const isMobileScreen = this.gameWidth < 768;
    
    // Reset aide position
    this.aide.x = centerX - (isMobileScreen ? 90 : 140);
    const basePodiumScale = this.gameWidth / 1400;
    const podiumScale = isMobileScreen ? Math.max(0.8, basePodiumScale) : basePodiumScale;
    const stageY = groundY - 15;
    
    this.aide.y = stageY - this.aide.height - 25;
    this.aide.shield = false;
    this.aide.shieldCooldown = 0;
    this.aide.expression = 'determined';
    this.aide.shieldEnergy = 100;
    
    // Define politician offset variables
    const politicianOffsetX = isMobileScreen ? -40 : -30;
    const politicianOffsetY = isMobileScreen ? -160 : -175;
    
    // Reset politician position
    this.politician.x = centerX + politicianOffsetX;
    this.politician.y = groundY + politicianOffsetY;
    this.politician.hitbox = { 
        x: centerX + politicianOffsetX + (isMobileScreen ? 10 : 10), 
        y: groundY + politicianOffsetY + (isMobileScreen ? 40 : 60),
        width: isMobileScreen ? 40 : 60, 
        height: isMobileScreen ? 60 : 80 
    };
    this.politician.expression = 'speaking';

    // Clear all stains from politician
    this.politician.stains = [];
    this.politician.reactionState = 'normal';
    this.politician.reactionTimer = 0;

    // Add message bubble system
    this.politician.messageBubble = {
        text: '',
        timer: 0,
        isVisible: false,
        fadeIn: 0
    };
    
    // Reset powers
    this.activePowers = { shield: 0, speed: 0, slowmo: 0 };
    // Hide audio toggle when game resets
    const audioToggle = document.getElementById('audioToggle');
    if (audioToggle) {
        audioToggle.classList.remove('show');
    }
}
    /**
     * Reposition characters on screen resize
     */
    repositionCharacters() {
        const centerX = this.gameWidth / 2;
        const groundY = this.gameHeight * 0.65;
        const isMobileScreen = this.gameWidth < 768;
        
        // Reposition aide
        this.aide.x = centerX - (isMobileScreen ? 90 : 140);
        const basePodiumScale = this.gameWidth / 1400;
        const podiumScale = isMobileScreen ? Math.max(0.8, basePodiumScale) : basePodiumScale;
        const stageY = groundY - 15;
        
        this.aide.y = stageY - this.aide.height - 25;
        
        // Reposition politician
        const politicianOffsetX = isMobileScreen ? -40 : -30;
        const politicianOffsetY = isMobileScreen ? -160 : -175;

        this.politician.x = centerX + politicianOffsetX;
        this.politician.y = groundY + politicianOffsetY;
        this.politician.hitbox = { 
            x: centerX + politicianOffsetX + (isMobileScreen ? 10 : 10), 
            y: groundY + politicianOffsetY + (isMobileScreen ? 40 : 60),
            width: isMobileScreen ? 40 : 60, 
            height: isMobileScreen ? 60 : 80 
        };
    }

    /**
     * Activate shield power
     */
    activateShield() {
    if (this.currentState !== this.gameStates.GAMEPLAY) return;
    
    if (this.aide.shieldCooldown <= 0) {
        this.aide.shield = true;
        // Play shield activation sound
    if (this.audioManager) {
    this.audioManager.playSound('shield_activate', {
        volume: 0.7
    });
    
    // Add power-up collection sound for feedback
    setTimeout(() => {
        this.audioManager.playSound('power_up_collect', {
            volume: 0.5
        });
    }, 200);
}
        this.aide.shieldCooldown = 5000; // Longer cooldown
        this.activePowers.shield = 1000;  // Shorter duration
        this.aide.shieldEnergy -= 30;    
        this.showPowerIndicator('shield');
        this.aide.expression = 'focused';
        this.showGameMessage('powerUp');

        // Track shield usage for analytics
        this.analytics.trackPowerUpUsage('shield');
    }
}

activateSlowMotion() {
    if (this.currentState !== this.gameStates.GAMEPLAY) return;
    
    // Toggle functionality - if already active, cancel it
    if (this.activePowers.slowmo > 0) {
        this.activePowers.slowmo = 0;
        console.log('Slow motion cancelled by player');
        return;
    }
    
    // Activate slow motion for 2 seconds
    this.activePowers.slowmo = 2000;
    this.showPowerIndicator('slowmo');
    console.log('Slow motion activated (2 seconds)');

    // Track slowmo usage for analytics
    this.analytics.trackPowerUpUsage('slowmo');
    
    // AUDIO
    if (this.audioManager) {
        this.audioManager.playSound('slowmo_activate', {
            volume: 0.6
        });
    }
}

    /**
     * Show power indicator UI
     * @param {string} type - Power type
     */
    showPowerIndicator(type) {
        const indicator = document.getElementById(type + 'Power');
        if (indicator) {
            indicator.classList.add('active');
            setTimeout(() => {
                indicator.classList.remove('active');
            }, type === 'slowmo' ? 2000 : 1500);
        }
    }

  /**
 * Calculate threat level based on damage
 * @param {number} damage - Projectile damage
 * @returns {string} Threat level
 */
calculateThreatLevel(damage) {
    const threats = this.projectileEffects.threatLevels;
    
    if (damage >= threats.critical.threshold) return 'critical';
    if (damage >= threats.high.threshold) return 'high';
    if (damage >= threats.medium.threshold) return 'medium';
    return 'low';
}

spawnProjectile() {
    // MOBILE: Ultra-conservative spawning
    if (this.isMobile) {
        if (this.projectiles.length >= 1) {
            console.log('Mobile: Skipping spawn, max projectiles reached');
            return; // Only allow 1 projectile at a time on mobile
        }
        
        // Spawn much less frequently on mobile
        if (Math.random() < 0.7) { // 30% chance to skip spawn
            return;
        }
    }
    console.log('ðŸŽª spawnProjectile() called');
    // Mobile projectile limit
    if (this.isMobile && this.projectiles.length >= this.mobileOptimizations.maxProjectiles) {
        console.log('Mobile: Skipping spawn, max projectiles reached:', this.projectiles.length);
        return; // Exit early if mobile has too many projectiles
    }
    console.log('Current projectiles count:', this.projectiles.length);
    
    // Level-based projectile weighting for progressive difficulty
    const levelDangerBonus = Math.min((this.level - 1) * 0.1, 0.4); // Cap at 40% bonus
    
    const types = [
        { name: 'tomato', color: '#FF4757', damage: 15, size: 38, glassTint: '#FF6B6B', weight: Math.max(0.1, 0.3 - levelDangerBonus) },
        { name: 'egg', color: '#FFF8DC', damage: 20, size: 36, glassTint: '#FFFACD', weight: Math.max(0.1, 0.25 - levelDangerBonus) },
        { name: 'shoe', color: '#8B4513', damage: 25, size: 42, glassTint: '#A0522D', weight: 0.2 + levelDangerBonus * 0.5 },
        { name: 'bottle', color: '#228B22', damage: 30, size: 44, glassTint: '#32CD32', weight: 0.15 + levelDangerBonus * 0.3 },
        { name: 'stone', color: '#696969', damage: 35, size: 39, glassTint: '#808080', weight: 0.1 + levelDangerBonus * 0.2 },
        { name: 'banana', color: '#FFD700', damage: 12, size: 40, glassTint: '#FFED4E', weight: Math.max(0.05, 0.15 - levelDangerBonus) },
        { name: 'apple', color: '#DC143C', damage: 18, size: 38, glassTint: '#FF6347', weight: Math.max(0.1, 0.2 - levelDangerBonus * 0.5) }
    ];
    
    console.log('Available projectile types:', types.length);
    
    // Weighted random selection for projectile type
    const totalWeight = types.reduce((sum, t) => sum + t.weight, 0);
    let random = Math.random() * totalWeight;
    let type = types[0];
    
    for (const typeOption of types) {
        random -= typeOption.weight;
        if (random <= 0) {
            type = typeOption;
            break;
        }
    }
    
    console.log('Selected type:', type.name);
    
    // Multi-directional spawn positions
    const crowdPositions = [
        // Left side positions
        { x: 50 + Math.random() * 150, y: 520 + Math.random() * 80 },
        { x: 80 + Math.random() * 120, y: 580 + Math.random() * 60 },
        { x: 30 + Math.random() * 100, y: 550 + Math.random() * 70 },
        
        // Right side positions  
        { x: this.gameWidth - 200 + Math.random() * 150, y: 520 + Math.random() * 80 },
        { x: this.gameWidth - 150 + Math.random() * 120, y: 580 + Math.random() * 60 },
        { x: this.gameWidth - 130 + Math.random() * 100, y: 550 + Math.random() * 70 },
        
        // Center crowd positions
        { x: this.gameWidth * 0.3 + Math.random() * (this.gameWidth * 0.4), y: 540 + Math.random() * 90 },
        { x: this.gameWidth * 0.25 + Math.random() * (this.gameWidth * 0.5), y: 570 + Math.random() * 80 }
    ];

    // Aerial positions (top-down attacks)
    const aerialPositions = [
        { x: this.gameWidth * 0.2 + Math.random() * (this.gameWidth * 0.6), y: -50 },
        { x: this.gameWidth * 0.3 + Math.random() * (this.gameWidth * 0.4), y: -30 },
        { x: this.gameWidth * 0.1 + Math.random() * (this.gameWidth * 0.8), y: -70 }
    ];

    // Side positions (side attacks)
    const sidePositions = [
        { x: -50, y: this.gameHeight * 0.3 + Math.random() * (this.gameHeight * 0.2) },
        { x: this.gameWidth + 50, y: this.gameHeight * 0.3 + Math.random() * (this.gameHeight * 0.2) },
        { x: -30, y: this.gameHeight * 0.4 + Math.random() * (this.gameHeight * 0.15) },
        { x: this.gameWidth + 30, y: this.gameHeight * 0.4 + Math.random() * (this.gameHeight * 0.15) }
    ];

    // Progressive spawn position selection based on level
    const levelProgression = Math.min(this.level, 10) / 10; // 0 to 1 scale
    const aerialChance = 0.1 + (levelProgression * 0.15); // 10% to 25%
    const sideChance = 0.05 + (levelProgression * 0.1);   // 5% to 15%

    let spawnPos;
    const rand = Math.random();

    if (rand < aerialChance) {
        spawnPos = aerialPositions[Math.floor(Math.random() * aerialPositions.length)];
        console.log('Aerial spawn selected');
    } else if (rand < aerialChance + sideChance) {
        spawnPos = sidePositions[Math.floor(Math.random() * sidePositions.length)];
        console.log('Side spawn selected');
    } else {
        spawnPos = crowdPositions[Math.floor(Math.random() * crowdPositions.length)];
        console.log('Crowd spawn selected');
    }
    
    // Target politician
    const targetX = this.politician.x + 40;
    const targetY = this.politician.y + 80;
    const dx = targetX - spawnPos.x;
    const dy = targetY - spawnPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const speed = 600 + this.level * 50;
    
    const projectile = {
        x: spawnPos.x,
        y: spawnPos.y,
        vx: (dx / distance) * speed,
        vy: (dy / distance) * speed,
        type: type.name,
        color: type.color,
        glassTint: type.glassTint,
        damage: type.damage,
        size: type.size + Math.random() * 6,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.3,
        trail: [],
        launchTrailLife: 800, 
        spawnTime: Date.now(),
        
        // Enhanced projectile properties
        threatLevel: this.calculateThreatLevel(type.damage),
        distanceToPolitician: distance,
        warningShown: false,
        enhancedTrail: [],
        glowIntensity: 1.0 + (type.damage / 50),
        impactPredicted: false
    };

    // Track projectile spawn for analytics
    const projectileId = this.analytics.trackProjectileSpawn(projectile);
    projectile.analyticsId = projectileId;

    // Play projectile whoosh sound with positional audio
    if (this.audioManager) {
    // Play swoosh for projectile launch
    this.audioManager.playPositionalSound('swoosh', spawnPos.x, {
        volume: 0.4,
        intensity: 0.8 + Math.random() * 0.4
    });
}
    this.projectiles.push(projectile);
    console.log('âœ… Projectile added. New count:', this.projectiles.length);
    this.debugLog('info', `Enhanced projectile spawned: ${type.name} (threat: ${projectile.threatLevel}) from (${spawnPos.x.toFixed(0)}, ${spawnPos.y.toFixed(0)}) targeting (${targetX}, ${targetY})`);
    this.debugLog('debug', `Total projectiles: ${this.projectiles.length}`);
}

   /**
 * Show game results screen
 */
showResults() {
    // IMMEDIATE BROWN OVERLAY PREVENTION
    this.canvas.style.display = 'none';
    this.canvas.style.visibility = 'hidden';
    this.canvas.style.background = '#87CEEB';
    this.ctx.fillStyle = '#87CEEB';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Set state and stop game immediately to prevent stuck screen
    this.currentState = this.gameStates.GAME_OVER;
    this.isRunning = false;
   
    // IMMEDIATE MESSAGE CLEANUP 
    this.hideGameMessage();
    this.messageSystem.isActive = false;
    this.messageSystem.messageTimer = 0;
    
    // Clear the canvas immediately to remove any lingering gameplay graphics
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Stop all game audio except UI sounds
    if (this.audioManager) {
        this.audioManager.stopAllSounds();
    }
    
    // Hide audio toggle on results screen
    const audioToggle = document.getElementById('audioToggle');
    if (audioToggle) {
        audioToggle.classList.remove('show');
        audioToggle.style.display = 'none';
    }
    
    // Hide HUD elements
    const hudElements = ['gameHUD', 'levelInfo', 'powerIndicators'];
    hudElements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.classList.remove('show');
        }
    });
    
    // Calculate statistics
    const sessionDuration = Math.floor((Date.now() - this.sessionStartTime) / 1000);
    const accuracy = this.projectilesBlocked + this.projectilesMissed > 0 ? 
        Math.round((this.projectilesBlocked / (this.projectilesBlocked + this.projectilesMissed)) * 100) : 0;
    
    const performanceRating = this.calculatePerformanceRating(accuracy, this.survivedWaves, sessionDuration);

    // Generate comprehensive session analytics
    const sessionAnalytics = this.analytics.calculateSessionAnalytics();
    console.log("Session Analytics:", sessionAnalytics);

    // Store analytics for potential display or export
    this.lastSessionAnalytics = sessionAnalytics;

    setTimeout(() => {
        this.displayPerformanceRating(performanceRating);
    }, 1800);

    // QR code generation
    setTimeout(() => {
        generateQRCode();
    }, 2000);
    
    // Update UI with delays
    setTimeout(() => {
        this.animateCounterUp('finalScore', this.score, 1500);
        
        setTimeout(() => {
            const sessionTimeEl = document.getElementById('sessionTime');
            if (sessionTimeEl) {
                sessionTimeEl.textContent = this.formatTime(sessionDuration);
            }
        }, 300);
        
        setTimeout(() => {
            this.animateCounterUp('accuracyPercent', accuracy, 1000, '%');
        }, 600);
        
        setTimeout(() => {
            const hitStatsEl = document.getElementById('hitStats');
            if (hitStatsEl) {
                hitStatsEl.textContent = `${this.projectilesBlocked}/${this.projectilesBlocked + this.projectilesMissed}`;
            }
        }, 900);
        
        setTimeout(() => {
            this.animateCounterUp('blockedCount', this.projectilesBlocked, 800);
        }, 1200);
        
        setTimeout(() => {
            this.displayPerformanceRating(performanceRating);
        }, 1800);
        
    }, 200);
    
    this.playResultsSound(performanceRating);
    this.checkAchievements(accuracy, this.survivedWaves, sessionDuration);
    
    setTimeout(() => {
        const resultsScreen = document.getElementById('resultsScreen');
        if (resultsScreen) {
            resultsScreen.classList.add('show');
        }
        
        // Ensure 3D canvas exists before attempting initialization
        setTimeout(() => {
            const container = document.getElementById('product3DContainer');
            if (container) {
                let canvas = document.getElementById('product3DCanvas');
                if (!canvas) {
                    debug3DViewer('ENSURING_CANVAS', 'Creating missing canvas element');
                    canvas = document.createElement('canvas');
                    canvas.id = 'product3DCanvas';
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.display = 'block';
                    container.appendChild(canvas);
                }
            }
        }, 100); // Run this before the 3D viewer initialization
        
        // Initialize 3D Product Viewer with enhanced error handling and debugging
        if (!window.pending3DViewerTimeouts) {
            window.pending3DViewerTimeouts = [];
        }

        debug3DViewer('TIMEOUT_SCHEDULED', '1200ms delay');

        const timeoutId = setTimeout(() => {
            debug3DViewer('TIMEOUT_EXECUTING', 'Starting 3D viewer initialization');
            
            // Remove this timeout from tracking array once it executes
            const index = window.pending3DViewerTimeouts.indexOf(timeoutId);
            if (index > -1) {
                window.pending3DViewerTimeouts.splice(index, 1);
                debug3DViewer('TIMEOUT_CLEANUP', 'Removed from tracking array');
            }
            
            // DEFENSIVE CHECK: Skip if game is restarting or not in game over state
            if (!window.game || window.game.currentState !== window.game.gameStates.GAME_OVER) {
                debug3DViewer('SKIP', `Game state check failed. State: ${window.game ? window.game.currentState : 'no game'}`);
                console.log('Skipping 3D viewer init - game not in results state');
                return;
            }

            // Additional check: ensure results screen is still visible
            const resultsScreen = document.getElementById('resultsScreen');
            if (!resultsScreen || !resultsScreen.classList.contains('show')) {
                debug3DViewer('SKIP', `Results screen check failed. Element: ${!!resultsScreen}, hasShow: ${resultsScreen ? resultsScreen.classList.contains('show') : 'N/A'}`);
                console.log('Skipping 3D viewer init - results screen no longer visible');
                return;
            }

            debug3DViewer('CHECKS_PASSED', 'All defensive checks passed');

            try {
                if (typeof Product3DViewer !== 'undefined' && typeof THREE !== 'undefined') {
                    const canvas = document.getElementById('product3DCanvas');
                    const container = document.getElementById('product3DContainer');
                    
                    debug3DViewer('DOM_CHECK', `canvas: ${!!canvas}, container: ${!!container}`);
                    
                    // If canvas is missing but container exists, recreate the canvas
                    if (!canvas && container) {
                        debug3DViewer('RECREATING_CANVAS', 'Canvas missing, recreating it');
                        const newCanvas = document.createElement('canvas');
                        newCanvas.id = 'product3DCanvas';
                        newCanvas.style.width = '100%';
                        newCanvas.style.height = '100%';
                        newCanvas.style.display = 'block';
                        container.appendChild(newCanvas);
                        debug3DViewer('CANVAS_RECREATED', 'New canvas element created and added');
                    }
                    
                    // Re-query elements after potential recreation
                    const finalCanvas = document.getElementById('product3DCanvas');
                    const finalContainer = document.getElementById('product3DContainer');
                    
                    if (finalCanvas && finalContainer) {
                        // Clean up any existing viewer first
                        if (window.product3DViewer) {
                            debug3DViewer('CLEANUP', 'Destroying existing viewer');
                            try {
                                window.product3DViewer.destroy();
                            } catch (error) {
                                debug3DViewer('CLEANUP_ERROR', error.message);
                                console.warn('Error cleaning up existing 3D viewer:', error);
                            }
                            window.product3DViewer = null;
                        }
                        
                        debug3DViewer('INITIALIZING', 'Creating new Product3DViewer');
                        window.product3DViewer = new Product3DViewer('product3DCanvas', 'product3DContainer');
                        debug3DViewer('SUCCESS', '3D Product Viewer initialized successfully');
                        console.log('3D Product Viewer initialized successfully');
                    } else {
                        debug3DViewer('ERROR', 'Canvas or container elements still not available after recreation attempt');
                        console.warn('3D viewer canvas or container not found');
                    }
                } else {
                    debug3DViewer('ERROR', `Product3DViewer: ${typeof Product3DViewer}, THREE: ${typeof THREE}`);
                    console.warn('Product3DViewer or THREE.js not available');
                }
            } catch (error) {
                debug3DViewer('EXCEPTION', error.message);
                console.error('Failed to initialize 3D Product Viewer:', error);
            }
        }, 1200);

        // Track this timeout for potential cancellation
        window.pending3DViewerTimeouts.push(timeoutId);
        debug3DViewer('TIMEOUT_TRACKED', `Timeout ID: ${timeoutId}, Total tracked: ${window.pending3DViewerTimeouts.length}`);

    }, 500);
}
 /**
 * Calculate performance rating based on comprehensive metrics (no waves)
 * @param {number} accuracy - Accuracy percentage
 * @param {number} waves - Waves survived (not used)
 * @param {number} duration - Session duration in seconds
 * @returns {string} Performance rating
 */
calculatePerformanceRating(accuracy, waves, duration) {
    let totalScore = 0;
    const maxScore = 100; // This is the internal rating scale (0-100)
    
    // Score contribution (40% weight) - Based on realistic game score benchmarks
    let scoreContribution = 0;
    if (this.score >= 5000) scoreContribution = 40;        // Legendary: 5000+ points
    else if (this.score >= 3000) scoreContribution = 32;   // Excellent: 3000+ points  
    else if (this.score >= 1500) scoreContribution = 24;   // Good: 1500+ points
    else if (this.score >= 750) scoreContribution = 16;    // Fair: 750+ points
    else if (this.score >= 300) scoreContribution = 8;     // Basic: 300+ points
    else scoreContribution = (this.score / 300) * 8;       // Proportional below 300
    
    totalScore += scoreContribution;
    
    // Accuracy contribution (30% weight) - More realistic thresholds
    let accuracyContribution = 0;
    if (accuracy >= 85) accuracyContribution = 30;
    else if (accuracy >= 70) accuracyContribution = 24;
    else if (accuracy >= 55) accuracyContribution = 18;
    else if (accuracy >= 40) accuracyContribution = 12;
    else if (accuracy >= 25) accuracyContribution = 6;
    else accuracyContribution = (accuracy / 25) * 6;       // Proportional below 25%
    
    totalScore += accuracyContribution;
    
    // Duration bonus (15% weight) - Reasonable time expectations
    let durationContribution = 0;
    if (duration >= 180) durationContribution = 15;        // 3+ minutes
    else if (duration >= 120) durationContribution = 12;   // 2+ minutes  
    else if (duration >= 90) durationContribution = 9;     // 1.5+ minutes
    else if (duration >= 60) durationContribution = 6;     // 1+ minute
    else if (duration >= 30) durationContribution = 3;     // 30+ seconds
    else durationContribution = (duration / 30) * 3;       // Proportional below 30s
    
    totalScore += durationContribution;
    
    // Projectiles blocked bonus (15% weight) - Combat performance
    let blockedBonus = 0;
    if (this.projectilesBlocked >= 30) blockedBonus = 15;
    else if (this.projectilesBlocked >= 20) blockedBonus = 12;
    else if (this.projectilesBlocked >= 15) blockedBonus = 9;
    else if (this.projectilesBlocked >= 10) blockedBonus = 6;
    else if (this.projectilesBlocked >= 5) blockedBonus = 3;
    else blockedBonus = (this.projectilesBlocked / 5) * 3; // Proportional below 5
    
    totalScore += blockedBonus;
    
    // Debug logging for transparency
    console.log(`Performance Rating Debug:
        Game Score: ${this.score} (rating points: ${scoreContribution.toFixed(1)}/40)
        Accuracy: ${accuracy}% (rating points: ${accuracyContribution}/30)
        Duration: ${duration}s (rating points: ${durationContribution}/15)
        Blocked: ${this.projectilesBlocked} (rating points: ${blockedBonus.toFixed(1)}/15)
        Total Rating Score: ${totalScore.toFixed(1)}/${maxScore}`);
    
    // Determine rating based on total score
    if (totalScore >= 85) return 'legendary';        // 85-100: Exceptional performance
    else if (totalScore >= 70) return 'excellent';   // 70-84: Very good performance
    else if (totalScore >= 50) return 'good';        // 50-69: Good performance
    else if (totalScore >= 30) return 'fair';        // 30-49: Fair performance  
    else return 'needs_improvement';                  // 0-29: Needs improvement
}


/**
 * Get detailed performance breakdown for debugging
 * @returns {Object} Performance metrics breakdown
 */
getPerformanceBreakdown() {
    const sessionDuration = Math.floor((Date.now() - this.sessionStartTime) / 1000);
    const accuracy = this.projectilesBlocked + this.projectilesMissed > 0 ? 
        Math.round((this.projectilesBlocked / (this.projectilesBlocked + this.projectilesMissed)) * 100) : 0;
    
    return {
        score: this.score,
        accuracy: accuracy,
        projectilesBlocked: this.projectilesBlocked,
        projectilesMissed: this.projectilesMissed,
        survivedWaves: this.survivedWaves,
        sessionDuration: sessionDuration,
        politicianHealthRemaining: this.politicianHealth,
        level: this.level,
        currentWave: this.wave
    };
}
    /**
     * Animate counter numbers
     * @param {string} elementId - Element ID
     * @param {number} targetValue - Target value
     * @param {number} duration - Animation duration
     * @param {string} suffix - Text suffix
     */
    animateCounterUp(elementId, targetValue, duration, suffix = '') {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        const startValue = 0;
        const increment = targetValue / (duration / 16);
        let currentValue = startValue;
        
        const timer = setInterval(() => {
            currentValue += increment;
            if (currentValue >= targetValue) {
                currentValue = targetValue;
                clearInterval(timer);
            }
            
            if (elementId === 'finalScore') {
                element.textContent = Math.floor(currentValue).toLocaleString() + suffix;
            } else {
                element.textContent = Math.floor(currentValue) + suffix;
            }
        }, 16);
    }

    /**
     * Format time display
     * @param {number} seconds - Seconds
     * @returns {string} Formatted time
     */
    formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

 /**
 * Display performance rating 
 * @param {string} rating - Performance rating
 */
displayPerformanceRating(rating) {
    const ratingElement = document.getElementById('performanceRating');
    if (!ratingElement) return;
    
    const ratings = {
        'legendary': { 
            text: 'ðŸ† LEGENDARY! Daag ki band bajaa di!', 
            class: 'rating-legendary', 
            color: '#1A2F85'
        },
        'excellent': { 
            text: 'â­ Wah bhai! Fab-tastic Defense!', 
            class: 'rating-excellent', 
            color: '#0097D7'
        },
        'good': { 
            text: 'ðŸ‘ Solid hai! Daag bhaag gaye.', 
            class: 'rating-good', 
            color: '#EF3E42'
        },
        'fair': { 
            text: 'ðŸ“ˆ Theek thaak, aur koshish kar!', 
            class: 'rating-fair', 
            color: '#00A859'
        },
        'needs_improvement': { 
            text: 'ðŸ’ª Abhi practice karo yaar!', 
            class: 'rating-poor', 
            color: '#000000'
        }
    };
    
    const ratingData = ratings[rating];
    ratingElement.textContent = ratingData.text;
    ratingElement.className = `performance-rating ${ratingData.class}`;
    ratingElement.style.color = ratingData.color;
    ratingElement.style.animation = 'pulse 0.6s ease-in-out';
    
    // Debug logging with actual performance data
    const breakdown = this.getPerformanceBreakdown();
    console.log(`Performance Rating: ${rating} - ${ratingData.text}`);
    console.log('Performance breakdown:', breakdown);
    
    if (rating === 'legendary') {
        this.addScreenFlashEffect();
    }
}

    /**
     * Add screen flash effect
     */
    addScreenFlashEffect() {
        const flashOverlay = document.createElement('div');
        flashOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%);
            pointer-events: none;
            z-index: 9999;
            animation: flashEffect 0.8s ease-out;
        `;
        
        document.body.appendChild(flashOverlay);
        
        setTimeout(() => {
            document.body.removeChild(flashOverlay);
        }, 800);
    }

/**
 * Play results sound
 * @param {string} rating - Performance rating
 */
playResultsSound(rating) {
    if (!this.audioManager) return;
    
    // Map performance ratings to available sounds using playSound method
    const soundMap = {
        'legendary': 'victory_sound',
        'excellent': 'victory_sound', 
        'good': 'combo_achievement',
        'fair': 'ui_click',
        'needs_improvement': 'health_critical'
    };
    
    const soundToPlay = soundMap[rating] || 'ui_click';
    
    // Use playSound method instead of checking soundLibrary
    this.audioManager.playSound(soundToPlay, {
        volume: 0.8
    });
}
    /**
     * Check for achievements
     * @param {number} accuracy - Accuracy percentage
     * @param {number} waves - Waves survived
     * @param {number} duration - Session duration
     */
    checkAchievements(accuracy, waves, duration) {
        const achievements = [];
        
        // Accuracy achievements
        if (accuracy === 100) {
            achievements.push({ name: 'Perfect Aim', description: '100% Accuracy!' });
        } else if (accuracy >= 95) {
            achievements.push({ name: 'Sharp Shooter', description: '95%+ Accuracy!' });
        }
        
        // Wave survival achievements
        if (waves >= 20) {
            achievements.push({ name: 'Wave Master', description: 'Survived 20+ waves!' });
        } else if (waves >= 15) {
            achievements.push({ name: 'Seasoned Defender', description: 'Survived 15+ waves!' });
        } else if (waves >= 10) {
            achievements.push({ name: 'Steady Guardian', description: 'Survived 10+ waves!' });
        }
        
        // Duration achievements
        if (duration >= 600) {
            achievements.push({ name: 'Marathon Defender', description: 'Defended for 10+ minutes!' });
        } else if (duration >= 300) {
            achievements.push({ name: 'Persistent Protector', description: 'Defended for 5+ minutes!' });
        }
        
        // Score achievements
        if (this.score >= 100000) {
            achievements.push({ name: 'Score Champion', description: '100,000+ points!' });
        } else if (this.score >= 50000) {
            achievements.push({ name: 'High Scorer', description: '50,000+ points!' });
        }
        
        if (achievements.length > 0) {
            this.displayAchievements(achievements);
        }
    }

    /**
     * Display earned achievements
     * @param {Array} achievements - Achievement array
     */
    displayAchievements(achievements) {
        const achievementContainer = document.getElementById('achievements');
        if (!achievementContainer) return;
        
        achievementContainer.innerHTML = '';
        achievements.forEach((achievement, index) => {
            setTimeout(() => {
                const achievementElement = document.createElement('div');
                achievementElement.className = 'achievement-item';
                achievementElement.innerHTML = `
                    <div class="achievement-icon">ðŸ†</div>
                    <div class="achievement-text">
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-desc">${achievement.description}</div>
                    </div>
                `;
                achievementContainer.appendChild(achievementElement);
                
                setTimeout(() => {
                    achievementElement.style.animation = 'slideInRight 0.5s ease-out';
                }, 50);
            }, index * 500);
        });
    }

    /**
     * Start the main game loop
     */
  // 3. SAFER GAME LOOP WITH MOBILE SAFEGUARDS
startGameLoop() {
    let frameCount = 0;
    let lastFPSTime = performance.now();
    let frameSkipCounter = 0;
    let errorCount = 0;
    let lastUpdateTime = 0;
    const maxErrors = 5; // Reduced from 10
    
    this.gameLoopId = null;
    
    const gameLoop = (currentTime) => {
        this.gameLoopId = null;
        
        try {
            // CRITICAL: More aggressive exit conditions
            if (!this.isRunning || 
                this.currentState !== this.gameStates.GAMEPLAY ||
                this.politicianHealth <= 0 ||
                errorCount >= maxErrors ||
                !document.hasFocus()) { // Stop when page loses focus
                
                console.log("Game loop stopped - condition failed");
                this.stopGameLoop();
                return;
            }
            
            // NEW TIME-BASED THROTTLING (replace with this):
if (this.isMobile) {
    const now = performance.now();
    if (!this.lastMobileFrame) this.lastMobileFrame = 0;
    
    // Throttle to max 20 FPS (50ms intervals)
    if (now - this.lastMobileFrame < 50) {
        this.gameLoopId = requestAnimationFrame(gameLoop);
        return;
    }
    this.lastMobileFrame = now;
}
            
            // CRITICAL: Throttle update frequency on mobile
            const now = performance.now();
            if (this.isMobile && (now - lastUpdateTime) < 66) { // Limit to 15fps max
                this.gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }
            lastUpdateTime = now;
            
            const frameStart = performance.now();
            
            // Cap deltaTime more aggressively for mobile stability
            this.deltaTime = Math.min((currentTime - this.lastTime) / 1000, this.isMobile ? 0.05 : 0.033);
            this.lastTime = currentTime;
            
            // CRITICAL: Wrap update and render in separate try-catch
            try {
                this.update(this.deltaTime);
            } catch (updateError) {
                console.error('Update error:', updateError);
                errorCount++;
            }
            
            try {
                this.render();
            } catch (renderError) {
                console.error('Render error:', renderError);
                errorCount++;
            }
            
            // Mobile performance monitoring
            const frameTime = performance.now() - frameStart;
            if (this.isMobile && frameTime > 50) { // Frame took longer than 50ms
                console.warn(`Mobile frame overrun: ${frameTime.toFixed(2)}ms`);
                errorCount++; // Count slow frames as errors
            }
            
            // Continue only if everything is still OK
            if (this.isRunning && 
                this.currentState === this.gameStates.GAMEPLAY && 
                this.politicianHealth > 0 &&
                errorCount < maxErrors) {
                this.gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                console.log('Game loop natural end');
                this.stopGameLoop();
            }
            
        } catch (error) {
            errorCount++;
            console.error(`Critical game loop error ${errorCount}/${maxErrors}:`, error);
            
            if (errorCount >= maxErrors) {
                console.error('Too many errors, emergency stop');
                this.stopGameLoop();
                // Show user-friendly error
                setTimeout(() => {
                    alert('Game encountered errors. Refreshing page...');
                    window.location.reload();
                }, 100);
            } else {
                this.gameLoopId = requestAnimationFrame(gameLoop);
            }
        }
    };
    
    console.log('Starting mobile-optimized game loop');
    this.gameLoopId = requestAnimationFrame(gameLoop);
}

stopGameLoop() {
    console.log('ðŸ›‘ stopGameLoop() - Comprehensive cleanup initiated');
    
    // CRITICAL: Immediately set running flag to false
    this.isRunning = false;
    
    // CRITICAL: Cancel any pending animation frames
    if (this.gameLoopId) {
        cancelAnimationFrame(this.gameLoopId);
        this.gameLoopId = null;
        console.log('âœ… Animation frame cancelled');
    }
    
    // IMMEDIATE CANVAS CLEANUP - Prevents brown overlay completely
    if (this.canvas && this.ctx) {
        // Clear all canvas content immediately
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Reset canvas transform to prevent stuck transformations
        this.ctx.resetTransform();
        
        // Clear any lingering canvas styles that might cause overlay
        this.ctx.globalAlpha = 1.0;
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.filter = 'none';
        
        // Hide canvas immediately
        this.canvas.style.display = 'none';
        this.canvas.style.visibility = 'hidden';
        this.canvas.style.opacity = '0';
        
        console.log('âœ… Canvas cleared and hidden');
    }
    
    // CLEAR ALL GAME OBJECTS - Prevents lingering renders
    this.projectiles = [];
    this.particles = [];
    this.trailParticles = [];
    
    // Clear atmospheric particles that contribute to brown overlay
    if (this.atmosphericSystem && this.atmosphericSystem.particles) {
        this.atmosphericSystem.particles = [];
    }
    
    // Reset camera effects
    this.cameraShake = { x: 0, y: 0, intensity: 0 };
    
    // Clear screen effects that might cause overlay
    if (this.screenEffects) {
        this.screenEffects.flash.active = false;
        this.screenEffects.colorOverlay.active = false;
        this.screenEffects.slowMotion.active = false;
    }
    
    // STOP MESSAGE SYSTEM - Prevents UI conflicts
    if (this.messageSystem) {
        this.hideGameMessage();
        this.messageSystem.isActive = false;
        this.messageSystem.messageTimer = 0;
        this.messageSystem.currentMessage = '';
    }
    
    // AUDIO CLEANUP - Stop all game audio
    if (this.audioManager) {
        this.audioManager.stopAllSounds();
        console.log('âœ… All audio stopped');
    }
    
    // CLEAR CACHED CROWD - Prevents brown crowd overlay
    this.crowdCache = null;
    
    // RESET ANIMATION TIMERS - Prevents stuck animations
    if (this.characterAnimTimers) {
        this.characterAnimTimers.politician = 0;
        this.characterAnimTimers.aide = 0;
    }
    
    if (this.crowdAnimation) {
        this.crowdAnimation.time = 0;
    }
    
    // FORCE GARBAGE COLLECTION HINTS (where supported)
    if (window.gc && typeof window.gc === 'function') {
        try {
            window.gc();
        } catch (e) {
            // Garbage collection not available, continue
        }
    }
    
    console.log('ðŸ”’ Game loop forcibly stopped - Brown overlay prevented');
}

    /**
     * Update game logic
     * @param {number} deltaTime - Time delta
     */
  update(deltaTime) {
    if (this.currentState !== this.gameStates.GAMEPLAY) return;
    
    // MOBILE: Run memory optimization every 30 frames instead of 60
    if (this.isMobile) {
        if (!this.mobileFrameCount) this.mobileFrameCount = 0;
        this.mobileFrameCount++;
        
        // CHANGE THIS: More frequent cleanup - every 30 frames instead of 60
        if (this.mobileFrameCount % 30 === 0) {
            this.optimizeMemoryForMobile();
        }
        
        // Cap deltaTime more aggressively
        deltaTime = Math.min(deltaTime, 0.05); // Changed from 0.033 to 0.05
    }
    
    const timeMultiplier = this.activePowers.slowmo > 0 ? 0.5 : 1.0; // Less dramatic slowmo
    const adjustedDelta = deltaTime * timeMultiplier;

    // Update politician reaction timer
    if (this.politician.reactionTimer > 0) {
        this.politician.reactionTimer -= deltaTime * 1000;
        if (this.politician.reactionTimer <= 0) {
            this.politician.reactionState = 'normal';
            console.log('Politician returned to normal state');
        }
    }

    // Update message bubble
    if (this.politician.messageBubble.isVisible) {
        this.politician.messageBubble.timer -= deltaTime * 1000;
        this.politician.messageBubble.fadeIn = Math.min(1, this.politician.messageBubble.fadeIn + deltaTime * 4);
        
        if (this.politician.messageBubble.timer <= 0) {
            this.politician.messageBubble.isVisible = false;
        }
    }
        
    this.updatePowerUps(deltaTime);
    this.updateCharacterAnimations(deltaTime);
    this.updateCrowdAnimations(deltaTime);
    this.updateAide(adjustedDelta);
    this.updateProjectiles(adjustedDelta);
    this.updateProjectileEffects(deltaTime);
    this.updateParticles(adjustedDelta);
    this.updateTimers(deltaTime);
    this.updateCameraShake(deltaTime);
    this.updateScreenEffects(deltaTime);
    this.updateMessageSystem(deltaTime);
    this.updateReactionSystem(deltaTime);
    this.updateAtmosphericSystem(deltaTime);
    this.checkCollisions();
    this.updateUI();

    // ADD THIS BLOCK - Mobile memory management
    if (this.isMobile) {
        // Increment frame counter
        if (!this.renderFrameId) this.renderFrameId = 0;
        this.renderFrameId++;
        
        // Run optimization every 3 seconds (180 frames at 60fps, 90 frames at 30fps)
        if (this.renderFrameId % 180 === 0) {
            this.optimizeMemoryForMobile();
        }
    }
}
  
//AGGRESSIVE MOBILE MEMORY MANAGEMENT
optimizeMemoryForMobile() {
    if (!this.isMobile) return;
    
    // NUCLEAR memory cleanup - more aggressive than current
    
    // 1. Eliminate ALL particles immediately
    this.particles = [];
    this.trailParticles = [];
    
    // 2. Limit projectiles to absolute minimum
    if (this.projectiles.length > 1) {
        this.projectiles = [this.projectiles[this.projectiles.length - 1]]; // Keep only newest
    }
    
    // 3. Clear atmospheric particles completely
    if (this.atmosphericSystem && this.atmosphericSystem.particles) {
        this.atmosphericSystem.particles = [];
    }
    
    // 4. Clear all analytics on mobile to free memory
    if (this.analytics) {
        this.analytics.projectileAnalytics = this.analytics.projectileAnalytics.slice(-5); // Keep only last 5
        this.analytics.reactionTimeData = this.analytics.reactionTimeData.slice(-10); // Keep only last 10
        this.analytics.defensePatterns = this.analytics.defensePatterns.slice(-10); // Keep only last 10
    }
    
    // 5. Clear message system immediately
    if (this.messageSystem) {
        this.messageSystem.isActive = false;
        this.messageSystem.currentMessage = '';
        this.messageSystem.messageTimer = 0;
    }
    
    // 6. Limit politician stains
    if (this.politician && this.politician.stains && this.politician.stains.length > 3) {
        this.politician.stains = this.politician.stains.slice(-3); // Keep only last 3
    }
    
    // 7. Clear any cached data
    this.crowdCache = null;
    
    // 8. Force garbage collection if available
    if (window.gc && typeof window.gc === 'function') {
        try {
            window.gc();
        } catch (e) {}
    }
    
    console.log('MOBILE: Nuclear memory cleanup performed');
}

    /**
     * Update power-ups
     * @param {number} deltaTime - Time delta
     */
    updatePowerUps(deltaTime) {
        Object.keys(this.activePowers).forEach(power => {
            if (this.activePowers[power] > 0) {
                this.activePowers[power] -= deltaTime;
            }
        });
        
        if (this.aide.shieldCooldown > 0) {
            this.aide.shieldCooldown -= deltaTime;
        }
        
        if (this.activePowers.shield <= 0) {
            this.aide.shield = false;
        }
    }

    /**
 * Update health bar visual state
 */
updateHealthBarStyling() {
    const healthFillEl = document.getElementById('healthFill');
    if (!healthFillEl) return;
    
    const healthPercent = Math.max(0, (this.politicianHealth / this.maxHealth) * 100);
    
    // Remove existing health state classes
    healthFillEl.classList.remove('health-critical', 'health-warning', 'health-good');
    
    // Add appropriate class based on health level
    if (healthPercent <= 25) {
        healthFillEl.classList.add('health-critical');
    } else if (healthPercent <= 50) {
        healthFillEl.classList.add('health-warning');
    } else {
        healthFillEl.classList.add('health-good');
    }
}

    /**
     * Update aide character
     * @param {number} deltaTime - Time delta
     */
   updateAide(deltaTime) {
    let moveSpeed = this.aide.speed;
    if (this.activePowers.speed > 0) moveSpeed *= 1.8;
    if (this.isMobile) moveSpeed *= 1.2;
    
    let moved = false;
    
    // Input handling
    const moveUp = this.keys['KeyW'] || this.keys['ArrowUp'] || this.touchControls.up;
    const moveDown = this.keys['KeyS'] || this.keys['ArrowDown'] || this.touchControls.down;
    const moveLeft = this.keys['KeyA'] || this.keys['ArrowLeft'] || this.touchControls.left;
    const moveRight = this.keys['KeyD'] || this.keys['ArrowRight'] || this.touchControls.right;
    
    if (moveUp) {
        this.aide.y -= moveSpeed * deltaTime;
        moved = true;
    }
    if (moveDown) {
        this.aide.y += moveSpeed * deltaTime;
        moved = true;
    }
    if (moveLeft) {
        this.aide.x -= moveSpeed * deltaTime;
        this.aide.facingDirection = -1;
        this.aide.spriteFlipped = true; 
        moved = true;
    }
    if (moveRight) {
        this.aide.x += moveSpeed * deltaTime;
        this.aide.facingDirection = 1;
        this.aide.spriteFlipped = false; 
        moved = true;
    }
    
    // Animation and effects
    if (moved) {
        this.aide.bounceY = Math.sin(Date.now() * 0.02) * 2 - 5;
        
        if (Math.random() < 0.7) {
            this.createTrailParticle(
                this.aide.x + this.aide.width/2 + (Math.random() - 0.5) * 20,
                this.aide.y + this.aide.height/2 + (Math.random() - 0.5) * 20,
                -moveSpeed * deltaTime * (Math.random() * 0.5 + 0.5),
                (Math.random() - 0.5) * 100
            );
        }
    } else {
        this.aide.bounceY = Math.sin(Date.now() * 0.01) * 1 - 5;
    }

      // Slowly regenerate shield energy
      if (this.aide.shieldEnergy < this.aide.maxShieldEnergy) {
          this.aide.shieldEnergy += 8 * deltaTime; // Regen rate
          this.aide.shieldEnergy = Math.min(this.aide.maxShieldEnergy, this.aide.shieldEnergy);
    }
    
// Enhanced boundary constraints for aerial defense
const marginX = this.gameWidth * 0.05;
const marginY = this.gameHeight * 0.05;
const groundY = this.gameHeight * 0.65;
const maxX = this.gameWidth - this.aide.width - marginX;
const maxY = this.gameHeight - this.aide.height - marginY;

// Expanded movement area for aerial defense
const expandedMinY = this.gameHeight * 0.2; // move higher
const stageMinY = groundY - this.aide.height; // stage constraint

// Check for aerial threats that require expanded movement
const hasAerialThreats = this.projectiles.some(proj => 
    proj.y < this.gameHeight * 0.4 && 
    Math.abs(proj.x - (this.aide.x + this.aide.width/2)) < 200
);

// Use expanded area during aerial threats, stage area otherwise
const activeMinY = hasAerialThreats ? expandedMinY : stageMinY;

// Apply movement speed bonus when moving toward aerial threats
if (hasAerialThreats && (this.keys['KeyW'] || this.keys['ArrowUp'] || this.touchControls.up)) {
    moveSpeed *= 1.3; // 30% speed boost when moving up toward aerial threats
    this.aide.expression = 'focused'; // Visual feedback
}

this.aide.x = Math.max(marginX, Math.min(maxX, this.aide.x));
this.aide.y = Math.max(activeMinY, Math.min(maxY, this.aide.y));
}
    /**
     * Update projectiles
     * @param {number} deltaTime - Time delta
     */
    updateProjectiles(deltaTime) {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];

             // ADD SAFETY CHECK - Initialize trail if missing
            if (!proj.trail) {
            proj.trail = [];
           }
            
              // Add to trail
            proj.trail.push({ x: proj.x, y: proj.y });
            if (proj.trail.length > 5) proj.trail.shift();
            
            proj.x += proj.vx * deltaTime;
            proj.y += proj.vy * deltaTime;
            proj.rotation += proj.rotationSpeed;
            
            // Apply gravity
            proj.vy += 50 * deltaTime;
            
            // Remove if out of bounds
            if (proj.x < -200 || proj.x > this.gameWidth + 200 || 
                proj.y > this.gameHeight + 200 || proj.y < -200) {
            if (this.audioManager && proj.y > this.gameHeight + 100) {
            // Only play miss sound if projectile went past the politician
                this.audioManager.playSound('miss', {
                volume: 0.3,
                pan: (proj.x / this.gameWidth - 0.5) * 2
            });
            }    
                this.projectiles.splice(i, 1);
                continue;
            }
            
            // Check politician collision
            if (this.isColliding(proj, this.politician.hitbox)) {
                this.hitPolitician(proj);
                this.projectiles.splice(i, 1);
                this.projectilesMissed++;
                this.debugLog('warn', `Politician hit! Health: ${this.politicianHealth} (-${proj.damage})`);
            }
        }
    }

 /**
 * Update projectile trails and effects
 * @param {number} deltaTime - Time delta
 */
updateProjectileEffects(deltaTime) {
    // Simplified projectile effects for mobile
    if (this.isMobile) {
        // Only basic distance tracking on mobile
        this.projectiles.forEach(proj => {
            const dx = proj.x - (this.politician.x + this.politician.width/2);
            const dy = proj.y - (this.politician.y + this.politician.height/2);
            proj.distanceToPolitician = Math.sqrt(dx * dx + dy * dy);
        });
        return; // Skip all enhanced effects
    }
    
    // Full desktop effects 
    this.projectiles.forEach(proj => {
        // Update enhanced trail system
        this.updateEnhancedTrail(proj, deltaTime);
        
        // Check for impact prediction
        this.updateImpactPrediction(proj);
        
        // Update threat warnings
        this.updateThreatWarnings(proj);
        
        // Update distance to politician
        const dx = proj.x - (this.politician.x + this.politician.width/2);
        const dy = proj.y - (this.politician.y + this.politician.height/2);
        proj.distanceToPolitician = Math.sqrt(dx * dx + dy * dy);
    });
    
    // Clean up old warning indicators
    this.projectileEffects.warningIndicators = this.projectileEffects.warningIndicators.filter(
        indicator => indicator.life > 0
    );
    
    // Update warning indicators
    this.projectileEffects.warningIndicators.forEach(indicator => {
        indicator.life -= deltaTime;
        indicator.alpha = Math.max(0, indicator.life / indicator.maxLife);
        indicator.radius += indicator.expandSpeed * deltaTime;
    });
}

/**
 * Update enhanced trail for projectile
 * @param {Object} proj - Projectile object
 * @param {number} deltaTime - Time delta
 */
updateEnhancedTrail(proj, deltaTime) {
    const trail = this.projectileEffects.trailSystem;
    
    // Add current position to enhanced trail
    proj.enhancedTrail.push({
        x: proj.x,
        y: proj.y,
        time: Date.now(),
        alpha: 1.0,
        size: proj.size * 0.8
    });
    
    // Maintain trail length
    if (proj.enhancedTrail.length > trail.maxTrailLength) {
        proj.enhancedTrail.shift();
    }
    
    // Update trail alpha
    proj.enhancedTrail.forEach((point, index) => {
        const age = (Date.now() - point.time) / 1000;
        point.alpha = Math.max(0, 1.0 - (age * trail.fadeRate * 2));
        point.size *= 0.98; // Gradually shrink
    });
    
    // Remove old trail points
    proj.enhancedTrail = proj.enhancedTrail.filter(point => point.alpha > 0.05);
}

/**
 * Create impact prediction visual
 * @param {Object} proj - Projectile object
 */
createImpactPrediction(proj) {
    // Calculate predicted impact point
    const timeToImpact = proj.distanceToPolitician / Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
    const impactX = proj.x + proj.vx * timeToImpact;
    const impactY = proj.y + proj.vy * timeToImpact;
    
    // Impact predictions array
    this.projectileEffects.impactPredictions.push({
        x: impactX,
        y: impactY,
        radius: 5,
        maxRadius: 40,
        life: 1.5,
        maxLife: 1.5,
        color: this.projectileEffects.threatLevels[proj.threatLevel].color,
        threatLevel: proj.threatLevel,
        pulseSpeed: proj.threatLevel === 'critical' ? 3 : 2
    });
}

/**
 * Create threat warning indicator
 * @param {Object} proj - Projectile object
 */
createThreatWarning(proj) {
    const threatColor = this.projectileEffects.threatLevels[proj.threatLevel].color;
    
    this.projectileEffects.warningIndicators.push({
        x: proj.x,
        y: proj.y,
        radius: 30,
        maxRadius: 80,
        expandSpeed: 50,
        life: 2.0,
        maxLife: 2.0,
        alpha: 1.0,
        color: threatColor,
        threatLevel: proj.threatLevel,
        pulseIntensity: proj.threatLevel === 'critical' ? 1.5 : 1.0
    });
    
    // Screen flash for critical threats
    if (proj.threatLevel === 'critical') {
        this.cameraShake.intensity = Math.max(this.cameraShake.intensity, 8);
    }
}

/**
 * Update impact prediction system
 * @param {Object} proj - Projectile object
 */
updateImpactPrediction(proj) {
    const predictionDistance = 120;
    
    if (proj.distanceToPolitician <= predictionDistance && !proj.impactPredicted) {
        proj.impactPredicted = true;
        
        // Create impact prediction indicator
        this.createImpactPrediction(proj);
    }
}

/**
 * Update threat warning system
 * @param {Object} proj - Projectile object
 */
updateThreatWarnings(proj) {
    const warningDistance = 200;
    
    if (proj.distanceToPolitician <= warningDistance && !proj.warningShown && 
        (proj.threatLevel === 'high' || proj.threatLevel === 'critical')) {
        
        proj.warningShown = true;
        this.createThreatWarning(proj);
    }
}   

    /**
 * Update particles
 * @param {number} deltaTime - Time delta
 */
updateParticles(deltaTime) {
    this.updateTrailParticles(deltaTime);
    
    for (let i = this.particles.length - 1; i >= 0; i--) {
        const particle = this.particles[i];
        
        particle.x += particle.vx * deltaTime;
        particle.y += particle.vy * deltaTime;
        particle.life -= deltaTime;
        particle.vy += 200 * deltaTime; // Your existing gravity
        
        // Handle rotation for spinning particles
        if (particle.spin) {
            particle.rotation = (particle.rotation || 0) + particle.spin;
        }
        
        // Handle twinkling effect
        if (particle.twinkle) {
            particle.alpha = 0.5 + 0.5 * Math.sin(Date.now() * 0.01 + i);
        } else if (particle.sparkle) {
            particle.alpha = 0.7 + 0.3 * Math.sin(Date.now() * 0.02 + i * 0.5);
        } else {
            particle.alpha = particle.life / particle.maxLife;
        }
        
        // Handle bouncing for debris
        if (particle.type === 'debris' && particle.y > this.gameHeight - 50 && particle.vy > 0) {
            particle.vy *= -0.4;
            particle.vx *= 0.7;
            particle.spin *= 0.8;
        }
        
        // Existing cleanup
        if (particle.life <= 0) {
            this.particles.splice(i, 1);
        }
    }
}

    /**
     * Update trail particles
     * @param {number} deltaTime - Time delta
     */
    updateTrailParticles(deltaTime) {
        for (let i = this.trailParticles.length - 1; i >= 0; i--) {
            const particle = this.trailParticles[i];
            
            particle.x += particle.vx * deltaTime;
            particle.y += particle.vy * deltaTime;
            particle.life -= deltaTime;
            particle.alpha = particle.life / particle.maxLife;
            particle.size += deltaTime * 2;
            
            particle.vx *= 0.95;
            particle.vy *= 0.95;
            
            if (particle.life <= 0) {
                this.trailParticles.splice(i, 1);
            }
        }
    }

    /**
     * Update game timers
     * @param {number} deltaTime - Time delta
     */
   updateTimers(deltaTime) {
    // Update spawn rate (more aggressive with level/wave progression)
    this.projectileSpawnRate = Math.max(800, 2000 - (this.level * 200) - (this.wave * 150));
    
    this.projectileSpawnTimer += deltaTime;
    this.waveTimer += deltaTime;
    
    // Wave-based spawning system
    if (!this.waveSpawning || !this.waveSpawning.isActive) {
        if (this.projectileSpawnTimer >= (this.projectileSpawnRate / 1000)) {
            console.log('ðŸš€ Starting projectile wave!');
            this.startProjectileWave();
            this.projectileSpawnTimer = 0;
        }
    } else {
        this.updateProjectileWave(deltaTime);
    }
    
    // Game wave progression (separate from projectile waves)
    if (this.waveTimer >= this.waveDuration) {
        this.nextWave();
    }
}

// Required supporting methods for wave system
startProjectileWave() {
    // Initialize waveSpawning if needed
    if (!this.waveSpawning) {
        this.waveSpawning = {};
    }
    
    this.waveSpawning.isActive = true;
    this.waveSpawning.timer = 0;
    this.waveSpawning.projectilesSpawned = 0;
    this.waveSpawning.projectilesInWave = Math.min(3 + Math.floor(this.level / 2), 8); // 3-8 projectiles per wave
    this.waveSpawning.spawnInterval = Math.max(200, 600 - (this.level * 50)); // 200-600ms between projectiles in wave
    
    console.log(`ðŸŒŠ Wave started: ${this.waveSpawning.projectilesInWave} projectiles, ${this.waveSpawning.spawnInterval}ms interval`);
}

updateProjectileWave(deltaTime) {
    if (!this.waveSpawning || !this.waveSpawning.isActive) return;
    
    this.waveSpawning.timer += deltaTime;
    
    // Time to spawn next projectile in wave?
    if (this.waveSpawning.timer >= (this.waveSpawning.spawnInterval / 1000)) {
        if (this.waveSpawning.projectilesSpawned < this.waveSpawning.projectilesInWave) {
            console.log(`ðŸŽ¯ Wave projectile ${this.waveSpawning.projectilesSpawned + 1}/${this.waveSpawning.projectilesInWave}`);
            this.spawnProjectile();
            this.waveSpawning.projectilesSpawned++;
            this.waveSpawning.timer = 0;
        } else {
            // Wave complete
            console.log('ðŸ Projectile wave completed!');
            this.waveSpawning.isActive = false;
        }
    }
}

spawnProjectileBurst() {
    const projectilesInBurst = Math.floor(1 + this.waveSpawning.intensity);
    console.log('ðŸŽ¯ Spawning burst with', projectilesInBurst, 'projectiles');
    
    for (let i = 0; i < projectilesInBurst; i++) {
        setTimeout(() => {
            console.log('ðŸ“¦ Attempting to spawn projectile', i + 1);
            this.spawnProjectile();
        }, i * 200);
    }
}

/**
 * End current wave and start rest period
 */
endProjectileWave() {
    this.waveSpawning.isActive = false;
    this.waveSpawning.restTimer = 0;
}


    /**
 * Update enhanced camera shake system
 * @param {number} deltaTime - Time delta
 */
updateCameraShake(deltaTime) {
    const shake = this.screenEffects.shake;
    
    if (shake.intensity > 0) {
        // Different shake patterns based on type
        switch (shake.type) {
            case 'impact':
                this.cameraShake.x = (Math.random() - 0.5) * shake.intensity;
                this.cameraShake.y = (Math.random() - 0.5) * shake.intensity;
                break;
                
            case 'explosion':
                const time = Date.now() * 0.05;
                this.cameraShake.x = Math.sin(time) * shake.intensity;
                this.cameraShake.y = Math.cos(time * 1.3) * shake.intensity;
                break;
                
            case 'critical':
                const criticalTime = Date.now() * 0.02;
                this.cameraShake.x = Math.sin(criticalTime) * shake.intensity * 1.5;
                this.cameraShake.y = Math.sin(criticalTime * 2.1) * shake.intensity;
                break;
        }
        
        // Decay shake intensity
        shake.intensity -= shake.decayRate * deltaTime;
        shake.duration -= deltaTime;
        
        if (shake.intensity <= 0 || shake.duration <= 0) {
            shake.intensity = 0;
            shake.duration = 0;
            this.cameraShake.x = 0;
            this.cameraShake.y = 0;
        }
    }
}

/**
 * Trigger enhanced screen shake
 * @param {number} intensity - Shake intensity
 * @param {number} duration - Shake duration
 * @param {string} type - Shake type (impact, explosion, critical)
 */
triggerScreenShake(intensity, duration = 0.5, type = 'impact') {
    const shake = this.screenEffects.shake;
    
    // Only override if new shake is stronger
    if (intensity > shake.intensity) {
        shake.intensity = intensity;
        shake.duration = duration;
        shake.type = type;
    }
}

/**
 * Trigger screen flash effect
 * @param {string} color - Flash color
 * @param {number} intensity - Flash intensity (0-1)
 * @param {number} duration - Flash duration
 */
triggerScreenFlash(color = '#FFFFFF', intensity = 0.3, duration = 0.2) {
    const flash = this.screenEffects.flash;
    
    flash.active = true;
    flash.color = color;
    flash.intensity = Math.max(flash.intensity, intensity);
    flash.duration = Math.max(flash.duration, duration);
}

/**
 * Trigger color overlay effect
 * @param {string} color - Overlay color
 * @param {number} intensity - Overlay intensity (0-1)
 * @param {number} duration - Overlay duration
 */
triggerColorOverlay(color = '#FF0000', intensity = 0.2, duration = 1.0) {
    const overlay = this.screenEffects.colorOverlay;
    
    overlay.active = true;
    overlay.color = color;
    overlay.intensity = Math.max(overlay.intensity, intensity);
    overlay.duration = Math.max(overlay.duration, duration);
}

/**
 * Update screen effects system
 * @param {number} deltaTime - Time delta
 */
updateScreenEffects(deltaTime) {
    // Skip all screen effects on mobile for performance
    if (this.isMobile) return;
    
    // Existing desktop screen effects code continues unchanged...
    const effects = this.screenEffects;
    
    // Update flash effect
    if (effects.flash.active) {
        effects.flash.duration -= deltaTime;
        effects.flash.intensity = Math.max(0, 
            effects.flash.intensity - effects.flash.fadeRate * deltaTime
        );
        
        if (effects.flash.duration <= 0 || effects.flash.intensity <= 0) {
            effects.flash.active = false;
        }
    }

    // Update color overlay
    if (effects.colorOverlay.active) {
        effects.colorOverlay.duration -= deltaTime;
        effects.colorOverlay.intensity = Math.max(0, 
            effects.colorOverlay.intensity - effects.colorOverlay.fadeRate * deltaTime
        );
        
        if (effects.colorOverlay.duration <= 0 || effects.colorOverlay.intensity <= 0) {
            effects.colorOverlay.active = false;
        }
    }
    
    // Update slow motion distortion
    if (this.activePowers.slowmo > 0) {
        effects.slowMotion.active = true;
        effects.slowMotion.distortionIntensity = Math.min(1.0, 
            effects.slowMotion.distortionIntensity + deltaTime * 3
        );
        effects.slowMotion.chromaShift = Math.sin(Date.now() * 0.01) * 2;
        effects.slowMotion.vignette = 0.3;
    } else {
        effects.slowMotion.distortionIntensity = Math.max(0, 
            effects.slowMotion.distortionIntensity - deltaTime * 4
        );
        
        if (effects.slowMotion.distortionIntensity <= 0) {
            effects.slowMotion.active = false;
            effects.slowMotion.chromaShift = 0;
            effects.slowMotion.vignette = 0;
        }
    }
    
    // Update combo effects
    this.updateComboEffects(deltaTime);
}

/**
 * Update combo visual effects
 * @param {number} deltaTime - Time delta
 */
updateComboEffects(deltaTime) {
    const combo = this.screenEffects.comboEffects;
    
    // Check for combo streak
    if (Date.now() - combo.lastHitTime > 3000) {
        combo.streakCount = 0;
        combo.multiplier = 1;
    }
    
    // Update glow intensity
    if (combo.streakCount >= 3) {
        combo.glowIntensity = Math.min(1.0, combo.glowIntensity + deltaTime * 2);
    } else {
        combo.glowIntensity = Math.max(0, combo.glowIntensity - deltaTime * 1.5);
    }
}

    /**
     * Check for collisions
     */
   checkCollisions() {
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
        const proj = this.projectiles[i];
        
        if (this.isColliding(proj, this.aide)) {
            this.blockProjectile(proj);
            this.projectiles.splice(i, 1);
            this.projectilesBlocked++;
            
            const baseScore = 15 * this.level;
            const bonusScore = this.aide.shield ? baseScore * 2 : baseScore;
            this.score += bonusScore;
            this.debugLog('info', `Projectile blocked! Score +${bonusScore}`);
            continue;
        }
        
        // NEAR MISS DETECTION:
        const distToAide = Math.sqrt(
            Math.pow(proj.x - (this.aide.x + this.aide.width/2), 2) + 
            Math.pow(proj.y - (this.aide.y + this.aide.height/2), 2)
        );
        
        if (distToAide < 80 && !proj.nearMissTriggered) {
            proj.nearMissTriggered = true;
            if (Math.random() < 0.3) { // 30% chance for close call message
                this.showGameMessage('close');
            }
        }
    }
}

    /**
     * Check collision between two objects
     * @param {Object} obj1 - First object
     * @param {Object} obj2 - Second object
     * @returns {boolean} Collision detected
     */
    isColliding(obj1, obj2) {
        return obj1.x < obj2.x + obj2.width &&
               obj1.x + obj1.size > obj2.x &&
               obj1.y < obj2.y + obj2.height &&
               obj1.y + obj1.size > obj2.y;
    }

    /**
 * Handle projectile blocking
 * @param {Object} projectile - Projectile object
 */
blockProjectile(projectile) {
    if (this.audioManager) {
        // Play projectile-specific blocking sound
        this.audioManager.playProjectileSound(projectile.type, projectile.x, {
            volume: 0.8,
            intensity: 1.0 + (Math.random() - 0.5) * 0.2
        });
        
        // Elimination sound for successful blocks
        setTimeout(() => {
            this.audioManager.playSound('eliminate', {
                volume: 0.6,
                pan: (projectile.x / this.gameWidth - 0.5) * 2
            });
        }, 50);
    }
    
    // Message system integration
    this.messageSystem.comboCount++;
    this.messageSystem.lastComboTime = Date.now();
    
    // Update aide confidence
    this.reactionSystem.aide.confidenceLevel = Math.min(100, this.reactionSystem.aide.confidenceLevel + 5);
    this.reactionSystem.aide.lastSuccessTime = Date.now();
    
    // Screen effects combo system
    const combo = this.screenEffects.comboEffects;
    combo.streakCount++;
    combo.lastHitTime = Date.now();
    
    if (combo.streakCount >= 3) {
        combo.multiplier = Math.min(5, 1 + (combo.streakCount - 2) * 0.5);
    }
    
    // Get properties for this projectile type
    const intensity = this.getProjectileIntensity(projectile.type);
    const colors = this.getProjectileEffectColors(projectile.type);
    
    // Screen effects based on projectile type and combo
    const isCombo = combo.streakCount >= 3;
    const isCritical = projectile.threatLevel === 'critical';
    
    // Screen shake
    if (isCritical) {
        this.triggerScreenShake(12, 0.4, 'critical');
    } else if (isCombo) {
        this.triggerScreenShake(8, 0.3, 'explosion');
    } else {
        this.triggerScreenShake(4 + intensity, 0.2, 'impact');
    }
    
    // Screen flash
    if (isCritical) {
        this.triggerScreenFlash('#FFD700', 0.4, 0.3);
    } else if (isCombo) {
        this.triggerScreenFlash('#00FFFF', 0.3, 0.2);
    } else if (intensity > 1.5) {
        this.triggerScreenFlash('#FFFFFF', 0.2, 0.15);
    }
    
    // Color overlay for special effects
    if (isCombo && combo.streakCount >= 5) {
        this.triggerColorOverlay('#FFD700', 0.15, 0.5);
    }
    
    // Show appropriate message
    if (this.messageSystem.comboCount >= 3) {
        this.showGameMessage('combo');
        this.messageSystem.comboCount = 0;

        // AUDIO Integration
        if (this.audioManager) {
            this.audioManager.playSound('combo', {
                volume: 0.8
            });
        }
        
        // Trigger victory pose for impressive blocks
        this.reactionSystem.aide.victoryPose = true;
        this.reactionSystem.aide.victoryTimer = 1500;
    } else if (Math.random() < 0.4) { // 40% chance for defense message
        this.showGameMessage('defense');
    }

    // Track successful block for analytics
    if (projectile.analyticsId) {
       const defenseMethod = this.aide.shield ? 'shield' : 'positioning';
       this.analytics.trackProjectileResolution(projectile.analyticsId, 'blocked', defenseMethod);
    }
    
    // MOBILE OPTIMIZED PARTICLE CREATION - Zero particles on mobile for maximum performance
    const particleCount = this.isMobile ? 0 : Math.floor((15 + Math.random() * 8) * intensity);
    
    console.log(`Creating ${particleCount} impact particles (mobile: ${this.isMobile})`);
    
    // Only create particles on desktop
    for (let i = 0; i < particleCount; i++) {
        const angle = (Math.PI * 2 / particleCount) * i + Math.random() * 0.5;
        const speed = 200 + Math.random() * 150;
        
        this.particles.push({
            x: projectile.x + (Math.random() - 0.5) * 5,
            y: projectile.y + (Math.random() - 0.5) * 5,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 50,
            life: 1.5 + Math.random() * 0.8,
            maxLife: 2.0,
            size: 4 + Math.random() * 8,
            color: colors.primary,
            type: 'impact',
            projectileType: projectile.type,
            alpha: 1.0,
            sparkle: Math.random() < 0.3,
            spin: projectile.type === 'stone' || projectile.type === 'bottle' ? (Math.random() - 0.5) * 0.4 : 0,
            rotation: 0
        });
    }
    
    // MOBILE: Skip sparkle particles entirely for performance
    if (!this.isMobile) {
        const sparkleCount = intensity > 1.5 ? 10 : 6;
        console.log(`Creating ${sparkleCount} sparkle particles (desktop only)`);
        for (let i = 0; i < sparkleCount; i++) {
            this.particles.push({
                x: projectile.x + (Math.random() - 0.5) * 20,
                y: projectile.y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 200,
                vy: -Math.random() * 150 - 50,
                life: 2.0,
                maxLife: 2.0,
                size: 2 + Math.random() * 4,
                color: colors.secondary,
                type: 'sparkle',
                alpha: 1.0,
                sparkle: true,
                twinkle: Math.random() < 0.7
            });
        }
    }
    
    // MOBILE: Skip debris particles for heavy projectiles
    if (!this.isMobile && (projectile.type === 'stone' || projectile.type === 'bottle' || projectile.type === 'shoe')) {
        console.log('Creating 4 debris particles (desktop only)');
        for (let i = 0; i < 4; i++) {
            this.particles.push({
                x: projectile.x,
                y: projectile.y,
                vx: (Math.random() - 0.5) * 180,
                vy: -Math.random() * 100 - 30,
                life: 2.5,
                maxLife: 2.5,
                size: 3 + Math.random() * 3,
                color: colors.debris,
                type: 'debris',
                alpha: 1.0,
                sparkle: false,
                spin: (Math.random() - 0.5) * 0.3,
                rotation: 0
            });
        }
    }

    // Check for achievements after successful block
    this.checkMinimalAchievements();
}

/**
 * Get projectile effect intensity
 * @param {string} type - Projectile type
 * @returns {number} Intensity multiplier
 */
getProjectileIntensity(type) {
    const intensityMap = {
        tomato: 1.5,
        egg: 1.2,
        shoe: 1.8,
        bottle: 2.0,
        stone: 2.2,
        banana: 0.8,
        apple: 1.3
    };
    return intensityMap[type] || 1.0;
}

/**
 * Get projectile effect colors
 * @param {string} type - Projectile type
 * @returns {Object} Color scheme
 */
getProjectileEffectColors(type) {
    const colorSchemes = {
        tomato: { primary: '#FF4757', secondary: '#FFD700', debris: '#8B0000' },
        egg: { primary: '#FFF8DC', secondary: '#FFD700', debris: '#F5DEB3' },
        shoe: { primary: '#8B4513', secondary: '#CD853F', debris: '#2F1B14' },
        bottle: { primary: '#228B22', secondary: '#90EE90', debris: '#006400' },
        stone: { primary: '#696969', secondary: '#A9A9A9', debris: '#2F2F2F' },
        banana: { primary: '#FFD700', secondary: '#FFED4E', debris: '#DAA520' },
        apple: { primary: '#DC143C', secondary: '#FFB6C1', debris: '#8B0000' }
    };
    return colorSchemes[type] || { primary: '#FF6B6B', secondary: '#FFD700', debris: '#666' };
}

/**
 * Create enhanced impact burst effect
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {Object} projectile - Projectile object
 */
createEnhancedImpactBurst(x, y, projectile) {
    const intensity = this.getProjectileIntensity(projectile.type);
    const colors = this.getProjectileEffectColors(projectile.type);
    
    // Main explosion particles
    for (let i = 0; i < 15 * intensity; i++) {
        const angle = (Math.PI * 2 / 15) * i + Math.random() * 0.5;
        const speed = 150 + Math.random() * 200;
        
        this.particles.push({
            x: x + (Math.random() - 0.5) * 10,
            y: y + (Math.random() - 0.5) * 10,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 30,
            life: 1.5 + Math.random() * 0.8,
            maxLife: 2.0,
            size: 4 + Math.random() * 6,
            color: colors.primary,
            type: 'explosion',
            projectileType: projectile.type,
            alpha: 1.0,
            sparkle: false,
            spin: (Math.random() - 0.5) * 0.4,
            rotation: 0
        });
    }
    
    // Secondary sparkle burst for high-impact projectiles
    if (intensity > 1.2) {
        for (let i = 0; i < 8; i++) {
            this.particles.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 300,
                vy: -Math.random() * 200 - 50,
                life: 2.0,
                maxLife: 2.0,
                size: 2 + Math.random() * 4,
                color: colors.secondary,
                type: 'sparkle',
                alpha: 1.0,
                sparkle: true,
                twinkle: Math.random() < 0.7
            });
        }
    }
    
    // Debris particles for solid projectiles
    if (projectile.type === 'stone' || projectile.type === 'bottle') {
        for (let i = 0; i < 5; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 200,
                vy: -Math.random() * 100 - 50,
                life: 3.0,
                maxLife: 3.0,
                size: 3 + Math.random() * 4,
                color: colors.debris,
                type: 'debris',
                alpha: 1.0,
                sparkle: false
            });
        }
    }
}

/**
 * Get projectile effect intensity
 * @param {string} type - Projectile type
 * @returns {number} Intensity multiplier
 */
getProjectileIntensity(type) {
    const intensityMap = {
        tomato: 1.5,
        egg: 1.2,
        shoe: 1.8,
        bottle: 2.0,
        stone: 2.2,
        banana: 0.8,
        apple: 1.3
    };
    return intensityMap[type] || 1.0;
}

/**
 * Get projectile effect colors
 * @param {string} type - Projectile type
 * @returns {Object} Color scheme
 */
getProjectileEffectColors(type) {
    const colorSchemes = {
        tomato: { primary: '#FF4757', secondary: '#FFD700', debris: '#8B0000' },
        egg: { primary: '#FFF8DC', secondary: '#FFD700', debris: '#DDD' },
        shoe: { primary: '#8B4513', secondary: '#654321', debris: '#2F1B14' },
        bottle: { primary: '#228B22', secondary: '#90EE90', debris: '#006400' },
        stone: { primary: '#696969', secondary: '#A9A9A9', debris: '#2F2F2F' },
        banana: { primary: '#FFD700', secondary: '#FFED4E', debris: '#DAA520' },
        apple: { primary: '#DC143C', secondary: '#FFB6C1', debris: '#8B0000' }
    };
    return colorSchemes[type] || { primary: '#FF6B6B', secondary: '#FFD700', debris: '#666' };
}

  /**
 * Handle politician hit
 * @param {Object} projectile - Projectile object
 */
hitPolitician(projectile) {
    this.politicianHealth -= projectile.damage;
    
    // Play politician hit sound
    if (this.audioManager) {
        // Play projectile-specific impact on politician
        this.audioManager.playProjectileSound(projectile.type, this.politician.x, {
            volume: 0.9,
            intensity: 1.2 + (projectile.damage / 50) * 0.3
        });
        
        // Danger sound for high damage hits
        if (projectile.damage >= 25) {
            setTimeout(() => {
                this.audioManager.playSound('danger', {
                    volume: 0.7
                });
            }, 100);
        }
    }
    
    // Play critical health warning
    if (this.politicianHealth <= 25 && this.politicianHealth > 0) {
        if (this.audioManager) {
            this.audioManager.playSound('health_critical', {
                volume: 0.8
            });
        }
    }
    
    // Track politician hit for analytics
    if (projectile.analyticsId) {
        this.analytics.trackProjectileResolution(projectile.analyticsId, 'hit_politician');
        this.analytics.trackHealthEvent('damage_taken', projectile.damage, projectile.type);
    }
    
    // Screen effects based on damage and health
    const damageIntensity = projectile.damage / 50; // Normalize damage
    const healthCritical = this.politicianHealth < 30;
    
    // Screen shake based on projectile type with damage multiplier
    const shakeIntensity = this.getShakeIntensity(projectile.type) * (1 + damageIntensity);
    this.triggerScreenShake(shakeIntensity, 0.6, 'impact');
    
    // Color overlay based on damage and health
    // if (healthCritical) {
      //  this.triggerColorOverlay('#FF0000', 0.3, 1.5);
    // } else if (projectile.damage >= 25) {
      //  this.triggerColorOverlay('#FF6B6B', 0.2, 1.0);
    // }
    
    // Screen flash for high damage hits
    // if (projectile.damage >= 20) {
     //   this.triggerScreenFlash('#FF4757', 0.25, 0.3);
    // }
    
    // Screen shake (legacy support)
    this.cameraShake.intensity = this.getShakeIntensity(projectile.type);
    
    // Set projectile-specific reaction
    this.setReactionForProjectile(projectile.type);

    // Message bubble
    const randomMessage = this.hinglishMessages[Math.floor(Math.random() * this.hinglishMessages.length)];
    this.politician.messageBubble.text = randomMessage;
    this.politician.messageBubble.timer = 3000; // 3 seconds
    this.politician.messageBubble.isVisible = true;
    this.politician.messageBubble.fadeIn = 0;

    this.addStainToPolitician(projectile);
    
    // Create enhanced splatter particles
    for (let i = 0; i < 15; i++) {
        this.particles.push({
            x: this.politician.hitbox.x + this.politician.hitbox.width/2,
            y: this.politician.hitbox.y + this.politician.hitbox.height/2,
            vx: (Math.random() - 0.5) * 200,
            vy: -Math.random() * 150,
            life: 3.0,
            size: 6 + Math.random() * 10,
            color: projectile.color
        });
    }
    
    console.log(`Politician hit by ${projectile.type}, health: ${this.politicianHealth}`);
    
   // CRITICAL FIX: Game Over Handling - Prevent Brown Overlay
if (this.politicianHealth <= 0) {
    console.log('ðŸŽ® GAME OVER - Implementing immediate results approach');
    
    // IMMEDIATE STATE CHANGE - This is crucial
    this.currentState = this.gameStates.GAME_OVER;
    
    // STOP GAME LOOP IMMEDIATELY to prevent further rendering
    this.stopGameLoop();
    
    // AGGRESSIVE CANVAS CLEANUP - Fill with sky blue to block brown
    this.ctx.fillStyle = '#87CEEB'; // Sky blue background
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // HIDE CANVAS IMMEDIATELY 
    this.canvas.style.display = 'none';
    this.canvas.style.visibility = 'hidden';
    this.canvas.style.background = '#87CEEB'; // Force sky blue
    
    // CLEAR ALL GAME OBJECTS immediately
    this.projectiles = [];
    this.particles = [];
    this.trailParticles = [];
    
    // CLEAR SCREEN EFFECTS that might cause overlay
    if (this.screenEffects) {
        this.screenEffects.flash.active = false;
        this.screenEffects.flash.intensity = 0;
        this.screenEffects.colorOverlay.active = false;
        this.screenEffects.colorOverlay.intensity = 0;
        this.screenEffects.slowMotion.active = false;
        this.screenEffects.slowMotion.vignette = 0;
    }
    
    // CLEAR MESSAGE SYSTEM
    this.hideGameMessage();
    this.messageSystem.isActive = false;
    this.messageSystem.messageTimer = 0;
    
    // STOP ALL AUDIO
    if (this.audioManager) {
        this.audioManager.stopAllSounds();
    }
    
    // IMMEDIATE RESULTS - No delay at all
    console.log('ðŸ† Showing results immediately - bypassing cleanup delay');
    this.showResults();
}
}
    /**
     * Advance to next wave
     */
    nextWave() {
        this.wave++;
        this.waveTimer = 0;
        this.survivedWaves++;
        
        if (this.wave > 4) {
            this.level++;
            this.wave = 1;
            this.politicianHealth = Math.min(this.maxHealth, this.politicianHealth + 25);
        }
        
        this.score += 200 * this.level;
        this.showGameMessage('wave');
    }

   /**
 * Update UI elements
 */
updateUI() {
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const waveEl = document.getElementById('wave');
    const healthFillEl = document.getElementById('healthFill');
    
    if (scoreEl) scoreEl.textContent = this.score.toLocaleString();
    if (levelEl) levelEl.textContent = this.level;
    if (waveEl) waveEl.textContent = this.wave;
    
    if (healthFillEl) {
        const healthPercent = Math.max(0, (this.politicianHealth / this.maxHealth) * 100);
        healthFillEl.style.width = healthPercent + '%';
    }
    
    // Health styling update
    this.updateHealthBarStyling();
}

/**
 * Check and display achievements
 */
checkMinimalAchievements() {
    if (!this.analytics) return;
    
    const streak = this.analytics.streakAnalytics.currentStreak;
    const total = this.projectilesBlocked + this.projectilesMissed;
    const accuracy = total > 0 ? Math.round((this.projectilesBlocked / total) * 100) : 100;
    
    // Streak achievements - show every 5th streak
    if (streak > 0 && streak % 5 === 0) {
        if (streak >= 20) {
            this.showGameMessage('combo', `LEGENDARY ${streak} Streak! Master Defender!`);
        } else if (streak >= 15) {
            this.showGameMessage('combo', `EPIC ${streak} Streak! Unstoppable!`);
        } else if (streak >= 10) {
            this.showGameMessage('combo', `AMAZING ${streak} Streak! On fire!`);
        } else if (streak >= 5) {
            this.showGameMessage('combo', `Great ${streak} Streak! Keep going!`);
        }
        this.triggerScoreBoost();
    }
    
    // Perfect accuracy achievement
    if (accuracy === 100 && this.projectilesBlocked >= 10) {
        this.showGameMessage('defense', 'PERFECT ACCURACY! Hot defense!');
        this.triggerAccuracyPerfect();
    }
    
    // Quick reaction achievement
    const lastReaction = this.analytics.reactionTimeData[this.analytics.reactionTimeData.length - 1];
    if (lastReaction && lastReaction.time < 400) {
        this.showGameMessage('defense', 'Lightning Reflexes! Ultra-fast!');
        this.triggerScoreBoost();
    }
}

/**
 * Trigger score boost animation
 */
triggerScoreBoost() {
    const scoreEl = document.getElementById('score');
    if (scoreEl) {
        scoreEl.classList.remove('score-boost'); // Reset if already active
        setTimeout(() => {
            scoreEl.classList.add('score-boost');
        }, 10);
        
        setTimeout(() => {
            scoreEl.classList.remove('score-boost');
        }, 800);
    }
}

/**
 * Trigger accuracy perfect animation
 */
triggerAccuracyPerfect() {
    const scoreEl = document.getElementById('score');
    if (scoreEl) {
        scoreEl.classList.remove('accuracy-perfect');
        setTimeout(() => {
            scoreEl.classList.add('accuracy-perfect');
        }, 10);
        
        setTimeout(() => {
            scoreEl.classList.remove('accuracy-perfect');
        }, 1200);
    }
}

/**
 * Show contextual message
 * @param {string} type - Message type
 * @param {string} customMessage - Custom message (optional)
 */
showGameMessage(type, customMessage = null) {
    const messageEl = document.getElementById('messageText');
    const messageBox = document.getElementById('gameMessage');

    // ADD ONLY THIS LINE:
    if (this.currentState !== this.gameStates.GAMEPLAY || !messageEl || !messageBox) return;
    
    if (!messageEl || !messageBox) return;
    
    // Don't show same message type consecutively
    if (type === this.messageSystem.lastMessageType && !customMessage) {
        return;
    }
    
    let message;
    if (customMessage) {
        message = customMessage;
    } else {
        const messages = this.messageSystem.messages[type] || this.messageSystem.messages.defense;
        message = messages[Math.floor(Math.random() * messages.length)];
    }
    
    // ADD DYNAMIC POSITIONING:
    const isMobile = window.innerWidth < 768;
    const topPosition = isMobile ? '140px' : '120px';
    messageBox.style.top = topPosition;
    
    // Clear any existing message
    this.hideGameMessage();
    
    // Set new message
    messageEl.textContent = message;
    this.messageSystem.currentMessage = message;
    this.messageSystem.isActive = true;
    this.messageSystem.messageTimer = this.messageSystem.messageDuration;
    this.messageSystem.lastMessageType = type;
    
    // Show with animation
    setTimeout(() => {
        messageBox.classList.add('show');
    }, 50);
    
    // Auto-hide after duration
    setTimeout(() => {
        this.hideGameMessage();
    }, this.messageSystem.messageDuration);
    
    console.log(`Message shown: "${message}" (${type})`);
}

/**
 * Hide current message
 */
hideGameMessage() {
    const messageBox = document.getElementById('gameMessage');
    if (!messageBox) return;
    
    messageBox.classList.remove('show');
    messageBox.classList.add('fade-out');
    
    setTimeout(() => {
        messageBox.classList.remove('fade-out');
        this.messageSystem.isActive = false;
        this.messageSystem.currentMessage = '';
    }, 500);
}

/**
 * Update message system
 * @param {number} deltaTime - Time delta
 */
updateMessageSystem(deltaTime) {
    if (this.messageSystem.isActive && this.messageSystem.messageTimer > 0) {
        this.messageSystem.messageTimer -= deltaTime * 1000;
    }
    
    // Update combo tracking
    if (Date.now() - this.messageSystem.lastComboTime > 3000) {
        this.messageSystem.comboCount = 0;
    }
}

/**
 * Update reaction system
 * @param {number} deltaTime - Time delta
 */
updateReactionSystem(deltaTime) {
    const reactions = this.reactionSystem;
    
    // Update aide victory timer
    if (reactions.aide.victoryTimer > 0) {
        reactions.aide.victoryTimer -= deltaTime * 1000;
        if (reactions.aide.victoryTimer <= 0) {
            reactions.aide.victoryPose = false;
        }
    }
    
    // Update politician stress over time
    if (this.politicianHealth > 50) {
        reactions.politician.stressLevel = Math.max(0, 
            reactions.politician.stressLevel - deltaTime * 10
        );
    }
}

/**
 * Update atmospheric background system
 * @param {number} deltaTime - Time delta
 */
updateAtmosphericSystem(deltaTime) {
     // Skip atmospheric effects entirely on mobile
    if (this.isMobile) return;

    const wind = this.atmosphericSystem.wind;
    const parallax = this.atmosphericSystem.parallaxLayers;
    
    // Update wind patterns
    wind.time += deltaTime * 2;
    wind.strength = 0.3 + Math.sin(wind.time * 0.5) * 0.4 + this.projectiles.length * 0.05;
    wind.direction = Math.sign(Math.sin(wind.time * 0.1));
    
    // Update parallax layers based on aide movement
    const aideMoveX = this.keys['KeyA'] || this.keys['ArrowLeft'] ? -1 : 
                     this.keys['KeyD'] || this.keys['ArrowRight'] ? 1 : 0;
    
    parallax.far.x += aideMoveX * parallax.far.speed;
    parallax.mid.x += aideMoveX * parallax.mid.speed;
    parallax.near.x += aideMoveX * parallax.near.speed;
    
    // Keep parallax within bounds
    Object.values(parallax).forEach(layer => {
        layer.x = Math.max(-50, Math.min(50, layer.x));
    });
    
    // Maintain particle count
    while (this.atmosphericSystem.particles.length < this.atmosphericSystem.maxParticles) {
        this.createAtmosphericParticle();
    }
}

/**
 * Main render function
 */
render() {
    // MOBILE: Use completely different render path
    if (this.isMobile) {
        this.mobileRender();
        return;
    }

    // DESKTOP: Skip render if conditions aren't perfect
    if (this.currentState !== this.gameStates.GAMEPLAY) return;
    
    // CRITICAL FIX: Immediate exit for problematic states
    // This prevents any rendering during game over transitions
    if (this.currentState === this.gameStates.GAME_OVER) {
        // Ensure canvas is hidden and cleared
        this.canvas.style.display = 'none';
        this.canvas.style.visibility = 'hidden';
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        console.log('ðŸš« render() - GAME_OVER state, canvas hidden');
        return;
    }
    
    // Hide canvas during loading and start screen
    if (this.currentState === this.gameStates.LOADING || 
        this.currentState === this.gameStates.START_SCREEN) { 
        this.canvas.style.display = 'none';
        this.canvas.style.visibility = 'hidden';
        console.log('ðŸš« render() - Loading/Start screen, canvas hidden');
        return;
    }
    
    // ONLY render during active gameplay
    if (this.currentState !== this.gameStates.GAMEPLAY) {
        console.log('ðŸš« render() - Not in gameplay state:', this.currentState);
        return;
    }
    
    // Enhanced HUD readiness check to prevent all overlay flashes
    const gameHUD = document.getElementById('gameHUD');
    const scoreDisplay = document.getElementById('score');
    const hudFullyReady = gameHUD && 
                         gameHUD.classList.contains('show') && 
                         scoreDisplay && 
                         getComputedStyle(gameHUD).opacity !== '0' &&
                         getComputedStyle(gameHUD).visibility !== 'hidden' &&
                         parseFloat(getComputedStyle(gameHUD).opacity) >= 0.9;

    if (!hudFullyReady) {
        console.log('ðŸš« render() - HUD not fully ready, canvas staying hidden');
        this.canvas.style.display = 'none';
        this.canvas.style.visibility = 'hidden';
        return;
    }
    
    // Show canvas ONLY when HUD is confirmed ready
    this.canvas.style.display = 'block';
    this.canvas.style.visibility = 'visible';
    this.canvas.style.opacity = '1';
    
    // Performance optimization check
    if (!this.optimizeRenderingPerformance()) {
        return;
    }
    
    // CLEAR CANVAS FIRST - Prevents any overlay issues
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    if (!this.renderFrameId) this.renderFrameId = 0;
    this.renderFrameId++;
    
    this.ctx.save();
    
    // Apply slow motion distortion
    const slowmo = this.screenEffects.slowMotion;
    if (slowmo.active && slowmo.distortionIntensity > 0) {
        this.ctx.shadowColor = '#00FFFF';
        this.ctx.shadowOffsetX = slowmo.chromaShift * slowmo.distortionIntensity;
        this.ctx.shadowOffsetY = 0;
        this.ctx.shadowBlur = 0;
    }
    
    // Apply camera shake
    this.ctx.translate(this.cameraShake.x, this.cameraShake.y);
    
    // DEFENSIVE RENDERING: Double-check state before each draw call
    // This creates multiple safety layers against brown overlay
    
    try {
        // Background elements - each has its own state check now
        if (this.currentState === this.gameStates.GAMEPLAY) {
            this.drawVillageBackgroundOnly(); // Has state check from Fix #1
        }
        
        if (this.currentState === this.gameStates.GAMEPLAY) {
            this.drawAnimatedClouds();
        }
        
        if (this.currentState === this.gameStates.GAMEPLAY) {
            this.drawBackgroundCrowd(); // Has state check from Fix #2
        }
        
        // Character elements - critical game objects
        if (this.currentState === this.gameStates.GAMEPLAY) {
            this.drawPolitician();
            this.drawPodiumAndMic();
            this.drawAide();
        }
        
        // Foreground elements
        if (this.currentState === this.gameStates.GAMEPLAY) {
            this.drawForegroundCrowd();
        }
        
        // Interactive elements
        if (this.currentState === this.gameStates.GAMEPLAY) {
            this.drawProjectiles();
            this.drawParticles();
            this.drawEffects();
        }
        
    } catch (error) {
        // Error handling - prevent rendering crashes that could cause overlay
        console.error('render() error:', error);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // If we hit an error during game over transition, ensure clean state
        if (this.politicianHealth <= 0) {
            this.currentState = this.gameStates.GAME_OVER;
            this.canvas.style.display = 'none';
        }
    }
    
    this.ctx.restore();
    
    // Screen effects - only during active gameplay and not on mobile
    if (!this.isMobile && this.currentState === this.gameStates.GAMEPLAY) {
        this.drawScreenEffects();
    }
    
    // FINAL SAFETY CHECK: If game ended during render, clean up immediately
    if (this.politicianHealth <= 0 && this.currentState !== this.gameStates.GAME_OVER) {
        console.log('ðŸ”§ render() - Detected game end, cleaning up');
        this.currentState = this.gameStates.GAME_OVER;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.canvas.style.display = 'none';
    }
}

// ADD this new mobile render method AFTER the render() method:
mobileRender() {
    // CRITICAL: Exit immediately if not in gameplay
    if (this.currentState !== this.gameStates.GAMEPLAY) {
        this.canvas.style.display = 'none';
        return;
    }

    // Simple performance check
    const now = performance.now();
    if (this.lastMobileRender && now - this.lastMobileRender < 50) return; // Max 20 FPS
    this.lastMobileRender = now;

    // Ensure canvas is visible for mobile gameplay
    this.canvas.style.display = 'block';
    this.canvas.style.visibility = 'visible';
    this.canvas.style.opacity = '1';

    // Clear canvas efficiently
    this.ctx.fillStyle = '#87CEEB'; // Sky blue background
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // Only draw essential game elements
    this.drawMobilePolitician();
    this.drawMobileAide();
    this.drawMobileProjectiles();
    
    // NO particles, crowds, effects, or complex graphics
}

/**
 * Draw screen effects overlay
 */
drawScreenEffects() {
    const effects = this.screenEffects;
    
    // Draw slow motion vignette
    if (effects.slowMotion.active && effects.slowMotion.vignette > 0) {
        this.drawSlowMotionVignette(effects.slowMotion.vignette);
    }
    
    // Draw combo glow border
    if (effects.comboEffects.glowIntensity > 0) {
        this.drawComboGlow(effects.comboEffects.glowIntensity);
    }
    
    // Draw color overlay
    if (effects.colorOverlay.active && effects.colorOverlay.intensity > 0) {
        this.ctx.save();
        this.ctx.globalAlpha = effects.colorOverlay.intensity;
        this.ctx.fillStyle = effects.colorOverlay.color;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.restore();
    }
    
    // Draw screen flash
    if (effects.flash.active && effects.flash.intensity > 0) {
        this.ctx.save();
        this.ctx.globalAlpha = effects.flash.intensity;
        this.ctx.fillStyle = effects.flash.color;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.restore();
    }
}

/**
 * Draw slow motion vignette effect
 * @param {number} intensity - Vignette intensity
 */
drawSlowMotionVignette(intensity) {
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const maxRadius = Math.max(this.canvas.width, this.canvas.height);
    
    const gradient = this.ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, maxRadius * 0.7
    );
    
    gradient.addColorStop(0, 'rgba(64, 128, 255, 0)');
    gradient.addColorStop(1, `rgba(64, 128, 255, ${intensity * 0.4})`);
    
    this.ctx.save();
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.restore();
}

/**
 * Draw combo glow border effect
 * @param {number} intensity - Glow intensity
 */
drawComboGlow(intensity) {
    const time = Date.now() * 0.005;
    const pulse = Math.sin(time) * 0.3 + 0.7;
    
    this.ctx.save();
    this.ctx.strokeStyle = '#FFD700';
    this.ctx.lineWidth = 4 * intensity;
    this.ctx.globalAlpha = intensity * pulse * 0.6;
    this.ctx.shadowColor = '#FFD700';
    this.ctx.shadowBlur = 20 * intensity;
    
    this.ctx.strokeRect(5, 5, this.canvas.width - 10, this.canvas.height - 10);
    this.ctx.restore();
}

  /**
 * Draw enhanced village background with atmospheric effects
 */
drawVillageBackgroundOnly() {
    // CRITICAL FIX: Multiple exit conditions including direct health check
    if (this.currentState === this.gameStates.GAME_OVER || 
        this.currentState === this.gameStates.LOADING ||
        this.currentState === this.gameStates.START_SCREEN ||
        this.politicianHealth <= 0 ||  // NEW: Direct health check prevents final frame issue
        !this.isRunning) {             // NEW: Running state check
        console.log('ðŸš« drawVillageBackgroundOnly() - Blocked: State:', this.currentState, 'Health:', this.politicianHealth, 'Running:', this.isRunning);
        return;
    }
    
    // Additional safety check - ensure we're actually in gameplay
    if (this.currentState !== this.gameStates.GAMEPLAY) {
        console.log('ðŸš« drawVillageBackgroundOnly() - Not in gameplay state, exiting');
        return;
    }
    
    const groundY = this.gameHeight * 0.65;
    
    // Draw dynamic sky gradient
    this.drawDynamicSky(groundY);
    
    // Draw background buildings with parallax
    this.drawParallaxBuildings(groundY);
    
    // Draw atmospheric particles
    this.drawAtmosphericParticles();
    
    // Draw ground
    if (this.backgroundsLoaded) {
        this.drawBackgroundAsset('ground', 0, groundY, this.gameWidth, this.gameHeight - groundY);
    } else {
        // Fallback ground
        const groundGradient = this.ctx.createLinearGradient(0, groundY, 0, this.canvas.height);
        groundGradient.addColorStop(0, '#DEB887');
        groundGradient.addColorStop(1, '#D2B48C');
        this.ctx.fillStyle = groundGradient;
        this.ctx.fillRect(0, groundY, this.canvas.width, this.canvas.height - groundY);
    }
}

/**
 * Draw dynamic sky with time-based changes
 * @param {number} groundY - Ground level Y position
 */
drawDynamicSky(groundY) {
    const sky = this.atmosphericSystem.skyGradient;
    
    // Update sky time and intensity based on game state
    sky.time += 0.0005;
    sky.intensity = Math.min(0.3, this.projectiles.length * 0.02); // Sky gets more dramatic with more projectiles
    
    // Create dynamic gradient
    const skyGradient = this.ctx.createLinearGradient(0, 0, 0, groundY);
    
    const hue1 = sky.baseHue + Math.sin(sky.time) * 15 + sky.intensity * 20;
    const hue2 = sky.baseHue + 30 + Math.cos(sky.time * 1.2) * 10 + sky.intensity * 15;
    
    const saturation1 = 50 + sky.intensity * 30;
    const saturation2 = 40 + sky.intensity * 25;
    
    const lightness1 = 80 - sky.intensity * 20;
    const lightness2 = 70 - sky.intensity * 15;
    
    skyGradient.addColorStop(0, `hsl(${hue1}, ${saturation1}%, ${lightness1}%)`);
    skyGradient.addColorStop(0.7, `hsl(${hue2}, ${saturation2}%, ${lightness2}%)`);
    skyGradient.addColorStop(1, `hsl(${hue2 + 10}, ${saturation2 - 10}%, ${lightness2 - 5}%)`);
    
    this.ctx.fillStyle = skyGradient;
    this.ctx.fillRect(0, 0, this.gameWidth, groundY);
}

/**
 * Draw buildings with parallax effect
 * @param {number} groundY - Ground level Y position
 */
drawParallaxBuildings(groundY) {
    if (this.backgroundsLoaded && this.backgroundImages.buildings) {
        // Calculate parallax offset based on projectile movement
        const avgProjectileX = this.projectiles.length > 0 ? 
            this.projectiles.reduce((sum, p) => sum + p.x, 0) / this.projectiles.length : 
            this.gameWidth / 2;
        
        const parallaxOffset = (avgProjectileX - this.gameWidth / 2) * -0.05;
        
        this.ctx.save();
        this.ctx.translate(parallaxOffset, 0);
        this.drawBackgroundAsset('buildings', -50, 0, this.gameWidth + 100, groundY);
        this.ctx.restore();
    } else {
        // Fallback: draw procedural buildings with parallax
        this.drawProceduralBuildingsWithParallax(groundY);
    }
}

/**
 * Draw procedural buildings with parallax effect
 * @param {number} groundY - Ground level Y position
 */
drawProceduralBuildingsWithParallax(groundY) {
    const parallax = this.atmosphericSystem.parallaxLayers;
    
    // Far layer buildings (smaller, lighter)
    this.ctx.save();
    this.ctx.translate(parallax.far.x, 0);
    this.ctx.globalAlpha = 0.6;
    this.drawBuildingLayer(groundY, 0.7, '#E6D7C7', 0.1);
    this.ctx.restore();
    
    // Mid layer buildings
    this.ctx.save();
    this.ctx.translate(parallax.mid.x, 0);
    this.ctx.globalAlpha = 0.8;
    this.drawBuildingLayer(groundY, 0.85, '#DEB887', 0.15);
    this.ctx.restore();
    
    // Near layer buildings (your existing buildings)
    this.ctx.save();
    this.ctx.translate(parallax.near.x, 0);
    this.ctx.globalAlpha = 1.0;
    this.drawBuildingLayer(groundY, 1.0, '#CD853F', 0.2);
    this.ctx.restore();
}

/**
 * Draw a layer of buildings
 * @param {number} groundY - Ground level
 * @param {number} scale - Building scale
 * @param {string} color - Building color
 * @param {number} heightVariation - Height variation factor
 */
drawBuildingLayer(groundY, scale, color, heightVariation) {
    const buildingCount = Math.floor(this.gameWidth / (60 * scale)) + 2;
    
    for (let i = 0; i < buildingCount; i++) {
        const x = (i * 60 * scale) - 30;
        const baseHeight = 80 * scale;
        const height = baseHeight + (Math.sin(i * 2.3) * baseHeight * heightVariation);
        const width = 50 * scale + Math.sin(i * 1.7) * 10 * scale;
        
        // Building body
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x, groundY - height, width, height);
        
        // Simple roof
        this.ctx.fillStyle = this.darkenColor(color, 0.3);
        this.ctx.beginPath();
        this.ctx.moveTo(x - 5, groundY - height);
        this.ctx.lineTo(x + width/2, groundY - height - 15 * scale);
        this.ctx.lineTo(x + width + 5, groundY - height);
        this.ctx.fill();
        
        // Windows
        const windowSize = 8 * scale;
        this.ctx.fillStyle = 'rgba(255, 255, 100, 0.3)';
        for (let w = 0; w < 2; w++) {
            this.ctx.fillRect(
                x + 10 * scale + w * 25 * scale, 
                groundY - height + 20 * scale, 
                windowSize, windowSize
            );
        }
    }
}
    /**
     * Draw village houses
     */
  drawVillageHousesOnly() {
    const houseScale = Math.min(1, this.gameWidth / 1400);
    const isMobile = this.gameWidth < 768;
    
    const baseHouseSize = {
        width: (isMobile ? 80 : 100) * houseScale,
        height: (isMobile ? 100 : 120) * houseScale
    };

    // Only short houses - NO tall buildings
    let houses;
    
    if (isMobile) {
        houses = [
            { x: this.gameWidth * 0.08, y: this.gameHeight * 0.32, width: baseHouseSize.width, height: baseHouseSize.height, color: '#DEB887' },
            { x: this.gameWidth * 0.28, y: this.gameHeight * 0.34, width: baseHouseSize.width * 0.9, height: baseHouseSize.height * 0.85, color: '#CD853F' },
            { x: this.gameWidth * 0.52, y: this.gameHeight * 0.33, width: baseHouseSize.width * 0.95, height: baseHouseSize.height * 0.9, color: '#F4A460' },
            { x: this.gameWidth * 0.72, y: this.gameHeight * 0.31, width: baseHouseSize.width, height: baseHouseSize.height * 1.05, color: '#D2B48C' }
        ];
    } else {
        houses = [
            { x: this.gameWidth * 0.06, y: this.gameHeight * 0.3, width: baseHouseSize.width, height: baseHouseSize.height, color: '#DEB887' },
            { x: this.gameWidth * 0.21, y: this.gameHeight * 0.32, width: baseHouseSize.width * 0.8, height: baseHouseSize.height * 0.83, color: '#CD853F' },
            { x: this.gameWidth * 0.61, y: this.gameHeight * 0.31, width: baseHouseSize.width * 0.9, height: baseHouseSize.height * 0.91, color: '#F4A460' },
            { x: this.gameWidth * 0.76, y: this.gameHeight * 0.29, width: baseHouseSize.width, height: baseHouseSize.height * 1.08, color: '#D2B48C' }
        ];
    }
    
    // Draw only the short houses
    houses.forEach(house => {
        // House body
        this.ctx.fillStyle = house.color;
        this.ctx.fillRect(house.x, house.y, house.width, house.height);
        
        // Roof
        this.ctx.fillStyle = '#8B4513';
        this.ctx.beginPath();
        this.ctx.moveTo(house.x - 10 * houseScale, house.y);
        this.ctx.lineTo(house.x + house.width/2, house.y - (isMobile ? 25 : 30) * houseScale);
        this.ctx.lineTo(house.x + house.width + 10 * houseScale, house.y);
        this.ctx.fill();
        
        // Windows
        const windowSize = isMobile ? 15 : 20;
        this.ctx.fillStyle = '#4A4A4A';
        this.ctx.fillRect(house.x + 12 * houseScale, house.y + 25 * houseScale, windowSize * houseScale, windowSize * houseScale);
        this.ctx.fillRect(house.x + house.width - (12 + windowSize) * houseScale, house.y + 25 * houseScale, windowSize * houseScale, windowSize * houseScale);
        
        // Door
        const doorWidth = isMobile ? 18 : 24;
        const doorHeight = isMobile ? 30 : 40;
        this.ctx.fillStyle = '#654321';
        this.ctx.fillRect(house.x + house.width/2 - doorWidth/2 * houseScale, house.y + house.height - doorHeight * houseScale, doorWidth * houseScale, doorHeight * houseScale);
    });
}

/**
 * Draw atmospheric particles
 */
drawAtmosphericParticles() {
     // MOBILE: Skip atmospheric particles entirely
    if (this.isMobile) {
        return;
    }

    const particles = this.atmosphericSystem.particles;
    const wind = this.atmosphericSystem.wind;
    
    this.ctx.save();
    
    particles.forEach(particle => {
        // Calculate wind effect
        const windX = Math.sin(wind.time + particle.wobble) * wind.strength * wind.direction;
        const windY = Math.cos(wind.time * 0.7 + particle.wobble) * wind.strength * 0.3;
        
        // Update particle position
        particle.x += particle.vx * 0.016 + windX;
        particle.y += particle.vy * 0.016 + windY;
        particle.wobble += particle.wobbleSpeed;
        
        // Apply subtle wobble
        const wobbleX = Math.sin(particle.wobble) * 2;
        const wobbleY = Math.cos(particle.wobble * 1.3) * 1;
        
        // Draw particle based on type
        this.ctx.globalAlpha = particle.opacity;
        
        if (particle.type === 'dust') {
            this.ctx.fillStyle = '#F5F5DC';
            this.ctx.shadowColor = '#F5F5DC';
            this.ctx.shadowBlur = 3;
            
            this.ctx.beginPath();
            this.ctx.arc(
                particle.x + wobbleX, 
                particle.y + wobbleY, 
                particle.size, 0, Math.PI * 2
            );
            this.ctx.fill();
        } else if (particle.type === 'pollen') {
            this.ctx.fillStyle = '#FFE135';
            this.ctx.shadowColor = '#FFE135';
            this.ctx.shadowBlur = 2;
            
            this.ctx.beginPath();
            this.ctx.arc(
                particle.x + wobbleX, 
                particle.y + wobbleY, 
                particle.size * 0.8, 0, Math.PI * 2
            );
            this.ctx.fill();
        }
        
        // Reset particle if it goes off screen
        if (particle.x > this.gameWidth + 100 || particle.x < -100 || 
            particle.y > this.gameHeight * 0.6 + 50 || particle.y < -50) {
            this.resetAtmosphericParticle(particle);
        }
    });
    
    this.ctx.restore();
}

/**
 * Reset atmospheric particle to starting position
 * @param {Object} particle - Particle to reset
 */
resetAtmosphericParticle(particle) {
    particle.x = -50 + Math.random() * 100;
    particle.y = Math.random() * this.gameHeight * 0.6;
    particle.vx = (Math.random() - 0.5) * 20 + 10;
    particle.vy = (Math.random() - 0.5) * 10;
    particle.opacity = 0.2 + Math.random() * 0.4;
    particle.wobble = Math.random() * Math.PI * 2;
}

    /**
     * Draw ground level crowd
     */
    drawGroundLevelCrowd() {
    if (!this.backgroundsLoaded) {
        // Fallback to procedural crowd if assets not loaded
        this.drawProceduralCrowd();
        return;
    }
    
    const groundY = this.gameHeight * 0.65;
    const crowdStartY = groundY + 10;
    const crowdHeight = this.gameHeight - crowdStartY;
    
    // Draw background crowd layer first (behind stage)
    if (this.backgroundImages.crowdBg) {
        this.ctx.drawImage(
            this.backgroundImages.crowdBg,
            0, crowdStartY,
            this.gameWidth, crowdHeight
        );
    }
    
    // Draw foreground crowd layer (in front of stage, but behind projectiles)
    if (this.backgroundImages.crowdFg) {
        this.ctx.globalAlpha = 0.9; // Slightly transparent so stage is visible
        this.ctx.drawImage(
            this.backgroundImages.crowdFg,
            0, crowdStartY,
            this.gameWidth, crowdHeight
        );
        this.ctx.globalAlpha = 1.0; // Reset alpha
    }
}

/**
 * Fallback procedural crowd
 */
drawProceduralCrowd() {
    // MOBILE: Skip procedural crowd entirely
    if (this.isMobile) {
        console.log('ðŸš« drawProceduralCrowd() - SKIPPED ON MOBILE for performance');
        return;
    }
    
    console.log('ðŸ¤– drawProceduralCrowd() is being called instead');
    const now = Date.now();
    if (!this.crowdCache || now - this.lastCrowdUpdate > 100) {
        this.updateCrowdCache();
        this.lastCrowdUpdate = now;
    }
    
    this.drawCachedCrowd();
}


/**
 * Draw animated background crowd layer
 */
drawBackgroundCrowd() {
    // MOBILE: Skip crowd rendering entirely to prevent freezing
    if (this.isMobile) {
        console.log('ðŸš« drawBackgroundCrowd() - SKIPPED ON MOBILE for performance');
        return;
    }
    
    // CRITICAL FIX: Multiple exit conditions including direct health check
    if (this.currentState === this.gameStates.GAME_OVER || 
        this.currentState === this.gameStates.LOADING ||
        this.currentState === this.gameStates.START_SCREEN ||
        this.politicianHealth <= 0 ||  // NEW: Direct health check prevents final frame issue
        !this.isRunning) {             // NEW: Running state check
        console.log('ðŸš« drawBackgroundCrowd() - Blocked: State:', this.currentState, 'Health:', this.politicianHealth, 'Running:', this.isRunning);
        return;
    }
    
    // Additional safety check - ensure we're actually in gameplay
    if (this.currentState !== this.gameStates.GAMEPLAY) {
        console.log('ðŸš« drawBackgroundCrowd() - Not in gameplay state, exiting');
        return;
    }

    console.log('ðŸŽ­ drawBackgroundCrowd() is being called - SAFE TO PROCEED');

    if (!this.backgroundsLoaded || !this.backgroundImages.crowdBg) {
        return;
    }
    
    // Rest of your existing crowd drawing code...
    const groundY = this.gameHeight * 0.65;
    const crowdStartY = groundY - 30;
    const targetHeight = (this.gameHeight - crowdStartY) * 1.1;
    
    const img = this.backgroundImages.crowdBg;
    const imgAspectRatio = img.naturalWidth / img.naturalHeight;
    
    const swayMargin = 50;
    const oversizedWidth = this.gameWidth + (swayMargin * 2);
    const targetWidth = oversizedWidth;
    
    const time = this.crowdAnimation.time * 0.001;
    const swayX = Math.sin(time) * 12;
    const swayY = Math.sin(time * 1.5) * 8;
    
    this.ctx.save();
    this.ctx.translate(swayX, swayY);
    
    const tilesNeeded = Math.ceil(targetWidth / (targetHeight * imgAspectRatio));
    const tileWidth = targetHeight * imgAspectRatio;
    
    for (let i = 0; i < tilesNeeded + 1; i++) {
        this.ctx.drawImage(
            img,
            -swayMargin + (i * tileWidth), crowdStartY,
            tileWidth, targetHeight
        );
    }
    
    this.ctx.restore();
}

/**
 * Draw animated foreground crowd layer
 */
drawForegroundCrowd() {
    // MOBILE: Skip foreground crowd entirely
    if (this.isMobile) {
        console.log('ðŸš« drawForegroundCrowd() - SKIPPED ON MOBILE for performance');
        return;
    }
    
    // CRITICAL FIX: Multiple exit conditions including direct health check
    if (this.currentState === this.gameStates.GAME_OVER || 
        this.currentState === this.gameStates.LOADING ||
        this.currentState === this.gameStates.START_SCREEN ||
        this.politicianHealth <= 0 ||  // NEW: Direct health check prevents final frame issue
        !this.isRunning) {             // NEW: Running state check
        console.log('ðŸš« drawForegroundCrowd() - Blocked: State:', this.currentState, 'Health:', this.politicianHealth, 'Running:', this.isRunning);
        return;
    }
    
    // Additional safety check - ensure we're actually in gameplay
    if (this.currentState !== this.gameStates.GAMEPLAY) {
        console.log('ðŸš« drawForegroundCrowd() - Not in gameplay state, exiting');
        return;
    }

    if (!this.backgroundsLoaded || !this.backgroundImages.crowdFg) {
        this.drawProceduralCrowd();
        return;
    }
    
    // Rest of your existing foreground crowd code...
    const groundY = this.gameHeight * 0.65;
    const crowdStartY = groundY + 15;
    
    const img = this.backgroundImages.crowdFg;
    const imgAspectRatio = img.naturalWidth / img.naturalHeight;
    const targetHeight = this.gameHeight - crowdStartY;
    
    const swayMargin = 50;
    const oversizedWidth = this.gameWidth + (swayMargin * 2);
    
    const time = this.crowdAnimation.time * 0.001;
    const swayX = Math.sin(time + 1) * 10;
    const swayY = Math.sin(time * 1.2 + 0.5) * 6;
    
    // Simple approach: move the drawing position down
    const groundingOffset = 25; // Reduced offset to prevent cropping
    
    this.ctx.save();
    this.ctx.globalAlpha = 0.85;
    this.ctx.translate(swayX, swayY);
    
    const tilesNeeded = Math.ceil(oversizedWidth / (targetHeight * imgAspectRatio));
    const tileWidth = targetHeight * imgAspectRatio;
    
    // Draw the full image (no cropping) but positioned lower
    for (let i = 0; i < tilesNeeded + 1; i++) {
        this.ctx.drawImage(
            img,
            -swayMargin + (i * tileWidth), 
            crowdStartY + groundingOffset, // Simple offset approach
            tileWidth, 
            targetHeight
        );
    }
    
    this.ctx.restore();
}
/**
 * Draw animated procedural clouds
 */
drawAnimatedClouds() {
    // MOBILE: Skip animated clouds
    if (this.isMobile) {
        return;
    }
    
    const time = this.crowdAnimation.time * 0.0003; // Slower than crowd animation
    
    // Define cloud positions and properties
    const clouds = [
        { baseX: this.gameWidth * 0.15, y: this.gameHeight * 0.12, size: 60, speed: 0.8 },
        { baseX: this.gameWidth * 0.45, y: this.gameHeight * 0.08, size: 80, speed: 0.5 },
        { baseX: this.gameWidth * 0.75, y: this.gameHeight * 0.15, size: 70, speed: 0.6 },
        { baseX: this.gameWidth * 1.1, y: this.gameHeight * 0.10, size: 90, speed: 0.4 }
    ];
    
    clouds.forEach((cloud, index) => {
        // Calculate moving X position (clouds drift across screen)
        const moveX = (cloud.baseX + time * cloud.speed * 100) % (this.gameWidth + 200) - 100;
        
        // Subtle vertical bobbing
        const bobY = cloud.y + Math.sin(time * 2 + index) * 3;
        
        this.drawCloud(moveX, bobY, cloud.size);
    });
}

/**
 * Draw a single cloud
 * @param {number} x - X position
 * @param {number} y - Y position 
 * @param {number} size - Cloud size
 */
drawCloud(x, y, size) {
    this.ctx.save();
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
    this.ctx.shadowBlur = 10;
    
    // Draw cloud as multiple overlapping circles
    const circles = [
        { offsetX: 0, offsetY: 0, scale: 1.0 },
        { offsetX: size * 0.3, offsetY: size * 0.1, scale: 0.8 },
        { offsetX: -size * 0.2, offsetY: size * 0.15, scale: 0.7 },
        { offsetX: size * 0.1, offsetY: -size * 0.2, scale: 0.6 },
        { offsetX: -size * 0.3, offsetY: -size * 0.1, scale: 0.5 }
    ];
    
    circles.forEach(circle => {
        this.ctx.beginPath();
        this.ctx.arc(
            x + circle.offsetX, 
            y + circle.offsetY, 
            size * circle.scale * 0.5, 
            0, Math.PI * 2
        );
        this.ctx.fill();
    });
    
    this.ctx.restore();
}

    /**
     * Update crowd cache for performance
     */
    updateCrowdCache() {
    // MOBILE: Skip crowd cache generation
    if (this.isMobile) {
        this.crowdCache = [];
        return;
    }
    
    // Continue crowd cache generation 
    const villagerColors = [
        '#FF6B35', '#4A90E2', '#50E3C2', '#F5A623', '#BD10E0', 
        '#D0021B', '#9B59B6', '#E67E22', '#27AE60', '#3498DB',
        '#FF5722', '#2196F3', '#4CAF50', '#FF9800', '#E91E63'
    ];
        
        this.crowdCache = [];
        const groundY = this.gameHeight * 0.65;
        const crowdStartY = groundY + 10;
        const isMobileScreen = this.gameWidth < 768;
        const villagerScale = isMobileScreen ? 0.8 : 1.0;
        
        const availableCrowdHeight = this.gameHeight - crowdStartY;
        const rowHeight = isMobileScreen ? 16 : 18;
        const maxRows = Math.floor(availableCrowdHeight / rowHeight);
        
        // Front center crowd
        const centerRows = Math.min(maxRows, isMobileScreen ? 8 : 10);
        const centerStartX = this.gameWidth * 0.25;
        const centerEndX = this.gameWidth * 0.75;
        const centerWidth = centerEndX - centerStartX;
        
        for (let row = 0; row < centerRows; row++) {
            const villagersPerRow = isMobileScreen ? 15 : 20;
            const rowSpacing = centerWidth / (villagersPerRow - 1);
            
            for (let i = 0; i < villagersPerRow; i++) {
                this.crowdCache.push({
                    x: centerStartX + (i * rowSpacing) + (Math.random() - 0.5) * 8,
                    y: crowdStartY + (row * rowHeight) + (Math.random() - 0.5) * 3,
                    color: villagerColors[(i + row) % villagerColors.length],
                    index: i + row * villagersPerRow + 1000,
                    scale: villagerScale * (0.85 + Math.random() * 0.3),
                    baseY: crowdStartY + (row * rowHeight),
                    animOffset: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Left side crowd
        const leftRows = Math.min(maxRows, isMobileScreen ? 6 : 8);
        const leftEndX = this.gameWidth * 0.22;
        
        for (let row = 0; row < leftRows; row++) {
            const villagersPerRow = isMobileScreen ? 8 : 10;
            const rowSpacing = leftEndX / (villagersPerRow - 1);
            
            for (let i = 0; i < villagersPerRow; i++) {
                this.crowdCache.push({
                    x: this.gameWidth * 0.02 + (i * rowSpacing) + (Math.random() - 0.5) * 5,
                    y: crowdStartY + (row * rowHeight) + (Math.random() - 0.5) * 3,
                    color: villagerColors[(i + row + 5) % villagerColors.length],
                    index: i + row * villagersPerRow + 2000,
                    scale: villagerScale * (0.8 + Math.random() * 0.25),
                    baseY: crowdStartY + (row * rowHeight),
                    animOffset: Math.random() * Math.PI * 2 + 1
                });
            }
        }
        
        // Right side crowd
        const rightRows = Math.min(maxRows, isMobileScreen ? 6 : 8);
        const rightStartX = this.gameWidth * 0.78;
        const rightWidth = this.gameWidth * 0.2;
        
        for (let row = 0; row < rightRows; row++) {
            const villagersPerRow = isMobileScreen ? 8 : 10;
            const rowSpacing = rightWidth / (villagersPerRow - 1);
            
            for (let i = 0; i < villagersPerRow; i++) {
                this.crowdCache.push({
                    x: rightStartX + (i * rowSpacing) + (Math.random() - 0.5) * 5,
                    y: crowdStartY + (row * rowHeight) + (Math.random() - 0.5) * 3,
                    color: villagerColors[(i + row + 10) % villagerColors.length],
                    index: i + row * villagersPerRow + 3000,
                    scale: villagerScale * (0.8 + Math.random() * 0.25),
                    baseY: crowdStartY + (row * rowHeight),
                    animOffset: Math.random() * Math.PI * 2 + 2
                });
            }
        }
        
        // Additional mobile density
        if (isMobileScreen && maxRows > 8) {
            const extraRows = Math.min(4, maxRows - 8);
            for (let row = 0; row < extraRows; row++) {
                const extraRowY = crowdStartY + ((centerRows + row) * rowHeight);
                
                for (let i = 0; i < 12; i++) {
                    this.crowdCache.push({
                        x: this.gameWidth * 0.3 + (i * (this.gameWidth * 0.4 / 11)),
                        y: extraRowY + (Math.random() - 0.5) * 3,
                        color: villagerColors[(i + row + 20) % villagerColors.length],
                        index: i + row * 12 + 5000,
                        scale: villagerScale * 0.75,
                        baseY: extraRowY,
                        animOffset: Math.random() * Math.PI * 2 + 4
                    });
                }
                
                for (let i = 0; i < 6; i++) {
                    this.crowdCache.push({
                        x: this.gameWidth * 0.05 + (i * (this.gameWidth * 0.2 / 5)),
                        y: extraRowY + (Math.random() - 0.5) * 3,
                        color: villagerColors[(i + row + 25) % villagerColors.length],
                        index: i + row * 6 + 6000,
                        scale: villagerScale * 0.75,
                        baseY: extraRowY,
                        animOffset: Math.random() * Math.PI * 2 + 5
                    });
                }
                
                for (let i = 0; i < 6; i++) {
                    this.crowdCache.push({
                        x: this.gameWidth * 0.75 + (i * (this.gameWidth * 0.2 / 5)),
                        y: extraRowY + (Math.random() - 0.5) * 3,
                        color: villagerColors[(i + row + 30) % villagerColors.length],
                        index: i + row * 6 + 7000,
                        scale: villagerScale * 0.75,
                        baseY: extraRowY,
                        animOffset: Math.random() * Math.PI * 2 + 6
                    });
                }
            }
        }
        
        // Desktop back rows
        if (!isMobileScreen && maxRows > 10) {
            const backRows = Math.min(3, maxRows - 10);
            for (let row = 0; row < backRows; row++) {
                for (let i = 0; i < 12; i++) {
                    this.crowdCache.push({
                        x: this.gameWidth * 0.35 + (i * (this.gameWidth * 0.3 / 11)),
                        y: crowdStartY + ((centerRows + row) * rowHeight),
                        color: villagerColors[(i + row + 15) % villagerColors.length],
                        index: i + row * 12 + 4000,
                        scale: villagerScale * 0.7,
                        baseY: crowdStartY + ((centerRows + row) * rowHeight),
                        animOffset: Math.random() * Math.PI * 2 + 3
                    });
                }
            }
        }
    }

/**
 * Update crowd animations
 * @param {number} deltaTime - Time delta
 */
updateCrowdAnimations(deltaTime) {
    this.crowdAnimation.time += deltaTime * 2000;

    // DEBUG: Simple verification that animation is running
    console.log('Animation time:', this.crowdAnimation.time);
    
    const projectileIntensity = Math.min(this.projectiles.length / 10, 1);
    this.crowdAnimation.waveAmplitude = 8 + projectileIntensity * 12;
    this.crowdAnimation.waveSpeed = 0.003 + projectileIntensity * 0.005;
}
    /**
     * Draw cached crowd
     */
    drawCachedCrowd() {
       // MOBILE: Skip cached crowd rendering
    if (this.isMobile || !this.crowdCache) {
        return;
    }
        const time = Date.now() * 0.0008;
        
        this.crowdCache.forEach(villager => {
            const animY = villager.baseY + Math.sin(time + villager.animOffset) * 0.4;
            this.drawAngryVillager(villager.x, animY, villager.color, villager.index, villager.scale);
        });
    }

    /**
     * Draw angry villager character
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} color - Villager color
     * @param {number} index - Villager index
     * @param {number} scale - Villager scale
     */
    drawAngryVillager(x, y, color, index, scale = 1.0) {
        const time = Date.now() * 0.005;
        const armWave = Math.sin(time + index * 0.5) * 0.4;
        const size = 20 * scale;
        
        // Body
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x, y, size * 0.9, size * 1.8);
        
        // Head
        this.ctx.fillStyle = '#DEB887';
        this.ctx.beginPath();
        this.ctx.arc(x + size * 0.45, y - size * 0.4, size * 0.4, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Eyes
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(x + size * 0.25, y - size * 0.5, size * 0.1, size * 0.1);
        this.ctx.fillRect(x + size * 0.55, y - size * 0.5, size * 0.1, size * 0.1);
        
        // Mouth
        this.ctx.strokeStyle = '#000';
        this.ctx.lineWidth = 2 * scale;
        this.ctx.beginPath();
        this.ctx.arc(x + size * 0.45, y - size * 0.15, size * 0.15, 0, Math.PI);
        this.ctx.stroke();
        
        // Arms
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 4 * scale;
        
        this.ctx.beginPath();
        this.ctx.moveTo(x + size * 0.1, y + size * 0.3);
        this.ctx.lineTo(x + size * 0.1 + Math.cos(armWave + 2.5) * size * 0.6, 
                       y + size * 0.3 + Math.sin(armWave + 2.5) * size * 0.6);
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.moveTo(x + size * 0.8, y + size * 0.3);
        this.ctx.lineTo(x + size * 0.8 + Math.cos(armWave + 0.6) * size * 0.6, 
                       y + size * 0.3 + Math.sin(armWave + 0.6) * size * 0.6);
        this.ctx.stroke();
    }

    /**
     * Draw podium and microphone
     */
    drawPodiumAndMic() {
        const centerX = this.gameWidth / 2;
        const groundY = this.gameHeight * 0.65;
        const stageY = groundY - 15;
        const isMobileScreen = this.gameWidth < 768;
        const basePodiumScale = this.gameWidth / 1400;
        const podiumScale = isMobileScreen ? Math.max(0.8, basePodiumScale) : basePodiumScale;
        
        // Stage platform
        this.ctx.fillStyle = '#8B7355';
        this.ctx.fillRect(centerX - 100 * podiumScale, stageY, 200 * podiumScale, 15 * podiumScale);
        
        // Stage edge
        this.ctx.fillStyle = '#654321';
        this.ctx.fillRect(centerX - 100 * podiumScale, stageY + 15 * podiumScale, 200 * podiumScale, 3 * podiumScale);
        
        // Podium
        this.ctx.fillStyle = '#A0522D';
        this.ctx.fillRect(centerX - 40 * podiumScale, stageY - 50 * podiumScale, 80 * podiumScale, 50 * podiumScale);
        
        // Podium details
        this.ctx.fillStyle = '#654321';
        this.ctx.fillRect(centerX - 35 * podiumScale, stageY - 55 * podiumScale, 70 * podiumScale, 5 * podiumScale);
        
        // Microphone stand
        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 4 * podiumScale;
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, stageY - 50 * podiumScale);
        this.ctx.lineTo(centerX, stageY - 80 * podiumScale);
        this.ctx.stroke();
        
        // Microphone
        this.ctx.fillStyle = '#666';
        this.ctx.beginPath();
        this.ctx.arc(centerX, stageY - 85 * podiumScale, 8 * podiumScale, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Microphone windscreen
        this.ctx.fillStyle = '#444';
        this.ctx.beginPath();
        this.ctx.arc(centerX, stageY - 85 * podiumScale, 6 * podiumScale, 0, Math.PI * 2);
        this.ctx.fill();
    }

/**
 * Draw politician character with enhanced reactions
 */
drawPolitician() {
    const p = this.politician;
    
    // Update stress level based on health
    this.reactionSystem.politician.stressLevel = Math.max(0, 100 - this.politicianHealth);
    
    // Determine animation based on reaction state
    let animation = 'idle';
    let frameSpeed = 0.4;
    
    if (p.reactionTimer > 0) {
        frameSpeed = 0.15;
        animation = p.reactionState;
    } else if (this.projectiles.length > 5) {
        animation = 'panicked';
        frameSpeed = 0.2;
    } else if (this.politicianHealth < 20) {
        animation = 'critical';
        frameSpeed = 0.3;
    }
    
    this.setCharacterAnimation('politician', animation);
    
    // Draw politician with stress-based shake
    this.ctx.save();
    if (this.reactionSystem.politician.stressLevel > 70) {
        const shake = (this.reactionSystem.politician.stressLevel - 70) / 30 * 2;
        this.ctx.translate(
            (Math.random() - 0.5) * shake,
            (Math.random() - 0.5) * shake
        );
    }
    
    const spriteDrawn = this.drawCharacterSprite(
        'politician',
        p.x,
        p.y,
        90,
        130,
        animation
    );
    
    this.ctx.restore();
    
    // Draw reaction effects
    this.drawPoliticianReactionEffects();
    
    // Draw stains over the politician sprite
    if (spriteDrawn && p.stains.length > 0) {
        this.drawPoliticianStains(p);
    }
    
    // Fallback if sprite fails
    if (!spriteDrawn) {
        this.ctx.fillStyle = '#9370DB';
        this.ctx.fillRect(p.x, p.y, 75, 100);
        
        if (p.stains.length > 0) {
            this.drawPoliticianStains(p);
        }
    }
    
    // Draw message bubble after drawing the politician
    if (p.messageBubble.isVisible) {
        this.drawMessageBubble(p);
    }
}

/**
 * Draw politician reaction effects
 */
drawPoliticianReactionEffects() {
    const p = this.politician;
    const reactions = this.reactionSystem.politician;
    
    // Draw worry sweat when health is low
    if (this.politicianHealth < 50) {
        this.drawWorrySweat();
    }
    
    // Draw reaction circle when recently hit
    if (p.reactionTimer > 0) {
        this.drawReactionCircle();
    }
    
    // Draw stress indicators when health is critical
    if (this.politicianHealth < 25) {
        this.drawStressIndicators();
    }
    
    // Update and draw sweat drops
    this.updateAndDrawSweatDrops();
}

/**
 * Draw worry sweat drops
 */
drawWorrySweat() {
    const p = this.politician;
    const sweatPositions = [
        { x: p.x + 25, y: p.y + 20 },
        { x: p.x + 65, y: p.y + 30 }
    ];
    
    this.ctx.save();
    this.ctx.fillStyle = '#87CEEB';
    this.ctx.shadowColor = '#87CEEB';
    this.ctx.shadowBlur = 3;
    
    sweatPositions.forEach((pos, index) => {
        const time = Date.now() * 0.003 + index;
        const wobble = Math.sin(time) * 2;
        
        // Main sweat drop
        this.ctx.beginPath();
        this.ctx.arc(pos.x + wobble, pos.y, 3, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Drip animation
        this.ctx.beginPath();
        this.ctx.ellipse(pos.x + wobble, pos.y + 10, 1.5, 4, 0, 0, Math.PI * 2);
        this.ctx.fill();
    });
    
    this.ctx.restore();
}

/**
 * Draw reaction circle effect
 */
drawReactionCircle() {
    const p = this.politician;
    const time = Date.now() * 0.008;
    const reactionIntensity = p.reactionTimer / 2000; // Normalize to 0-1
    
    const radius = 50 + Math.sin(time) * 8 * reactionIntensity;
    const alpha = Math.max(0.1, reactionIntensity * 0.6);
    
    this.ctx.save();
    this.ctx.globalAlpha = alpha;
    this.ctx.strokeStyle = '#FF6B6B';
    this.ctx.lineWidth = 3 * reactionIntensity;
    this.ctx.setLineDash([8, 8]);
    this.ctx.lineDashOffset = time * 10;
    
    this.ctx.beginPath();
    this.ctx.arc(
        p.x + p.width/2,
        p.y + p.height/2,
        radius, 0, Math.PI * 2
    );
    this.ctx.stroke();
    
    this.ctx.setLineDash([]);
    this.ctx.restore();
}

/**
 * Draw stress indicators for critical health
 */
drawStressIndicators() {
    const p = this.politician;
    const time = Date.now() * 0.01;
    
    // Stress lines around head
    const stressLines = 8;
    const headCenterX = p.x + p.width/2;
    const headCenterY = p.y + 20;
    
    this.ctx.save();
    this.ctx.strokeStyle = '#FF4757';
    this.ctx.lineWidth = 2;
    this.ctx.globalAlpha = 0.7;
    
    for (let i = 0; i < stressLines; i++) {
        const angle = (i / stressLines) * Math.PI * 2 + time;
        const innerRadius = 35;
        const outerRadius = 45 + Math.sin(time * 3 + i) * 5;
        
        const startX = headCenterX + Math.cos(angle) * innerRadius;
        const startY = headCenterY + Math.sin(angle) * innerRadius;
        const endX = headCenterX + Math.cos(angle) * outerRadius;
        const endY = headCenterY + Math.sin(angle) * outerRadius;
        
        this.ctx.beginPath();
        this.ctx.moveTo(startX, startY);
        this.ctx.lineTo(endX, endY);
        this.ctx.stroke();
    }
    
    this.ctx.restore();
}

/**
 * Update and draw animated sweat drops
 */
updateAndDrawSweatDrops() {
    const reactions = this.reactionSystem.politician;
    
    // Add new sweat drops when stressed
    if (this.politicianHealth < 30 && Math.random() < 0.02) {
        reactions.sweatDrops.push({
            x: this.politician.x + 20 + Math.random() * 50,
            y: this.politician.y + 15 + Math.random() * 10,
            vy: 50 + Math.random() * 30,
            life: 2.0,
            size: 2 + Math.random() * 2
        });
    }
    
    // Update and draw sweat drops
    this.ctx.save();
    this.ctx.fillStyle = '#87CEEB';
    this.ctx.shadowColor = '#87CEEB';
    this.ctx.shadowBlur = 2;
    
    for (let i = reactions.sweatDrops.length - 1; i >= 0; i--) {
        const drop = reactions.sweatDrops[i];
        
        drop.y += drop.vy * 0.016;
        drop.life -= 0.016;
        
        if (drop.life <= 0 || drop.y > this.gameHeight) {
            reactions.sweatDrops.splice(i, 1);
            continue;
        }
        
        this.ctx.globalAlpha = Math.min(1, drop.life / 2.0);
        this.ctx.beginPath();
        this.ctx.arc(drop.x, drop.y, drop.size, 0, Math.PI * 2);
        this.ctx.fill();
    }
    
    this.ctx.restore();
}

drawMessageBubble() {
    const bubble = this.politician.messageBubble;
    const p = this.politician;
    
    // Bubble position (above politician's head)
    const bubbleX = p.x + p.width/2;
    const bubbleY = p.y - 60;
    const bubbleWidth = 200;
    const bubbleHeight = 40;
    
    this.ctx.save();
    this.ctx.globalAlpha = bubble.fadeIn;
    
    // Draw bubble background
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    this.ctx.strokeStyle = '#333';
    this.ctx.lineWidth = 2;
    
    // Rounded rectangle for bubble
    this.ctx.beginPath();
    this.ctx.roundRect(bubbleX - bubbleWidth/2, bubbleY - bubbleHeight/2, bubbleWidth, bubbleHeight, 10);
    this.ctx.fill();
    this.ctx.stroke();
    
    // Draw bubble tail (pointing to politician)
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    this.ctx.beginPath();
    this.ctx.moveTo(bubbleX - 10, bubbleY + bubbleHeight/2);
    this.ctx.lineTo(bubbleX, bubbleY + bubbleHeight/2 + 15);
    this.ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight/2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // Draw text
    this.ctx.fillStyle = '#333';
    this.ctx.font = 'bold 14px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.textBaseline = 'middle';
    this.ctx.fillText(bubble.text, bubbleX, bubbleY);
    
    this.ctx.restore();
}
    
    /**
 * Draw aide character with enhanced reactions
 */
drawAide() {
    const a = this.aide;
    const reactions = this.reactionSystem.aide;
    
    // Update confidence based on recent performance
    const timeSinceLastSuccess = Date.now() - reactions.lastSuccessTime;
    if (timeSinceLastSuccess > 5000) {
        reactions.confidenceLevel = Math.max(50, reactions.confidenceLevel - 0.5);
    }
    
    let animation = 'idle';
    
    // Determine animation based on state and confidence
    if (reactions.victoryPose && reactions.victoryTimer > 0) {
        animation = 'victory';
    } else if (a.shield) {
        const hasProjectilesFromSide = this.projectiles.some(proj => 
            Math.abs(proj.x - a.x) > Math.abs(proj.y - a.y)
        );
        animation = hasProjectilesFromSide ? 'shield_side' : 'shield_up';
    } else if (this.projectiles.length > 5) {
        animation = 'crouch_cover';
    } else if (this.projectiles.some(proj => proj.y > a.y)) {
        animation = 'swat_down';
    } else if (reactions.confidenceLevel < 60) {
        animation = 'worried';
    } else if (a.expression === 'focused') {
        animation = 'focused';
    } else if (this.keys['KeyA'] || this.keys['KeyD'] || 
               this.keys['ArrowLeft'] || this.keys['ArrowRight']) {
        animation = 'walking';
    }
    
    this.setCharacterAnimation('aide', animation);
    
    // Draw aide with confidence-based effects
    this.ctx.save();
    
    // Add confidence glow effect
    if (reactions.confidenceLevel > 80) {
        this.ctx.shadowColor = '#00FFFF';
        this.ctx.shadowBlur = 8;
    }
    
    const spriteDrawn = this.drawCharacterSprite(
        'aide',
        a.x,
        a.y + a.bounceY,
        100,
        130,
        animation
    );
    
    this.ctx.restore();
    
    // Draw aide reaction effects
    this.drawAideReactionEffects();
    
    // Draw shield effect
    if (a.shield) {
        this.drawShieldEffect(a);
    }
}

/**
 * Draw aide reaction effects
 */
drawAideReactionEffects() {
    const a = this.aide;
    const reactions = this.reactionSystem.aide;
    
    // Draw confidence indicator
    this.drawConfidenceIndicator();
    
    // Draw victory effects
    if (reactions.victoryPose && reactions.victoryTimer > 0) {
        this.drawVictoryEffects();
    }
    
    // Draw focus lines when concentrated
    if (a.expression === 'focused' && a.shield) {
        this.drawFocusLines();
    }
}

/**
 * Draw confidence level indicator
 */
drawConfidenceIndicator() {
    const a = this.aide;
    const reactions = this.reactionSystem.aide;
    
    if (reactions.confidenceLevel < 70) {
        // Draw worry indicators
        const time = Date.now() * 0.005;
        const worryIntensity = (70 - reactions.confidenceLevel) / 70;
        
        this.ctx.save();
        this.ctx.strokeStyle = '#FFD700';
        this.ctx.lineWidth = 2;
        this.ctx.globalAlpha = worryIntensity * 0.6;
        
        // Worry lines above head
        for (let i = 0; i < 3; i++) {
            const x = a.x + 30 + i * 15 + Math.sin(time + i) * 3;
            const y = a.y - 10 - i * 5;
            
            this.ctx.beginPath();
            this.ctx.moveTo(x - 5, y);
            this.ctx.lineTo(x + 5, y);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }
}

/**
 * Draw victory celebration effects
 */
drawVictoryEffects() {
    const a = this.aide;
    const time = Date.now() * 0.01;
    
    // Victory sparkles
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + time;
        const radius = 40 + Math.sin(time * 2 + i) * 10;
        const x = a.x + 50 + Math.cos(angle) * radius;
        const y = a.y + 50 + Math.sin(angle) * radius;
        
        this.ctx.save();
        this.ctx.fillStyle = '#FFD700';
        this.ctx.globalAlpha = 0.8;
        this.ctx.shadowColor = '#FFD700';
        this.ctx.shadowBlur = 5;
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, 2 + Math.sin(time * 3 + i), 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.restore();
    }
}

/**
 * Draw focus concentration lines
 */
drawFocusLines() {
    const a = this.aide;
    const time = Date.now() * 0.008;
    
    this.ctx.save();
    this.ctx.strokeStyle = '#00FFFF';
    this.ctx.lineWidth = 1;
    this.ctx.globalAlpha = 0.6;
    
    // Focus lines emanating from eyes
    const eyeX = a.x + 50;
    const eyeY = a.y + 30;
    
    for (let i = 0; i < 6; i++) {
        const angle = -Math.PI/3 + (i / 5) * (2 * Math.PI/3) + Math.sin(time + i) * 0.1;
        const length = 25 + Math.sin(time * 2 + i) * 5;
        
        this.ctx.beginPath();
        this.ctx.moveTo(eyeX, eyeY);
        this.ctx.lineTo(
            eyeX + Math.cos(angle) * length,
            eyeY + Math.sin(angle) * length
        );
        this.ctx.stroke();
    }
    
    this.ctx.restore();
}

    /**
     * Draw shield effect
     * @param {Object} aide - Aide character object
     */
    drawShieldEffect(aide) {
        const time = Date.now() * 0.01;
        const radius = 55 + Math.sin(time) * 4;
        
        this.ctx.strokeStyle = '#00FFFF';
        this.ctx.lineWidth = 4;
        this.ctx.setLineDash([10, 5]);
        this.ctx.beginPath();
        this.ctx.arc(aide.x + 40, aide.y + 65 + aide.bounceY, radius, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        
        for (let i = 0; i < 10; i++) {
            const angle = (time + i * Math.PI / 5) % (Math.PI * 2);
            const sx = aide.x + 40 + Math.cos(angle) * (radius - 4);
            const sy = aide.y + 65 + aide.bounceY + Math.sin(angle) * (radius - 4);
            
            this.ctx.fillStyle = '#00FFFF';
            this.ctx.globalAlpha = 0.8;
            this.ctx.beginPath();
            this.ctx.arc(sx, sy, 3, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.globalAlpha = 1.0;
        }
    }


/**
 * Draw projectiles with all visual effects
 */
drawProjectiles() {
    // Draw impact predictions first (behind projectiles)
    this.drawImpactPredictions();
    
    // Draw warning indicators
    this.drawWarningIndicators();
    
    // Draw enhanced projectile trails
    this.drawEnhancedTrails();
    
    // Draw projectiles with enhanced effects
    this.projectiles.forEach(proj => {
        this.ctx.save();
        
        // Enhanced glow based on threat level
        this.ctx.shadowColor = this.projectileEffects.threatLevels[proj.threatLevel].color;
        this.ctx.shadowBlur = 10 + (proj.glowIntensity * 5);
        
        // Pulsing effect for high threat projectiles
        if (proj.threatLevel === 'high' || proj.threatLevel === 'critical') {
            const pulseScale = 1.0 + Math.sin(Date.now() * 0.01) * 0.1;
            this.ctx.translate(proj.x, proj.y);
            this.ctx.scale(pulseScale, pulseScale);
            this.ctx.translate(-proj.x, -proj.y);
        }
        
        // Draw main projectile
        this.ctx.translate(proj.x, proj.y);
        this.ctx.rotate(proj.rotation);
        this.drawGlassmorphicProjectile(proj);
        this.ctx.restore();
        
        // Draw priority rings (your existing method)
        this.drawProjectilePriorityRings(proj);
        
        // Draw proximity warning
        this.drawProximityWarning(proj);
    });
}

/**
 * Draw enhanced projectile trails
 */
drawEnhancedTrails() {
    this.projectiles.forEach(proj => {
        if (proj.enhancedTrail.length < 2) return;
        
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'screen';
        
        // Draw gradient trail
        for (let i = 1; i < proj.enhancedTrail.length; i++) {
            const current = proj.enhancedTrail[i];
            const previous = proj.enhancedTrail[i - 1];
            
            if (current.alpha <= 0 || previous.alpha <= 0) continue;
            
            const gradient = this.ctx.createLinearGradient(
                previous.x, previous.y, current.x, current.y
            );
            
            const threatColor = this.projectileEffects.threatLevels[proj.threatLevel].color;
            gradient.addColorStop(0, `${threatColor}${Math.floor(previous.alpha * 255).toString(16).padStart(2, '0')}`);
            gradient.addColorStop(1, `${threatColor}${Math.floor(current.alpha * 255).toString(16).padStart(2, '0')}`);
            
            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = Math.max(1, current.size * 0.3);
            this.ctx.lineCap = 'round';
            
            this.ctx.beginPath();
            this.ctx.moveTo(previous.x, previous.y);
            this.ctx.lineTo(current.x, current.y);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    });
}

/**
 * Draw impact prediction indicators
 */
drawImpactPredictions() {
    this.projectileEffects.impactPredictions.forEach((prediction, index) => {
        const time = Date.now() * 0.005;
        const pulse = Math.sin(time * prediction.pulseSpeed) * 0.5 + 0.5;
        const alpha = (prediction.life / prediction.maxLife) * 0.8;
        
        // Expanding circle
        const currentRadius = prediction.radius + 
            ((prediction.maxRadius - prediction.radius) * (1 - prediction.life / prediction.maxLife));
        
        this.ctx.save();
        this.ctx.globalAlpha = alpha * (0.5 + pulse * 0.5);
        this.ctx.strokeStyle = prediction.color;
        this.ctx.lineWidth = 3;
        this.ctx.setLineDash([5, 5]);
        this.ctx.lineDashOffset = time * 20;
        
        // Outer circle
        this.ctx.beginPath();
        this.ctx.arc(prediction.x, prediction.y, currentRadius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Inner crosshair for critical threats
        if (prediction.threatLevel === 'critical') {
            this.ctx.setLineDash([]);
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(prediction.x - 10, prediction.y);
            this.ctx.lineTo(prediction.x + 10, prediction.y);
            this.ctx.moveTo(prediction.x, prediction.y - 10);
            this.ctx.lineTo(prediction.x, prediction.y + 10);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
        
        // Update prediction
        prediction.life -= 0.016;
        if (prediction.life <= 0) {
            this.projectileEffects.impactPredictions.splice(index, 1);
        }
    });
}

/**
 * Draw warning indicators
 */
drawWarningIndicators() {
    this.projectileEffects.warningIndicators.forEach(warning => {
        const pulse = Math.sin(Date.now() * 0.01 * warning.pulseIntensity) * 0.3 + 0.7;
        
        this.ctx.save();
        this.ctx.globalAlpha = warning.alpha * pulse;
        this.ctx.strokeStyle = warning.color;
        this.ctx.lineWidth = 4;
        this.ctx.setLineDash([10, 10]);
        
        this.ctx.beginPath();
        this.ctx.arc(warning.x, warning.y, warning.radius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        this.ctx.setLineDash([]);
        this.ctx.restore();
    });
}

/**
 * Draw proximity warning for close projectiles
 * @param {Object} proj - Projectile object
 */
drawProximityWarning(proj) {
    const warningDistance = 100;
    
    if (proj.distanceToPolitician <= warningDistance) {
        const intensity = 1 - (proj.distanceToPolitician / warningDistance);
        const time = Date.now() * 0.02;
        
        this.ctx.save();
        this.ctx.globalAlpha = intensity * 0.6 * (0.5 + Math.sin(time) * 0.5);
        this.ctx.strokeStyle = '#FF0000';
        this.ctx.lineWidth = 2 + intensity * 3;
        this.ctx.setLineDash([8, 8]);
        
        const warningRadius = proj.size + 15 + Math.sin(time) * 5;
        this.ctx.beginPath();
        this.ctx.arc(proj.x, proj.y, warningRadius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        this.ctx.setLineDash([]);
        this.ctx.restore();
    }
}
drawProjectilePriorityRings(projectile) {
    const currentTime = Date.now();
    const age = currentTime - projectile.spawnTime;
    
    // Only show ring for first 2 seconds
    if (age > 2000) return;
    
    const ringProgress = (age % 1500) / 1500; // Complete circle every 1.5 seconds
    const fadeOut = age > 1500 ? 1 - ((age - 1500) / 500) : 1;
    
    if (fadeOut <= 0) return;
    
    const ringRadius = projectile.size + 15;
    const angle = ringProgress * Math.PI * 2;
    
    this.ctx.save();
    this.ctx.globalAlpha = fadeOut * 0.7;
    
    // Draw rotating ring segments
    for (let i = 0; i < 8; i++) {
        const segmentAngle = angle + (i * Math.PI / 4);
        const x = projectile.x + Math.cos(segmentAngle) * ringRadius;
        const y = projectile.y + Math.sin(segmentAngle) * ringRadius;
        
        this.ctx.fillStyle = this.getPriorityColor(projectile.type);
        this.ctx.beginPath();
        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Subtle trail
        if (i > 0) {
            const prevAngle = segmentAngle - 0.1;
            const prevX = projectile.x + Math.cos(prevAngle) * ringRadius;
            const prevY = projectile.y + Math.sin(prevAngle) * ringRadius;
            
            this.ctx.strokeStyle = this.getPriorityColor(projectile.type);
            this.ctx.lineWidth = 1;
            this.ctx.globalAlpha = fadeOut * 0.3;
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.stroke();
        }
    }
    
    this.ctx.restore();
}

getPriorityColor(projectileType) {
    const colors = {
        tomato: '#FF4757',
        egg: '#FFD700',
        shoe: '#8B4513',
        bottle: '#228B22',
        stone: '#696969',
        banana: '#FFD700',
        apple: '#DC143C'
    };
    return colors[projectileType] || '#FF6B6B';
}
/**
 * Draw individual glassmorphic projectile
 * @param {Object} proj - Projectile object
 */
drawGlassmorphicProjectile(proj) {
    const size = proj.size;
    
    // Stronger shadow for visibility
    this.ctx.shadowColor = proj.color;
    this.ctx.shadowBlur = 20;
    this.ctx.shadowOffsetX = 2;
    this.ctx.shadowOffsetY = 2;
    
    // With glassmorphic gradient
    const gradient = this.ctx.createRadialGradient(-size/4, -size/4, 0, 0, 0, size/2);
    gradient.addColorStop(0, `rgba(255, 255, 255, 0.8)`);
    gradient.addColorStop(0.3, `rgba(255, 255, 255, 0.6)`);
    gradient.addColorStop(0.7, proj.glassTint + '40');
    gradient.addColorStop(1, proj.color + '20');

    this.ctx.fillStyle = gradient;
    
    // Outline for better definition
    this.ctx.strokeStyle = proj.color;
    this.ctx.lineWidth = 2;
    
    switch(proj.type) {
        case 'tomato':
            this.drawDetailedTomato(size);
            break;
        case 'egg':
            this.drawDetailedEgg(size);
            break;
        case 'shoe':
            this.drawDetailedShoe(size);
            break;
        case 'bottle':
            this.drawDetailedBottle(size);
            break;
        case 'stone':
            this.drawDetailedStone(size);
            break;
        case 'banana':
            this.drawDetailedBanana(size);
            break;
        case 'apple':
            this.drawDetailedApple(size);
            break;
    }
    
    // Updated highlights
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    this.ctx.beginPath();
    this.ctx.ellipse(-size/3, -size/3, size/3, size/5, 0, 0, Math.PI * 2);
    this.ctx.fill();
    
    this.ctx.shadowBlur = 0;
    this.ctx.shadowOffsetX = 0;
    this.ctx.shadowOffsetY = 0;
}

/**
 * Individual projectile shapes
 */

drawDetailedTomato(size) {
    // Main tomato body - more prominent
    this.ctx.beginPath();
    this.ctx.arc(0, 0, size/2, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // Enhanced tomato segments - more visible
    this.ctx.strokeStyle = 'rgba(139, 0, 0, 0.7)';
    this.ctx.lineWidth = 2;
    for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo(Math.cos(angle) * size/2, Math.sin(angle) * size/2);
        this.ctx.stroke();
    }
    
    // Larger, more visible green stem
    this.ctx.fillStyle = '#228B22';
    this.ctx.fillRect(-6, -size/2 - 4, 12, 16);
    this.ctx.strokeStyle = '#006400';
    this.ctx.lineWidth = 2;
    this.ctx.strokeRect(-6, -size/2 - 4, 12, 16);
    
    // Stem leaves for instant recognition
    this.ctx.fillStyle = '#32CD32';
    this.ctx.beginPath();
    this.ctx.ellipse(-4, -size/2 + 2, 3, 6, -Math.PI/6, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.beginPath();
    this.ctx.ellipse(4, -size/2 + 2, 3, 6, Math.PI/6, 0, Math.PI * 2);
    this.ctx.fill();
}

drawDetailedEgg(size) {
    // Updated egg shape
    this.ctx.beginPath();
    this.ctx.ellipse(0, 0, size/2, size/1.4, 0, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // More prominent crack lines for recognition
    this.ctx.strokeStyle = '#CCC';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.moveTo(-size/3, -size/6);
    this.ctx.lineTo(size/3, size/6);
    this.ctx.stroke();
    this.ctx.beginPath();
    this.ctx.moveTo(-size/4, size/4);
    this.ctx.lineTo(size/6, -size/8);
    this.ctx.stroke();
    
    // Updated speckles - larger and more visible
    this.ctx.fillStyle = 'rgba(139, 117, 91, 0.6)';
    for (let i = 0; i < 8; i++) {
        const x = (Math.random() - 0.5) * size * 0.6;
        const y = (Math.random() - 0.5) * size * 0.8;
        this.ctx.beginPath();
        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
        this.ctx.fill();
    }
}

drawDetailedShoe(size) {
    // Updated shoe body
    this.ctx.beginPath();
    this.ctx.roundRect(-size/2, -size/3, size, size/1.5, 8);
    this.ctx.fill();
    this.ctx.stroke();
    
    // More prominent sole
    this.ctx.fillStyle = '#654321';
    this.ctx.fillRect(-size/2, size/6, size, 8);
    this.ctx.strokeStyle = '#8B4513';
    this.ctx.lineWidth = 2;
    this.ctx.strokeRect(-size/2, size/6, size, 8);
    
    // Updated shoelaces - thicker and more visible
    this.ctx.strokeStyle = '#000';
    this.ctx.lineWidth = 4;
    this.ctx.beginPath();
    this.ctx.moveTo(-size/4, -size/6);
    this.ctx.lineTo(size/4, size/12);
    this.ctx.moveTo(size/4, -size/6);
    this.ctx.lineTo(-size/4, size/12);
    this.ctx.stroke();
    
    // Prominent eyelets
    this.ctx.fillStyle = '#000';
    for(let i = -1; i <= 1; i++) {
        this.ctx.beginPath();
        this.ctx.arc(i * size/6, -size/8, size/20, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.beginPath();
        this.ctx.arc(i * size/6, size/16, size/20, 0, Math.PI * 2);
        this.ctx.fill();
    }
    
    // Add heel detail for recognition
    this.ctx.fillStyle = '#8B4513';
    this.ctx.fillRect(size/3, -size/4, size/6, size/2);
    this.ctx.strokeStyle = '#654321';
    this.ctx.strokeRect(size/3, -size/4, size/6, size/2);
}

drawDetailedBottle(size) {
    // Updated bottle body - more bottle-like
    this.ctx.beginPath();
    this.ctx.roundRect(-size/4, -size/2, size/2, size, 6);
    this.ctx.fill();
    this.ctx.stroke();
    
    // More prominent bottle neck
    this.ctx.fillRect(-size/6, -size/2 - 12, size/3, 16);
    this.ctx.strokeStyle = '#006400';
    this.ctx.lineWidth = 2;
    this.ctx.strokeRect(-size/6, -size/2 - 12, size/3, 16);
    
    // Updated bottle cap - more visible
    this.ctx.fillStyle = '#8B0000';
    this.ctx.fillRect(-size/5, -size/2 - 8, size/2.5, 6);
    this.ctx.strokeStyle = '#654321';
    this.ctx.lineWidth = 2;
    this.ctx.strokeRect(-size/5, -size/2 - 8, size/2.5, 6);
    
    // More prominent label with text-like lines
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    this.ctx.fillRect(-size/5, -size/6, size/2.5, size/3);
    this.ctx.strokeStyle = '#000';
    this.ctx.lineWidth = 1;
    this.ctx.strokeRect(-size/5, -size/6, size/2.5, size/3);
    
    // Label text lines for recognition
    this.ctx.strokeStyle = '#666';
    this.ctx.lineWidth = 1;
    for(let i = 0; i < 4; i++) {
        this.ctx.beginPath();
        this.ctx.moveTo(-size/6, -size/8 + i * 3);
        this.ctx.lineTo(size/8, -size/8 + i * 3);
        this.ctx.stroke();
    }
}

drawDetailedStone(size) {
    // Updated irregular stone shape
    this.ctx.beginPath();
    const sides = 10;
    for (let i = 0; i < sides; i++) {
        const angle = (i / sides) * Math.PI * 2;
        const radius = size/2 + Math.sin(i * 2.3) * 6;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) this.ctx.moveTo(x, y);
        else this.ctx.lineTo(x, y);
    }
    this.ctx.closePath();
    this.ctx.fill();
    this.ctx.stroke();
    
    // Updated stone texture - more prominent
    this.ctx.fillStyle = 'rgba(105, 105, 105, 0.6)';
    for (let i = 0; i < 12; i++) {
        const x = (Math.random() - 0.5) * size * 0.7;
        const y = (Math.random() - 0.5) * size * 0.7;
        this.ctx.beginPath();
        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
        this.ctx.fill();
    }
    
    // Cracks for better stone recognition
    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
    this.ctx.lineWidth = 1;
    for (let i = 0; i < 3; i++) {
        this.ctx.beginPath();
        this.ctx.moveTo((Math.random() - 0.5) * size, (Math.random() - 0.5) * size);
        this.ctx.lineTo((Math.random() - 0.5) * size, (Math.random() - 0.5) * size);
        this.ctx.stroke();
    }
}

drawDetailedBanana(size) {
    // Updated banana curve - more recognizable
    this.ctx.beginPath();
    this.ctx.ellipse(0, 0, size/2, size/1.2, Math.PI/6, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // More prominent banana ridges
    this.ctx.strokeStyle = 'rgba(218, 165, 32, 0.7)';
    this.ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
        this.ctx.beginPath();
        this.ctx.ellipse(0, 0, size/2 - i*4, size/1.2 - i*3, Math.PI/6, 0, Math.PI * 2);
        this.ctx.stroke();
    }
    
    // Updated brown spots - larger and more visible
    this.ctx.fillStyle = 'rgba(139, 69, 19, 0.7)';
    for (let i = 0; i < 6; i++) {
        const x = (Math.random() - 0.5) * size * 0.6;
        const y = (Math.random() - 0.5) * size * 0.8;
        this.ctx.beginPath();
        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
        this.ctx.fill();
    }
    
    // Banana tips for better recognition
    this.ctx.fillStyle = '#8B4513';
    this.ctx.beginPath();
    this.ctx.ellipse(-size/3, size/4, 3, 6, Math.PI/3, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.beginPath();
    this.ctx.ellipse(size/4, -size/3, 3, 6, -Math.PI/6, 0, Math.PI * 2);
    this.ctx.fill();
}

drawDetailedApple(size) {
    // Updated apple body
    this.ctx.beginPath();
    this.ctx.arc(0, size/8, size/2.2, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // More pronounced apple indent
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    this.ctx.beginPath();
    this.ctx.ellipse(0, -size/4, size/4, size/5, 0, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Larger, more visible stem
    this.ctx.fillStyle = '#8B4513';
    this.ctx.fillRect(-3, -size/2, 6, 14);
    this.ctx.strokeStyle = '#654321';
    this.ctx.lineWidth = 1;
    this.ctx.strokeRect(-3, -size/2, 6, 14);
    
    // Updated apple leaf - much more prominent
    this.ctx.fillStyle = '#228B22';
    this.ctx.beginPath();
    this.ctx.ellipse(8, -size/2 + 4, 6, 12, Math.PI/4, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.strokeStyle = '#006400';
    this.ctx.lineWidth = 1;
    this.ctx.stroke();
    
    // Add prominent apple shine
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    this.ctx.beginPath();
    this.ctx.ellipse(-size/3, -size/8, size/5, size/6, 0, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Add apple texture lines
    this.ctx.strokeStyle = 'rgba(178, 34, 34, 0.3)';
    this.ctx.lineWidth = 1;
    for (let i = 0; i < 3; i++) {
        const angle = (i / 3) * Math.PI * 2;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo(Math.cos(angle) * size/3, size/8 + Math.sin(angle) * size/3);
        this.ctx.stroke();
    }
}

/**
 * Get screen shake intensity by projectile type
 */
getShakeIntensity(projectileType) {
    const shakeMap = {
        tomato: 4,
        egg: 3,
        shoe: 8,
        bottle: 12,
        stone: 15,
        banana: 2,
        apple: 5
    };
    
    return shakeMap[projectileType] || 6;
}

/**
 * Darken color by factor
 */
darkenColor(color, factor) {
    if (color.startsWith('#')) {
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        
        return `rgb(${Math.floor(r * (1 - factor))}, ${Math.floor(g * (1 - factor))}, ${Math.floor(b * (1 - factor))})`;
    }
    return color;
}

    /**
 * Draw particles
 */
drawParticles() {
    // MOBILE: Skip all particle effects
    if (this.isMobile) {
        return;
    }

    this.drawTrailParticles();
    
    this.particles.forEach(particle => {
        this.ctx.save();
        this.ctx.globalAlpha = particle.alpha || (particle.life / 2.0);
        
        // ENHANCEMENTS:
        
        // Add glow effect for sparkle particles
        if (particle.sparkle || particle.type === 'sparkle') {
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = particle.twinkle ? 15 : 8;
        }
        
        this.ctx.fillStyle = particle.color;
        
        // Handle rotation for debris particles
        if (particle.rotation && particle.type === 'debris') {
            this.ctx.translate(particle.x, particle.y);
            this.ctx.rotate(particle.rotation);
            this.ctx.fillRect(-particle.size/2, -particle.size/2, particle.size, particle.size);
        } else {
            // Existing circle drawing
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        this.ctx.restore();
    });
}

    /**
     * Draw trail particles
     */
    drawTrailParticles() {
         // MOBILE: Skip trail particles
    if (this.isMobile) {
        return;
    }
    
        this.trailParticles.forEach(particle => {
            this.ctx.save();
            this.ctx.globalAlpha = particle.alpha;
            this.ctx.fillStyle = particle.color;
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = 8;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        });
    }

    /**
     * Draw visual effects
     */
    drawEffects() {
        // MOBILE: Skip all screen effects
    if (this.isMobile) {
        return;
    }
        // Slow motion effect
        if (this.activePowers.slowmo > 0) {
            this.ctx.save();
            this.ctx.globalAlpha = 0.3;
            this.ctx.fillStyle = '#4169E1';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.restore();
        }
        
        // Screen flash for hits
        if (this.cameraShake.intensity > 10) {
            this.ctx.save();
            this.ctx.globalAlpha = 0.2;
            this.ctx.fillStyle = '#FF0000';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.restore();
        }
    }
    /**
 * Set politician reaction based on projectile type
 */
setReactionForProjectile(projectileType) {
    const reactions = {
        tomato: { state: 'shocked', duration: 1500 },
        egg: { state: 'hit', duration: 1200 },
        shoe: { state: 'ducking', duration: 1800 },
        bottle: { state: 'hit', duration: 2000 },
        stone: { state: 'shocked', duration: 2500 },
        banana: { state: 'shocked', duration: 800 },
        apple: { state: 'hit', duration: 1000 }
    };
    
    const reaction = reactions[projectileType] || { state: 'hit', duration: 1000 };
    this.politician.reactionState = reaction.state;
    this.politician.reactionTimer = reaction.duration;
    
    console.log(`Politician reaction: ${reaction.state} for ${reaction.duration}ms`);
}
/**
 * Add stain to politician when hit
 */
addStainToPolitician(projectile) {
    // Calculate stain position relative to politician hitbox
    const hitX = projectile.x - this.politician.hitbox.x;
    const hitY = projectile.y - this.politician.hitbox.y;
    
   // Projectile-specific stain properties with natural colors
    const stainProperties = {
    tomato: { 
        size: 8, 
        type: 'splatter-drip',
        opacity: 0.85, 
        color: '#D22B2B'
    },
    egg: { 
        size: 10, 
        type: 'drip-drop',
        opacity: 0.9, 
        color: '#FFD700'
    },
    shoe: { 
        size: 7, 
        type: 'smudge-streak',
        opacity: 0.65, 
        color: '#4B3621'
    },
    bottle: { 
        size: 8, 
        type: 'splatter-ring',
        opacity: 0.7, 
        color: '#556B2F'
    },
    stone: { 
        size: 6, 
        type: 'smudge-blotch',
        opacity: 0.55, 
        color: '#2F4F4F'
    },
    banana: { 
        size: 9, 
        type: 'smudge-drip',
        opacity: 0.75, 
        color: '#DAA520'
    },
    apple: { 
        size: 7, 
        type: 'splatter-smudge',
        opacity: 0.8, 
        color: '#B22222'
    }
};
    
    const props = stainProperties[projectile.type] || { size: 10, type: 'splatter', opacity: 0.7, color: '#8B4513' };
    
    // Create stain spots
    const stainCount = projectile.type === 'tomato' || projectile.type === 'egg' ? 3 : 1;

for (let i = 0; i < stainCount; i++) {
    const baseX = hitX + (Math.random() - 0.5) * 20;
    const baseY = hitY + (Math.random() - 0.5) * 15;
    
    // Restrict to torso area only (center chest area)
    const torsoStartX = this.politician.hitbox.width * 0.2;   // 20% from left edge
    const torsoEndX = this.politician.hitbox.width * 0.8;     // 80% from left edge
    const clampedX = Math.max(torsoStartX, Math.min(torsoEndX, baseX));
    
    const torsoStartY = this.politician.hitbox.height * 0.1;  // 10% from top
    const torsoEndY = this.politician.hitbox.height * 0.4;    // 40% from top (upper torso only)
    const clampedY = Math.max(torsoStartY, Math.min(torsoEndY, baseY));
    
    const stain = {
        x: clampedX,
        y: clampedY,
        size: props.size + Math.random() * 3,
        color: props.color,
        type: props.type,
        opacity: props.opacity,
        age: 0
    };
    
    this.politician.stains.push(stain);
    console.log(`Added ${projectile.type} stain at (${stain.x}, ${stain.y})`);
}

// Limit total stains
if (this.politician.stains.length > 15) {
    this.politician.stains.splice(0, this.politician.stains.length - 15);
}
}

/**
 * Draw stains on politician
 */
drawPoliticianStains(politician) {
    this.ctx.save();
    
    politician.stains.forEach(stain => {
        // Add bounds validation
        const stainX = politician.hitbox.x + stain.x;
        const stainY = politician.hitbox.y + stain.y;

        // Skip stain if outside hitbox bounds
        if (stainX < politician.hitbox.x || 
            stainX > politician.hitbox.x + politician.hitbox.width ||
            stainY < politician.hitbox.y || 
            stainY > politician.hitbox.y + politician.hitbox.height) {
            return;
        }

        // Stain integration
        this.ctx.globalAlpha = stain.opacity;
        this.ctx.fillStyle = stain.color;
        
        const centerX = politician.hitbox.x + stain.x;
        const centerY = politician.hitbox.y + stain.y;

       
       // Updated switch with working methods
        switch(stain.type) {
             case 'splatter-drip':
                  this.drawSplatterDrip(centerX, centerY, stain.size);
             break;
        case 'drip-drop':
        case 'smudge-streak':
        case 'splatter-ring':
        case 'smudge-blotch':
        case 'smudge-drip':
        case 'splatter-smudge':
        case 'splatter':
        case 'drip':
        case 'smudge':
        default:
           this.drawRandomBlob(centerX, centerY, stain.size);
       }

        // WORKING FALLBACK - Simple irregular stain
        this.ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const radius = stain.size * (0.6 + Math.random() * 0.4);
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.closePath();
        this.ctx.fill();
        
        // Dark edge for depth
        this.ctx.globalAlpha = stain.opacity;
        this.ctx.strokeStyle = this.darkenColor(stain.color, 0.4);
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
    });
    
    this.ctx.restore();
}
drawRandomBlob(x, y, size) {
    this.ctx.beginPath();
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const radius = size * (0.4 + Math.random() * 0.4);
        const px = x + Math.cos(angle) * radius;
        const py = y + Math.sin(angle) * radius;
        if (i === 0) this.ctx.moveTo(px, py);
        else this.ctx.lineTo(px, py);
    }
    this.ctx.closePath();
    this.ctx.fill();
}
drawSplatterDrip(x, y, size) {
    // Central burst
    this.ctx.beginPath();
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const radius = size * (0.3 + Math.random() * 0.4);
        const px = x + Math.cos(angle) * radius;
        const py = y + Math.sin(angle) * radius;
        if (i === 0) this.ctx.moveTo(px, py);
        else this.ctx.lineTo(px, py);
    }
    this.ctx.closePath();
    this.ctx.fill();
    
    // Downward drips
    for (let i = 0; i < 2; i++) {
        const dripX = x + (Math.random() - 0.5) * size;
        const dripLength = size * (1.2 + Math.random() * 1);
        this.ctx.beginPath();
        this.ctx.ellipse(dripX, y + dripLength/2, size * 0.12, dripLength/2, 0, 0, Math.PI * 2);
        this.ctx.fill();
    }
}

    /**
     * Open Blinkit product page
     */
    openBlinkit() {
        const utmParams = new URLSearchParams({
            utm_source: 'stain_slayer_game',
            utm_medium: 'mobile_game',
            utm_campaign: 'fab_detergent_2025',
            utm_content: 'game_cta_button',
            utm_term: 'godrej_fab_purchase'
        });
        
        const blinkitUrl = `https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061?${utmParams.toString()}`;
        window.open(blinkitUrl, '_blank');
    }

    /**
     * Create trail particle
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} vx - X velocity
     * @param {number} vy - Y velocity
     */
   createTrailParticle(x, y, vx, vy) {
      // MOBILE: Skip ALL trail particle creation
    if (this.isMobile) return;

    
    const particle = {
        x: x,
        y: y,
        vx: vx * 0.3 + (Math.random() - 0.5) * 50,
        vy: vy * 0.3 + (Math.random() - 0.5) * 50,
        life: this.isMobile ? 0.3 : 0.8,        // Much shorter life on mobile
        maxLife: this.isMobile ? 0.3 : 0.8,
        size: this.isMobile ? 1 + Math.random() * 0.5 : 2 + Math.random() * 2, // Smaller particles
        alpha: 1.0,
        color: `hsl(${180 + Math.random() * 40}, 80%, ${60 + Math.random() * 20}%)`
    };
    
    this.trailParticles.push(particle);
    
    // Aggressive cleanup for mobile
    const maxParticles = this.mobileOptimizations ? this.mobileOptimizations.maxTrailParticles : 10;
    if (this.trailParticles.length > maxParticles) {
        this.trailParticles.splice(0, this.trailParticles.length - maxParticles);
    }
}

    // SPRITE SYSTEM METHODS

    /**
     * Initialize sprite system
     */
   initSpriteSystem() {
    // Define sprite configs based on device type
    if (this.isMobile) {
        // Mobile: Simplified sprite configuration
        this.spriteConfigs = {
            politician: {
                src: 'https://assets.codepen.io/t-24779/politics-sprite-sheet-v2.png',
                frameWidth: 768,     // Half resolution
                frameHeight: 1024,   // Keep height for aspect ratio
                totalFrames: 1,      // Use only first frame
                layout: 'horizontal',
                scale: 0.6           // Scale down for mobile
            },
            aide: {
                src: 'https://assets.codepen.io/t-24779/aide-sprite-sheet-v2.png',
                frameWidth: 384,     // Keep original width (already smaller)
                frameHeight: 600,    // Use only upper portion
                totalFrames: 1,      // Single frame only
                layout: 'vertical',
                scale: 0.7           // Scale down for mobile
            }
        };

        this.currentAnimations = {
            politician: { name: 'idle', frame: 0, timer: 0 },
            aide: { name: 'idle', frame: 0, timer: 0 }
        };

        console.log('Mobile sprite system initialized with optimizations');
    } else {
        // Desktop: Full sprite configuration (your existing config)
        this.spriteConfigs = {
            politician: {
                src: 'https://assets.codepen.io/t-24779/politics-sprite-sheet-v2.png',
                frameWidth: 768,
                frameHeight: 1024,
                totalFrames: 2,
                layout: 'horizontal'
            },
            aide: {
                src: 'https://assets.codepen.io/t-24779/aide-sprite-sheet-v2.png',
                frameWidth: 384,
                frameHeight: 1024,
                totalFrames: 4,
                layout: 'vertical'
            }
        };

        this.currentAnimations = {
            politician: { name: 'idle', frame: 0, timer: 0 },
            aide: { name: 'idle', frame: 0, timer: 0 }
        };

        console.log('Desktop sprite system initialized with full features');
    }

    this.spriteSystem = {
        loaded: false,
        images: {},
        animations: {},
        currentFrames: { politician: 0, aide: 0 }
    };

    this.loadSprites();
}

    /**
     * Load sprite images
     */
    loadSprites() {
        let loadedCount = 0;
        const totalSprites = Object.keys(this.spriteConfigs).length;

        Object.entries(this.spriteConfigs).forEach(([name, config]) => {
            const img = new Image();
            img.onload = () => {
                loadedCount++;
                this.debugLog('info', `Sprite loaded: ${name} (${img.width}x${img.height})`);
                if (loadedCount === totalSprites) {
                    this.spriteSystem.loaded = true;
                    this.debugLog('info', 'All sprites loaded successfully');
                    this.initializeCharacterAnimations();
                }
            };
            img.onerror = () => {
                this.debugLog('error', `Failed to load sprite: ${name} from ${config.src}`);
            };
            img.src = config.src;
            this.spriteSystem.images[name] = img;
        });
    }

    /**
     * Draw character sprite
     * @param {string} spriteName - Sprite name
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width
     * @param {number} height - Height
     * @param {string} animation - Animation name
     * @returns {boolean} Success status
     */
   drawCharacterSprite(spriteName, x, y, width, height, animation = 'idle') {
    const image = this.spriteSystem.images[spriteName];
    const config = this.spriteConfigs[spriteName];
    
    if (!image || !config) {
        return false;
    }

    // Mobile: Use only first frame, no animation
    let frameIndex = 0;
    if (!this.isMobile && this.spriteSystem.animations[spriteName]) {
        const animationFrames = this.spriteSystem.animations[spriteName][animation] || 
                               this.spriteSystem.animations[spriteName]['idle'];
        if (animationFrames && animationFrames.length > 0) {
            const currentFrame = this.spriteSystem.currentFrames[spriteName] || 0;
            frameIndex = currentFrame % animationFrames.length;
        }
    }

    // Calculate frame position
    const frameWidth = config.frameWidth;
    const frameHeight = config.frameHeight;
    
    let frameX = 0;
    let frameY = 0;
    
    if (config.layout === 'horizontal') {
        frameX = frameIndex * frameWidth;
        frameY = 0;
    } else if (config.layout === 'vertical') {
        frameX = 0;
        frameY = frameIndex * frameHeight;
    }

    // Apply mobile scaling
    const renderWidth = this.isMobile ? width * (config.scale || 0.7) : width;
    const renderHeight = this.isMobile ? height * (config.scale || 0.7) : height;

    this.ctx.save();
    
    try {
        // Handle sprite flipping for aide
        if (spriteName === 'aide' && this.aide.spriteFlipped) {
            this.ctx.translate(x + renderWidth, y);
            this.ctx.scale(-1, 1);
            this.ctx.drawImage(
                image,
                frameX, frameY, frameWidth, frameHeight,
                0, 0, renderWidth, renderHeight
            );
        } else {
            this.ctx.drawImage(
                image,
                frameX, frameY, frameWidth, frameHeight,
                x, y, renderWidth, renderHeight
            );
        }
        
        this.ctx.restore();
        return true;
        
    } catch (error) {
        console.warn(`Sprite rendering error for ${spriteName}:`, error);
        this.ctx.restore();
        return false;
    }
}

    /**
     * Extract sprite frames from image
     * @param {string} imageName - Image name
     * @param {number} frameWidth - Frame width
     * @param {number} frameHeight - Frame height
     * @param {number} totalFrames - Total frames
     * @param {string} layout - Layout type
     * @returns {Array} Frame array
     */
    extractSpriteFrames(imageName, frameWidth, frameHeight, totalFrames, layout = 'horizontal') {
    const image = this.spriteSystem.images[imageName];
    if (!image) return [];
    
    const frames = [];
    
    // Mobile: Extract only first frame
    if (this.isMobile) {
        frames.push({
            x: 0,
            y: 0,
            width: frameWidth,
            height: frameHeight
        });
        return frames;
    }
    
    // Desktop: Extract all frames (your existing logic)
    if (layout === 'horizontal') {
        for (let i = 0; i < totalFrames; i++) {
            frames.push({
                x: i * frameWidth,
                y: 0,
                width: frameWidth,
                height: frameHeight
            });
        }
    } else if (layout === 'vertical') {
        for (let i = 0; i < totalFrames; i++) {
            frames.push({
                x: 0,
                y: i * frameHeight,
                width: frameWidth,
                height: frameHeight
            });
        }
    }
    
    return frames;
}

    /**
     * Initialize character animations
     */
    initializeCharacterAnimations() {
        if (!this.spriteSystem.loaded) return;
        
        const politicianConfig = this.spriteConfigs.politician;
        const politicianFrames = this.extractSpriteFrames(
            'politician', 
            politicianConfig.frameWidth,
            politicianConfig.frameHeight,
            politicianConfig.totalFrames, 
            politicianConfig.layout
        );
        
        this.spriteSystem.animations.politician = {
            idle: politicianFrames,
            excited: politicianFrames,
            dodge: politicianFrames,
            panicked: politicianFrames,
            critical: politicianFrames
        };
        
        const aideFrames = this.extractSpriteFrames(
            'aide', 512, 600, 4, 'vertical'
        );
        
        this.spriteSystem.animations.aide = {
            idle: aideFrames,
            shield_side: aideFrames,
            shield_up: aideFrames,
            crouch_cover: aideFrames,
            swat_down: aideFrames,
            worried: aideFrames,
            focused: aideFrames,
            walking: aideFrames,
            victory: aideFrames
        };
        
        this.spriteSystem.currentFrames = {
            politician: 0,
            aide: 0
        };
    }

    /**
     * Update character animations
     * @param {number} deltaTime - Time delta
     */
    updateCharacterAnimations(deltaTime = 0.016) {
    // Mobile: Skip complex animations
    if (this.isMobile) {
        // Keep frame counters at 0 for single frame sprites
        this.spriteSystem.currentFrames = {
            politician: 0,
            aide: 0
        };
        
        // Simplified expressions without animation
        if (this.aide.shield) {
            this.aide.expression = 'focused';
        } else {
            this.aide.expression = 'determined';
        }
        
        if (this.politicianHealth < 50) {
            this.politician.expression = 'worried';
        } else {
            this.politician.expression = 'speaking';
        }
        
        return;
    }
    
    // Desktop: Full animation system (your existing code)
    if (!this.characterAnimTimers) {
        this.characterAnimTimers = {
            politician: 0,
            aide: 0
        };
    }
    
    this.characterAnimTimers.politician += deltaTime;
    if (this.characterAnimTimers.politician >= 0.4) {
        this.spriteSystem.currentFrames.politician = 
            (this.spriteSystem.currentFrames.politician + 1) % 2;
        this.characterAnimTimers.politician = 0;
    }
    
    this.characterAnimTimers.aide += deltaTime;
    if (this.characterAnimTimers.aide >= 0.2) {
        this.spriteSystem.currentFrames.aide = 
            (this.spriteSystem.currentFrames.aide + 1) % 4;
        this.characterAnimTimers.aide = 0;
    }
    
        this.aide.armAnimation += deltaTime * 3;
        this.politician.armAnimation += deltaTime * 2;
        
        if (this.aide.shield) {
            this.aide.expression = 'focused';
        } else if (this.projectiles.length > 3) {
            this.aide.expression = 'worried';
        } else {
            this.aide.expression = 'determined';
        }
        
        if (this.politicianHealth < 50) {
            this.politician.expression = 'worried';
        } else {
            this.politician.expression = 'speaking';
        }
    }

    /**
     * Set character animation
     * @param {string} character - Character name
     * @param {string} animationName - Animation name
     */
    setCharacterAnimation(character, animationName) {
        const currentAnim = this.currentAnimations[character];
        if (currentAnim && currentAnim.name !== animationName) {
            currentAnim.name = animationName;
            currentAnim.frame = 0;
            currentAnim.timer = 0;
        }
    }

    /**
     * Optimize rendering performance
     * @returns {boolean} Should render this frame
     */
    optimizeRenderingPerformance() {
        const now = performance.now();
        if (now - this.lastFrameTime < 16.67) return false;
        this.lastFrameTime = now;
        return true;
    }
}

// Add this debug function before the Product3DViewer class
function debug3DViewer(action, details = '') {
    console.log(`[3D DEBUG] ${new Date().toISOString().substr(11, 12)} - ${action} - ${details}`);
}

/**
 * 3D Product Viewer for Fab refill pack - Front & Back views only
 */
class Product3DViewer {
    constructor(canvasId, containerId) {
        debug3DViewer('CONSTRUCTOR_START', `canvasId: ${canvasId}, containerId: ${containerId}`);
        
        if (typeof THREE === 'undefined') {
            debug3DViewer('ERROR', 'THREE.js is not available');
            console.error('THREE.js is not available');
            return;
        }
        
        this.canvas = document.getElementById(canvasId);
        this.container = document.getElementById(containerId);
        
        debug3DViewer('ELEMENT_CHECK', `canvas: ${!!this.canvas}, container: ${!!this.container}`);
        
        if (!this.canvas) {
            debug3DViewer('ERROR', `Canvas element '${canvasId}' not found in DOM`);
            console.error(`3D viewer canvas or container not found - Canvas '${canvasId}' missing`);
            return;
        }
        
        if (!this.container) {
            debug3DViewer('ERROR', `Container element '${containerId}' not found in DOM`);
            console.error(`3D viewer canvas or container not found - Container '${containerId}' missing`);
            return;
        }
        
        // Check if elements are attached to DOM
        if (!document.body.contains(this.canvas)) {
            debug3DViewer('ERROR', 'Canvas element not attached to DOM');
            console.error('3D viewer canvas or container not found - Canvas not attached to DOM');
            return;
        }
        
        if (!document.body.contains(this.container)) {
            debug3DViewer('ERROR', 'Container element not attached to DOM');
            console.error('3D viewer canvas or container not found - Container not attached to DOM');
            return;
        }
        
        // Check visibility
        const containerRect = this.container.getBoundingClientRect();
        debug3DViewer('DIMENSIONS', `width: ${containerRect.width}, height: ${containerRect.height}`);
        
        if (containerRect.width === 0 || containerRect.height === 0) {
            debug3DViewer('ERROR', 'Container has zero dimensions');
            console.error('3D viewer canvas or container not found - Container has zero dimensions');
            return;
        }
        
        debug3DViewer('SUCCESS', 'All validation checks passed, proceeding with initialization');
        
        // Rest of your existing constructor code...
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.productPlane = null;
        this.isMouseDown = false;
        this.mouseX = 0;
        this.rotationY = 0;
        this.targetRotationY = 0;
        this.frontTexture = null;
        this.backTexture = null;
        this.texturesLoaded = false;
        
        this.loadTextures().then(() => {
            this.init();
        });
    }
    
    async loadTextures() {
        const textureLoader = new THREE.TextureLoader();
        
        try {
            const [front, back] = await Promise.all([
                this.loadSingleTexture(textureLoader, 'https://assets.codepen.io/t-24779/fab-front-view-image.png'),
                this.loadSingleTexture(textureLoader, 'https://assets.codepen.io/t-24779/fab-back-side-view.png')
            ]);
            
            this.frontTexture = front;
            this.backTexture = back;
            this.texturesLoaded = true;
            console.log('Front and back textures loaded successfully');
        } catch (error) {
            console.warn('Failed to load textures:', error);
            this.texturesLoaded = false;
        }
    }
    
    loadSingleTexture(loader, url) {
        return new Promise((resolve, reject) => {
            loader.load(
                url,
                (texture) => {
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    resolve(texture);
                },
                undefined,
                reject
            );
        });
    }
    
    init() {
        this.setupScene();
        this.createProduct();
        this.setupLighting();
        this.setupControls();
        this.animate();
        
        console.log('3D Product Viewer initialized - Front & Back only');
    }
    
    setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = null;
        
        this.camera = new THREE.PerspectiveCamera(
            50, 
            this.container.offsetWidth / this.container.offsetHeight, 
            0.1, 
            1000
        );
        this.camera.position.set(0, 0, 4);
        
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true,
            alpha: true
        });
        this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
    }
    
    createProduct() {
        if (!this.texturesLoaded) {
            console.warn('Textures not loaded, using fallback');
            this.createFallbackProduct();
            return;
        }
        
        // Create geometry for the product plane
        const planeGeometry = new THREE.PlaneGeometry(2.5, 3.2);
        
        // Create shader material that switches between textures based on viewing angle
        const material = new THREE.ShaderMaterial({
            uniforms: {
                frontTexture: { value: this.frontTexture },
                backTexture: { value: this.backTexture },
                cameraPosition: { value: this.camera.position }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vViewDirection;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewDirection = normalize(-modelViewPosition.xyz);
                    gl_Position = projectionMatrix * modelViewPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D frontTexture;
                uniform sampler2D backTexture;
                varying vec3 vNormal;
                varying vec3 vViewDirection;
                
                void main() {
                    vec2 uv = gl_PointCoord;
                    
                    // Use UV coordinates from vertex shader
                    uv = vec2(gl_FragCoord.x / 1024.0, gl_FragCoord.y / 1024.0);
                    
                    // Determine which texture to use based on normal direction
                    float facing = dot(vNormal, vViewDirection);
                    
                    vec4 frontColor = texture2D(frontTexture, uv);
                    vec4 backColor = texture2D(backTexture, uv);
                    
                    // Blend between front and back based on viewing angle
                    gl_FragColor = mix(backColor, frontColor, smoothstep(-0.1, 0.1, facing));
                }
            `,
            side: THREE.DoubleSide,
            transparent: true
        });
        
        // Fallback to simpler approach if shaders are complex
        this.createSimpleDoubleSided();
    }
    
    createSimpleDoubleSided() {
        const planeGeometry = new THREE.PlaneGeometry(2.5, 3.2);
        
        // Create a group to hold front and back planes
        this.productPlane = new THREE.Group();
        
        // Front plane
        const frontMaterial = new THREE.MeshBasicMaterial({
            map: this.frontTexture,
            transparent: true,
            side: THREE.FrontSide
        });
        
        const frontPlane = new THREE.Mesh(planeGeometry, frontMaterial);
        frontPlane.position.z = 0.001; // Slight offset to prevent z-fighting
        this.productPlane.add(frontPlane);
        
        // Back plane
        const backMaterial = new THREE.MeshBasicMaterial({
            map: this.backTexture,
            transparent: true,
            side: THREE.BackSide
        });
        
        const backPlane = new THREE.Mesh(planeGeometry, backMaterial);
        backPlane.position.z = -0.001; // Slight offset to prevent z-fighting
        backPlane.scale.x = -1; 
        this.productPlane.add(backPlane);
        
        this.scene.add(this.productPlane);
    }
    
    createFallbackProduct() {
        const planeGeometry = new THREE.PlaneGeometry(2.5, 3.2);
        
        const frontMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00A859, 
            transparent: true, 
            opacity: 0.8 
        });
        
        this.productPlane = new THREE.Mesh(planeGeometry, frontMaterial);
        this.scene.add(this.productPlane);
    }
    
    setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(1, 1, 1);
        this.scene.add(directionalLight);
    }
    
    setupControls() {
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.onMouseUp());
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
        
        this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
        this.canvas.addEventListener('touchend', () => this.onTouchEnd());
        
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        window.addEventListener('resize', () => this.onResize());
    }
    
    onMouseDown(event) {
        this.isMouseDown = true;
        this.mouseX = event.clientX;
    }
    
    onMouseMove(event) {
        if (!this.isMouseDown) return;
        
        const deltaX = event.clientX - this.mouseX;
        const deltaY = event.clientY - this.mouseY;
        this.targetRotationY += deltaX * 0.08;
       
     if (!this.targetRotationX) this.targetRotationX = 0;
        this.targetRotationX += deltaY * 0.01;
        this.targetRotationX = Math.max(-Math.PI/6, Math.min(Math.PI/6, this.targetRotationX));
    
        this.mouseX = event.clientX;
        this.mouseY = event.clientY; 
    }
    
    onMouseUp() {
        this.isMouseDown = false;
    }
    
    onTouchStart(event) {
        event.preventDefault();
        if (event.touches.length === 1) {
            this.isMouseDown = true;
            this.mouseX = event.touches[0].clientX;
        }
    }
    
    onTouchMove(event) {
        event.preventDefault();
        if (!this.isMouseDown || event.touches.length !== 1) return;
        
        const deltaX = event.touches[0].clientX - this.mouseX;
        this.targetRotationY += deltaX * 0.02;
        this.mouseX = event.touches[0].clientX;
    }
    
    onTouchEnd() {
        this.isMouseDown = false;
    }
    
    onWheel(event) {
        event.preventDefault();
        const zoom = event.deltaY * 0.002;
        this.camera.position.z = Math.max(2.5, Math.min(6, this.camera.position.z + zoom));
    }
    
    onResize() {
    if (!this.container) return;
    
    // Get the fixed container dimensions
    const containerWidth = this.container.offsetWidth;
    const containerHeight = this.container.offsetHeight;
    
    this.camera.aspect = containerWidth / containerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(containerWidth, containerHeight);
    
    // Reset any scaling issues with responsive scaling
    if (this.productPlane) {
        const isMobile = containerWidth < 280;
        const scale = isMobile ? 0.8 : 1.0;
        this.productPlane.scale.set(scale, scale, scale);
    }
}
    
   animate() {
    // Check if viewer has been destroyed
    if (!this.renderer || !this.scene || !this.camera) {
        return; // Stop animation loop if destroyed
    }
    
    requestAnimationFrame(() => this.animate());
    
    if (this.productPlane) {
        // Smooth rotation interpolation
        this.rotationY += (this.targetRotationY - this.rotationY) * 0.1;
        this.productPlane.rotation.y = this.rotationY;
        
        // Add vertical rotation support
        if (this.targetRotationX !== undefined) {
            if (!this.rotationX) this.rotationX = 0;
            this.rotationX += (this.targetRotationX - this.rotationX) * 0.1;
            this.productPlane.rotation.x = this.rotationX;
        }
        
        // Gentle idle rotation when not interacting
        if (!this.isMouseDown) {
            this.productPlane.rotation.y += 0.08;
            this.targetRotationY = this.productPlane.rotation.y;
        }
    }
    
    // Error handling for WebGL rendering
    try {
        if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    } catch (error) {
        console.warn('3D viewer render error (non-critical):', error.message);
        // Track error count to prevent infinite error loops
        this.errorCount = (this.errorCount || 0) + 1;
        
        // If too many errors occur, disable the 3D viewer
        if (this.errorCount > 5) { // Reduced threshold
            console.warn('Too many 3D viewer errors, disabling...');
            this.destroy();
            return;
        }
    }
}
    
   destroy() {
    console.log('Destroying 3D Product Viewer...');
    
    // Stop animation loop
    this.isDestroyed = true;
    
    if (this.renderer) {
        this.renderer.dispose();
        this.renderer.domElement.remove();
        this.renderer = null;
    }
    
    if (this.frontTexture) {
        this.frontTexture.dispose();
        this.frontTexture = null;
    }
    
    if (this.backTexture) {
        this.backTexture.dispose();
        this.backTexture = null;
    }
    
    if (this.scene) {
        this.scene.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(material => material.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
        this.scene = null;
    }
    
    this.camera = null;
    this.productPlane = null;
    this.container = null;
    this.canvas = null;
}
}

/**
 * Stain Slayer Game Analytics System
 */
class StainSlayerAnalytics {
    constructor(gameInstance) {
        this.game = gameInstance;
        this.sessionData = this.initializeSession();
        this.performanceMetrics = this.initializePerformanceTracking();
        this.projectileAnalytics = [];
        this.reactionTimeData = [];
        this.defensePatterns = [];
        this.streakAnalytics = {
            currentStreak: 0,
            bestStreak: 0,
            streakHistory: []
        };
        
        console.log("ðŸ“Š Stain Slayer Analytics initialized");
    }

    initializeSession() {
        return {
            sessionId: this.generateSessionId(),
            gameStartTime: Date.now(),
            playerActions: [],
            waveProgression: [],
            healthEvents: [],
            powerUpUsage: {
                shield: { used: 0, effectiveness: [] },
                slowmo: { used: 0, effectiveness: [] },
                speed: { used: 0, effectiveness: [] }
            }
        };
    }

    initializePerformanceTracking() {
        return {
            frameRateHistory: [],
            inputLatency: [],
            renderingPerformance: {
                particleCount: [],
                projectileCount: [],
                frameDrops: 0
            }
        };
    }

    generateSessionId() {
        return `SS_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    // Track projectile spawn and lifecycle
    trackProjectileSpawn(projectile) {
        const projectileData = {
            id: `proj_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            type: projectile.type,
            spawnTime: Date.now(),
            spawnPosition: { x: projectile.x, y: projectile.y },
            threatLevel: projectile.threatLevel,
            damage: projectile.damage,
            size: projectile.size,
            outcome: null, // Will be set when resolved
            reactionTime: null,
            defenseMethod: null
        };

        this.projectileAnalytics.push(projectileData);
        return projectileData.id;
    }

    // Track projectile defense/hit resolution
    trackProjectileResolution(projectileId, outcome, defenseMethod = null) {
        const projectileData = this.projectileAnalytics.find(p => p.id === projectileId);
        if (!projectileData) return;

        const resolutionTime = Date.now();
        const reactionTime = resolutionTime - projectileData.spawnTime;

        projectileData.outcome = outcome; // 'blocked', 'hit_politician', 'missed'
        projectileData.reactionTime = reactionTime;
        projectileData.defenseMethod = defenseMethod;

        // Update streak tracking
        if (outcome === 'blocked') {
            this.streakAnalytics.currentStreak++;
            this.streakAnalytics.bestStreak = Math.max(
                this.streakAnalytics.bestStreak, 
                this.streakAnalytics.currentStreak
            );
        } else if (outcome === 'hit_politician') {
            if (this.streakAnalytics.currentStreak > 0) {
                this.streakAnalytics.streakHistory.push(this.streakAnalytics.currentStreak);
            }
            this.streakAnalytics.currentStreak = 0;
        }

        // Record reaction time for performance analysis
        this.reactionTimeData.push({
            time: reactionTime,
            projectileType: projectileData.type,
            threatLevel: projectileData.threatLevel,
            outcome: outcome
        });
    }

    // Track player movement and positioning
    trackPlayerMovement(aidePosition, timestamp = Date.now()) {
        this.defensePatterns.push({
            timestamp: timestamp,
            position: { x: aidePosition.x, y: aidePosition.y },
            facing: aidePosition.facingDirection,
            activeShield: aidePosition.shield,
            expression: aidePosition.expression
        });

        // Keep only last 100 movement records to manage memory
        if (this.defensePatterns.length > 100) {
            this.defensePatterns.shift();
        }
    }

    // Track power-up usage and effectiveness
    trackPowerUpUsage(powerType, effectivenessScore = null) {
        const usage = this.sessionData.powerUpUsage[powerType];
        if (usage) {
            usage.used++;
            if (effectivenessScore !== null) {
                usage.effectiveness.push({
                    timestamp: Date.now(),
                    score: effectivenessScore,
                    gameContext: {
                        activeProjectiles: this.game.projectiles.length,
                        politicianHealth: this.game.politicianHealth,
                        currentWave: this.game.wave,
                        currentLevel: this.game.level
                    }
                });
            }
        }
    }

    // Track health events (damage taken, close calls)
    trackHealthEvent(eventType, damage = 0, projectileType = null) {
        this.sessionData.healthEvents.push({
            timestamp: Date.now(),
            eventType: eventType, // 'damage_taken', 'close_call', 'critical_health'
            damage: damage,
            projectileType: projectileType,
            healthBefore: this.game.politicianHealth + damage,
            healthAfter: this.game.politicianHealth,
            gameContext: {
                wave: this.game.wave,
                level: this.game.level,
                activeProjectiles: this.game.projectiles.length
            }
        });
    }

    // Track wave progression and difficulty scaling
    trackWaveCompletion(waveNumber, levelNumber, performance) {
        this.sessionData.waveProgression.push({
            wave: waveNumber,
            level: levelNumber,
            completionTime: Date.now(),
            performance: {
                projectilesBlocked: performance.blocked || 0,
                projectilesMissed: performance.missed || 0,
                healthRemaining: this.game.politicianHealth,
                scoreGained: performance.scoreGained || 0,
                accuracyRate: performance.accuracy || 0
            },
            difficultyMetrics: {
                spawnRate: this.game.projectileSpawnRate,
                projectileSpeed: performance.avgProjectileSpeed || 0,
                threatDistribution: performance.threatLevels || {}
            }
        });
    }

    // Performance monitoring
    trackPerformanceMetrics(frameRate, inputLatency) {
        this.performanceMetrics.frameRateHistory.push({
            timestamp: Date.now(),
            fps: frameRate
        });

        if (inputLatency) {
            this.performanceMetrics.inputLatency.push(inputLatency);
        }

        // Track rendering load
        this.performanceMetrics.renderingPerformance.particleCount.push(
            this.game.particles.length + this.game.trailParticles.length
        );
        this.performanceMetrics.renderingPerformance.projectileCount.push(
            this.game.projectiles.length
        );

        // Detect frame drops
        if (frameRate < 45) {
            this.performanceMetrics.renderingPerformance.frameDrops++;
        }

        // Keep performance history manageable
        const maxHistory = 300; // ~5 minutes at 60fps
        if (this.performanceMetrics.frameRateHistory.length > maxHistory) {
            this.performanceMetrics.frameRateHistory.shift();
        }
    }

    // Calculate comprehensive analytics
    calculateSessionAnalytics() {
        const sessionDuration = Date.now() - this.sessionData.gameStartTime;
        const totalProjectiles = this.projectileAnalytics.length;
        const blockedProjectiles = this.projectileAnalytics.filter(p => p.outcome === 'blocked').length;
        const hitProjectiles = this.projectileAnalytics.filter(p => p.outcome === 'hit_politician').length;

        return {
            session: {
                sessionId: this.sessionData.sessionId,
                duration: sessionDuration,
                gameEndTime: new Date().toISOString(),
                finalScore: this.game.score,
                finalLevel: this.game.level,
                finalWave: this.game.wave,
                survivedWaves: this.game.survivedWaves
            },
            
            combat: {
                totalProjectiles: totalProjectiles,
                projectilesBlocked: blockedProjectiles,
                projectilesHit: hitProjectiles,
                accuracy: totalProjectiles > 0 ? (blockedProjectiles / totalProjectiles * 100).toFixed(1) : 0,
                bestDefenseStreak: this.streakAnalytics.bestStreak,
                averageReactionTime: this.calculateAverageReactionTime(),
                defenseEfficiency: this.calculateDefenseEfficiency()
            },

            health: {
                finalHealth: this.game.politicianHealth,
                healthLost: 100 - this.game.politicianHealth,
                damageEvents: this.sessionData.healthEvents.filter(e => e.eventType === 'damage_taken').length,
                closeCalls: this.sessionData.healthEvents.filter(e => e.eventType === 'close_call').length,
                criticalMoments: this.sessionData.healthEvents.filter(e => e.eventType === 'critical_health').length
            },

            powerUps: {
                shieldUsage: this.sessionData.powerUpUsage.shield.used,
                slowmoUsage: this.sessionData.powerUpUsage.slowmo.used,
                speedUsage: this.sessionData.powerUpUsage.speed.used,
                overallEffectiveness: this.calculatePowerUpEffectiveness()
            },

            projectileBreakdown: this.analyzeProjectileTypes(),
            
            performance: {
                averageFPS: this.calculateAverageFPS(),
                frameDrops: this.performanceMetrics.renderingPerformance.frameDrops,
                averageInputLatency: this.calculateAverageInputLatency(),
                peakComplexity: this.calculatePeakComplexity()
            },

            gameplayPatterns: {
                favoriteDefensePosition: this.calculateFavoritePosition(),
                movementStyle: this.analyzeMovementStyle(),
                threatPrioritization: this.analyzeThreatPrioritization()
            }
        };
    }

    // Helper calculation methods
    calculateAverageReactionTime() {
        if (this.reactionTimeData.length === 0) return 0;
        const sum = this.reactionTimeData.reduce((acc, data) => acc + data.time, 0);
        return Math.round(sum / this.reactionTimeData.length);
    }

    calculateDefenseEfficiency() {
        const shieldBlocks = this.projectileAnalytics.filter(p => 
            p.outcome === 'blocked' && p.defenseMethod === 'shield'
        ).length;
        
        const totalShieldUse = this.sessionData.powerUpUsage.shield.used;
        
        return totalShieldUse > 0 ? (shieldBlocks / totalShieldUse).toFixed(2) : 0;
    }

    calculatePowerUpEffectiveness() {
        const allEffectiveness = [];
        Object.values(this.sessionData.powerUpUsage).forEach(powerUp => {
            powerUp.effectiveness.forEach(eff => allEffectiveness.push(eff.score));
        });
        
        if (allEffectiveness.length === 0) return 0;
        const sum = allEffectiveness.reduce((acc, score) => acc + score, 0);
        return (sum / allEffectiveness.length).toFixed(1);
    }

    analyzeProjectileTypes() {
        const typeAnalysis = {};
        this.projectileAnalytics.forEach(proj => {
            if (!typeAnalysis[proj.type]) {
                typeAnalysis[proj.type] = {
                    total: 0,
                    blocked: 0,
                    hit: 0,
                    avgReactionTime: 0,
                    threatLevel: proj.threatLevel
                };
            }
            
            typeAnalysis[proj.type].total++;
            if (proj.outcome === 'blocked') typeAnalysis[proj.type].blocked++;
            if (proj.outcome === 'hit_politician') typeAnalysis[proj.type].hit++;
        });

        // Calculate accuracy for each type
        Object.keys(typeAnalysis).forEach(type => {
            const data = typeAnalysis[type];
            data.accuracy = data.total > 0 ? ((data.blocked / data.total) * 100).toFixed(1) : 0;
            
            // Calculate average reaction time for this type
            const typeReactions = this.reactionTimeData.filter(r => r.projectileType === type);
            if (typeReactions.length > 0) {
                const sum = typeReactions.reduce((acc, r) => acc + r.time, 0);
                data.avgReactionTime = Math.round(sum / typeReactions.length);
            }
        });

        return typeAnalysis;
    }

    calculateAverageFPS() {
        if (this.performanceMetrics.frameRateHistory.length === 0) return 60;
        const sum = this.performanceMetrics.frameRateHistory.reduce((acc, frame) => acc + frame.fps, 0);
        return Math.round(sum / this.performanceMetrics.frameRateHistory.length);
    }

    calculateAverageInputLatency() {
        if (this.performanceMetrics.inputLatency.length === 0) return 0;
        const sum = this.performanceMetrics.inputLatency.reduce((acc, latency) => acc + latency, 0);
        return Math.round(sum / this.performanceMetrics.inputLatency.length);
    }

    calculatePeakComplexity() {
        const maxParticles = Math.max(...this.performanceMetrics.renderingPerformance.particleCount, 0);
        const maxProjectiles = Math.max(...this.performanceMetrics.renderingPerformance.projectileCount, 0);
        return { maxParticles, maxProjectiles };
    }

    calculateFavoritePosition() {
        if (this.defensePatterns.length === 0) return { x: 0, y: 0 };
        
        const sumX = this.defensePatterns.reduce((acc, pattern) => acc + pattern.position.x, 0);
        const sumY = this.defensePatterns.reduce((acc, pattern) => acc + pattern.position.y, 0);
        
        return {
            x: Math.round(sumX / this.defensePatterns.length),
            y: Math.round(sumY / this.defensePatterns.length)
        };
    }

    analyzeMovementStyle() {
        if (this.defensePatterns.length < 10) return 'insufficient_data';
        
        const movements = this.defensePatterns.slice(1).map((pattern, index) => {
            const prev = this.defensePatterns[index];
            return {
                distance: Math.sqrt(
                    Math.pow(pattern.position.x - prev.position.x, 2) + 
                    Math.pow(pattern.position.y - prev.position.y, 2)
                ),
                time: pattern.timestamp - prev.timestamp
            };
        });

        const avgMovement = movements.reduce((acc, move) => acc + move.distance, 0) / movements.length;
        
        if (avgMovement < 5) return 'stationary';
        if (avgMovement < 15) return 'conservative';
        if (avgMovement < 30) return 'active';
        return 'highly_mobile';
    }

    analyzeThreatPrioritization() {
        const threatResponses = this.reactionTimeData.reduce((acc, reaction) => {
            if (!acc[reaction.threatLevel]) {
                acc[reaction.threatLevel] = [];
            }
            acc[reaction.threatLevel].push(reaction.time);
            return acc;
        }, {});

        const prioritization = {};
        Object.keys(threatResponses).forEach(level => {
            const times = threatResponses[level];
            const avgTime = times.reduce((acc, time) => acc + time, 0) / times.length;
            prioritization[level] = Math.round(avgTime);
        });

        return prioritization;
    }

    // Export analytics for external use
    exportAnalytics(format = 'json') {
        const analytics = this.calculateSessionAnalytics();
        
        if (format === 'json') {
            return JSON.stringify(analytics, null, 2);
        } else if (format === 'csv') {
            return this.convertToCSV(analytics);
        }
        
        return analytics;
    }

    convertToCSV(analytics) {
        // Convert key metrics to CSV format
        const csvLines = [
            'Metric,Value',
            `Session Duration,${analytics.session.duration}`,
            `Final Score,${analytics.session.finalScore}`,
            `Accuracy,${analytics.combat.accuracy}%`,
            `Projectiles Blocked,${analytics.combat.projectilesBlocked}`,
            `Best Streak,${analytics.combat.bestDefenseStreak}`,
            `Average Reaction Time,${analytics.combat.averageReactionTime}ms`,
            `Final Health,${analytics.health.finalHealth}`,
            `Shield Usage,${analytics.powerUps.shieldUsage}`,
            `Average FPS,${analytics.performance.averageFPS}`
        ];
        
        return csvLines.join('\n');
    }

    // Reset analytics for new session
    resetAnalytics() {
        this.sessionData = this.initializeSession();
        this.performanceMetrics = this.initializePerformanceTracking();
        this.projectileAnalytics = [];
        this.reactionTimeData = [];
        this.defensePatterns = [];
        this.streakAnalytics = {
            currentStreak: 0,
            bestStreak: 0,
            streakHistory: []
        };
        
        console.log("ðŸ“Š Analytics reset for new session");
    }
}

// GLOBAL UTILITY FUNCTIONS

/**
 * Generate QR code with game score
 */
function generateQRCode() {
    try {
        console.log("ðŸ“± Generating QR code...");
        
        const qrDiv = document.getElementById('qrCode');
        if (!qrDiv || typeof QRious === 'undefined') {
            console.log("âŒ QR code generation failed - missing elements");
            return;
        }
        
        qrDiv.innerHTML = '';
        const canvas = document.createElement('canvas');
        qrDiv.appendChild(canvas);
        
        // Use the actual game score from the game instance
        const gameScore = window.game ? window.game.score : 0;
        const utmParams = new URLSearchParams({
            utm_source: 'stain_slayer_qr',
            utm_medium: 'qr_code',
            utm_campaign: 'fab_detergent_2025',
            utm_content: 'results_qr',
            utm_term: 'godrej_fab_purchase',
            score: gameScore
        });
        
        new QRious({
            element: canvas,
            value: `https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061?${utmParams.toString()}`,
            size: 90, 
            background: '#ffffff',
            foreground: '#000000',
            level: 'H'
        });
        
        console.log(`âœ… QR code generated with score: ${gameScore}`);
    } catch (error) {
        console.error('âŒ QR Code generation failed:', error);
        // Fallback display
        const qrDiv = document.getElementById('qrCode');
        if (qrDiv) {
            qrDiv.innerHTML = '<div style="font-size: 0.7em; color: #666;">QR<br>Code<br>Error</div>';
        }
    }
}

/**
 * Save game code to clipboard
 */
function saveGameCode() {
    try {
        const qrCanvas = document.querySelector('#qrCode canvas');
        if (!qrCanvas) {
            alert('QR code not found. Please wait for it to load.');
            return;
        }

        // Create download link
        const link = document.createElement('a');
        link.download = `FAB-Stain-Slayer-QR-Score-${window.game ? window.game.score : 0}.png`;
        link.href = qrCanvas.toDataURL('image/png');
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        alert('QR code downloaded successfully!');
    } catch (error) {
        console.error('Download failed:', error);
        // Fallback to text code
        const gameCode = `FAB-${Math.random().toString(36).substr(2, 8).toUpperCase()}`;
        alert(`Download failed. Your game code: ${gameCode}`);
    }
}

/**
 * Open Fab product purchase page
 */
function buyFabProduct() {
    const utmParams = new URLSearchParams({
        utm_source: 'stain_slayer_results',
        utm_medium: 'mobile_game',
        utm_campaign: 'fab_detergent_2025',
        utm_content: 'buy_fab_button',
        utm_term: 'godrej_fab_purchase'
    });
    
    const blinkitUrl = `https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061?${utmParams.toString()}`;
    window.open(blinkitUrl, '_blank');
}

/**
 * Share game results on WhatsApp
 */
/**
 * Share game results on WhatsApp
 */
function shareOnWhatsApp() {
    const finalScore = document.getElementById('finalScore')?.textContent || '0';
    const blockedCount = document.getElementById('blockedCount')?.textContent || '0';
    
    // 8 Array integrated
    const messages = [
        `Yaar maine Stain Slayer khela - Political Rally mein ${finalScore} score kiya! ${blockedCount} projectiles block kiye!\n\nNeta ji ka safed kurta bachaya Godrej Fab se! Daag toh bhag gaye bhai!\n\nTu bhi khel aur Fab wala magic le: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Bro! Stain Slayer mein ${finalScore} points banaye! ${blockedCount} ande-tamatar se neta ko bachaya!\n\nFab ki power se politician ka reputation clean! Democracy bachao, Fab lagao!\n\nGame try kar aur Fab wala Power order kar: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Dekh bhai! Political Rally mein ${finalScore} score - ${blockedCount} missiles block kiye maine!\n\nNeta ji ka white shirt = Fab se protected! Stains ka kya haal kiya maine!\n\nTu bhi hero ban aur Fab wala magic le ja: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Yaar maine neta ki bodyguard bana! Score: ${finalScore}, Blocked: ${blockedCount} attacks!\n\nPublic ka gussa vs Fab ka power - guess kaun jeeta? Fab FTW!\n\nGame khel aur Fab ka Power mangwa: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Stain Slayer champion alert! ${finalScore} points, ${blockedCount} projectiles defeated!\n\nPolitician ka kurta = spotless! Fab ka kamaal dekha ki nahi?\n\nAb tera turn hai - game try kar aur Fab wala magic order kar: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Bhai sahab! Rally mein ${finalScore} score kiya - ${blockedCount} stain attacks rokiye!\n\nNeta ji ka white dress code = Fab se maintained! Democracy is safe yaar!\n\nTu bhi defensive player ban aur Fab wala Power le: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Yaar Stain Slayer mein mast performance! Score: ${finalScore}, Defense: ${blockedCount} blocks!\n\nPolitical rally mein neta ka reputation bachaya - Fab ke saath full swag!\n\nAb tu khel aur Fab wala magic manga: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Dekho mere skills! Stain Slayer mein ${finalScore} points - ${blockedCount} dirty attacks blocked!\n\nNeta ji ka pristine image = Fab protected! Clean politics ka naya level!\n\nTera number hai - game khelo aur Fab ka Power lo: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`
    ];
    
    // Select random message
    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
    const message = encodeURIComponent(randomMessage);
    
    const whatsappUrl = `https://wa.me/?text=${message}`;
    window.open(whatsappUrl, '_blank');
}

/**
 * Restart the game
 */
function playAgain() {
    debug3DViewer('PLAY_AGAIN_START', 'Play Again button clicked');
    
    // STEP 1: IMMEDIATELY CANCEL ANY PENDING 3D VIEWER INITIALIZATION
    if (window.pending3DViewerTimeouts) {
        debug3DViewer('CANCELLING_TIMEOUTS', `Found ${window.pending3DViewerTimeouts.length} pending timeouts`);
        window.pending3DViewerTimeouts.forEach(timeoutId => {
            clearTimeout(timeoutId);
            debug3DViewer('TIMEOUT_CANCELLED', `Cancelled timeout ID: ${timeoutId}`);
        });
        window.pending3DViewerTimeouts = [];
        console.log('Cancelled pending 3D viewer initialization timeouts');
    } else {
        debug3DViewer('NO_TIMEOUTS', 'No pending timeouts to cancel');
    }
    
    // STEP 2: CLEANUP EXISTING 3D VIEWER
    if (window.product3DViewer) {
        debug3DViewer('DESTROYING_VIEWER', 'Destroying existing 3D viewer');
        try {
            window.product3DViewer.destroy();
            debug3DViewer('DESTROY_SUCCESS', '3D viewer destroyed successfully');
            console.log('3D viewer destroyed successfully');
        } catch (error) {
            debug3DViewer('DESTROY_ERROR', error.message);
            console.warn('Error destroying 3D viewer:', error);
        }
        window.product3DViewer = null;
    } else {
        debug3DViewer('NO_VIEWER', 'No existing 3D viewer to destroy');
    }
    
    // STEP 3: HIDE RESULTS SCREEN
    const resultsScreen = document.getElementById('resultsScreen');
    if (resultsScreen) {
        resultsScreen.classList.remove('show');
        debug3DViewer('RESULTS_HIDDEN', 'Results screen hidden');
    }
    
    // SetTimeout with aggressive time conditions
setTimeout(() => {
    if (window.game) {
        // Hide canvas initially
        window.game.canvas.style.display = 'none';
        window.game.canvas.style.visibility = 'hidden';
        
        // Reset game state
        window.game.politicianHealth = 100;
        window.game.projectiles = [];
        window.game.particles = [];
        window.game.trailParticles = [];
        window.game.politician.stains = [];
        window.game.currentState = window.game.gameStates.START_SCREEN;
        window.game.isRunning = false;
        window.game.ctx.clearRect(0, 0, window.game.canvas.width, window.game.canvas.height);
        
        // Clear touch controls
        window.game.touchControls = {
            up: false, down: false, left: false, right: false, shield: false, slowmo: false
        };
        
        // Hide HUD elements first
        const hudElements = ['gameHUD', 'levelInfo', 'powerIndicators'];
        hudElements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.classList.remove('show');
            }
        });
        
        window.game.resetGameState();
        window.game.startGame(); // This will handle the proper canvas timing
    }
}, 100);
}

/**
 * Initialize game when DOM is loaded
 */
window.addEventListener('load', () => {
    try {
        window.game = new StainSlayerGame();
        console.log('[GAME] Stain Slayer initialized successfully');
    } catch (error) {
        console.error('[GAME] Failed to initialize:', error);
        alert('Game failed to load. Check console for details.');
    }
});

// Add after window.addEventListener('load', () => {...})
window.debugGameIssues = {
    findYellowBorders: function() {
        const allElements = document.querySelectorAll('*');
        const yellowElements = [];
        
        allElements.forEach(el => {
            const styles = getComputedStyle(el);
            const borderColor = styles.borderColor;
            
            if (borderColor.includes('255, 215') || 
                borderColor.includes('#FFD') ||
                el.style.borderColor && el.style.borderColor.includes('gold')) {
                yellowElements.push({
                    element: el,
                    borderColor: borderColor,
                    id: el.id || 'no-id',
                    className: el.className || 'no-class'
                });
            }
        });
        
        console.table(yellowElements);
        return yellowElements;
    }
};

/**
 * Global error handler
 */
window.addEventListener('error', (event) => {
    console.error('[GLOBAL ERROR]', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
    });
});

// DEBUG UTILITIES

if (typeof window !== 'undefined') {
    /**
     * Debug utilities for development
     */
    window.gameDebug = {
        toggleDebug: () => {
            if (window.game) {
                window.game.debug.enabled = !window.game.debug.enabled;
                console.log('Debug logging:', window.game.debug.enabled ? 'ENABLED' : 'DISABLED');
            }
        },
        setLogLevel: (level) => {
            if (window.game) {
                window.game.debug.logLevel = level;
                console.log('Debug level set to:', level);
            }
        },
        spawnProjectile: () => {
            if (window.game) {
                window.game.spawnProjectile();
            }
        },
        getGameState: () => {
            if (window.game) {
                return {
                    state: window.game.currentState,
                    score: window.game.score,
                    health: window.game.politicianHealth,
                    projectiles: window.game.projectiles.length,
                    particles: window.game.particles.length + window.game.trailParticles.length
                };
            }
            return null;
        },
        forceLevelUp: () => {
            if (window.game) {
                window.game.level++;
                window.game.wave = 1;
                console.log('Forced level up to:', window.game.level);
            }
        },
        debugFlags: () => {
            if (window.game) {
                return window.game.debugFlags();
            }
        },
        toggleFlagDebug: () => {
            if (window.game) {
                return window.game.toggleFlagDebug();
            }
        }
    };
    
    console.log('Debug commands available: window.gameDebug');
}
    </script>
</body>
</html>