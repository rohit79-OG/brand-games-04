<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stain Slayer - Godrej FAB</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #FFD400, #FFA500);
        }

        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            margin: 0;
            padding: 0;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            margin: 0 !important;
            padding: 0 !important;
            background: linear-gradient(135deg, #FFD400, #FFA500) !important;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000 !important;
            color: white;
        }

        .loading-card {
            background: linear-gradient(135deg, rgba(255, 212, 0, 0.9), rgba(255, 165, 0, 0.9));
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 215, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .loading-title {
            font-size: 2.5em;
            font-weight: bold;
            color: #0097D7;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .loading-subtitle {
            font-size: 1.2em;
            color: #1A2F85;
            margin-bottom: 30px;
            font-weight: bold;
        }

        .loading-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            border-radius: 4px;
            transition: width 0.3s ease;
            animation: pulse 1.5s infinite;
        }

        .loading-tip {
            font-size: 1.1em;
            color: #1A2F85;
            font-style: italic;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05);
            }
        }

      /* Start Screen */
.start-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    padding: 20px !important;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9000 !important;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease;
    transform: translateY(-100vh);
}

.start-screen:not(.hidden) {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    transform: translateY(0) !important;
}

.start-screen.hidden {
    opacity: 0;
    pointer-events: none;
    display: none !important;
    visibility: hidden !important;
    transform: translateY(-100vh) !important;
}

.start-card {
    background: linear-gradient(135deg, rgba(255, 212, 0, 0.9), rgba(255, 165, 0, 0.9));
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 215, 0, 0.3);
    max-width: 400px;
    width: 90%;
    color: white;
}

/* Mobile-specific centering for start screen */
@media (max-width: 768px) {
    .start-screen {
        padding: 13vh 20px !important;
        justify-content: center !important;
    }
    
    .start-card {
        max-height: 80vh !important;
        overflow-y: auto !important;
        padding: 30px !important;
    }
}
        .fab-logo-img {
            height: 100px;
            width: auto;
            margin-bottom: 10px;
        }

        .game-main-title {
            font-size: 3em;
            font-weight: bold;
            color: #0097D7;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-subtitle {
            font-size: 1.1em;
            margin-bottom: 30px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
        }

        .character-preview-img {
            width: 120px;
            height: 120px;
            object-fit: contain;
            animation: float 3s ease-in-out infinite;
        }

        .play-button {
            background: linear-gradient(45deg, #1A2F85, #2A3F95);
            border: none;
            padding: 15px 40px;
            font-size: 1.3em;
            font-weight: bold;
            color: #FFFFFF;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease;
            pointer-events: all;
            margin-top: 10px;
        }

        .play-button:hover {
            transform: scale(1.05);
        }

        .play-button:active {
            transform: scale(0.95);
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes notificationFadeIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
        }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
        }
        }

        @keyframes notificationFadeOut {
          from {
               opacity: 1;
               transform: translateX(-50%) translateY(0);
        }
          to {
              opacity: 0;
              transform: translateX(-50%) translateY(-20px);
        }
        }

        /* Game HUD */
        .game-hud {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 240px;
            z-index: 1000;
            display: none;
        }

        .game-hud.show {
            display: block;
        }

        .compact-hud-container {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }    

        .hud-panel {
            margin-bottom: 8px;
        }

        .hud-item {
            margin-bottom: 6px;
         }

        .hud-item:last-child {
            margin-bottom: 0;
         }

        .hud-label {
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 3px;
            font-size: 0.8em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hud-bar-bg {
            width: 100%;
            height: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            overflow: hidden;
        }

        .hud-bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .health-bar {
            background: linear-gradient(90deg, #FFD700, #FFA500);
        }

       .health-bar.danger {
            background: linear-gradient(90deg, #FF0000, #AA0000);
        }

       .power-bar {
            background: linear-gradient(90deg, #FF4500, #FFD700);
            box-shadow: 0 0 8px rgba(255, 69, 0, 0.4);
        }

        .mood-bar {
            background: linear-gradient(90deg, #FF0000, #FFD700, #00FF00);
        }

        .score-value {
             color: white;
             font-weight: bold;
            font-size: 0.9em;
             text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
         }

        .stage-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            padding: 10px 25px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 1001;
            display: none;
        }

        .stage-indicator.show {
            display: block;
            animation: slideDown 0.5s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        /* Mobile Score Display - Top Right */
        .mobile-score-display {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            padding: 8px 12px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 1001;
            display: none;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .mobile-score-display {
                display: block !important;
            }
            .hud-item.score-item {
                display: none !important;
            }
        }

        .mobile-notification-container {
    position: fixed;
    top: 65px;
    right: 15px;
    z-index: 9999;
    max-width: 200px;
    display: none;
}

@media (max-width: 768px) {
    .mobile-notification-container {
        display: block;
    }
}

.mobile-notification-item {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.25);
    border-radius: 8px;
    padding: 8px 12px;
    color: white;
    font-weight: bold;
    font-size: 0.75em;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    text-align: right;
    margin-bottom: 5px;
    opacity: 0;
    transform: translateX(20px);
    transition: all 0.3s ease;
    line-height: 1.2;
}

.mobile-notification-item.show {
    opacity: 1;
    transform: translateX(0);
} 
     
        /* Stage-Specific Mechanics Styles */
        .stage-mechanic {
            position: fixed;
            top: 140px;
            left: 15px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 15px;
            z-index: 1001;
            min-width: 280px;
        }

         .stage-meter {
            margin-top: 8px;
        }
        
        #stageMeterBar {
            background: linear-gradient(90deg, #FF0000, #FFD700, #00FF00);
            transition: width 0.3s ease, background 0.3s ease;
        }

        .mechanic-label {
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        /* Achievement glow effect */
        .achievement-item.fab-glow {
            background: rgba(255, 215, 0, 0.3) !important;
            border-color: rgba(255, 165, 0, 0.8) !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6) !important;
            animation: fabGlow 1s ease-in-out infinite alternate;
        }
        
        @keyframes fabGlow {
            from { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            to { box-shadow: 0 0 25px rgba(255, 165, 0, 0.8); }
        }

        /* Power Hit Warning */
       .warning-indicator {
    position: fixed;
    top: 200px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.25);
    border-radius: 12px;
    padding: 12px 24px;
    color: white;
    font-weight: bold;
    font-size: 1.1em;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    text-align: center;
    z-index: 1005;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    animation: slideDown 0.5s ease;
}

        @keyframes warningPulse {
            0%, 100% { 
                transform: translateX(-50%) scale(1);
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            }
            50% { 
                transform: translateX(-50%) scale(1.05);
                box-shadow: 0 0 40px rgba(255, 0, 0, 1);
            }
        }

        /* Grease Blur Effect */
        .grease-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 997;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            background: rgba(139, 69, 19, 0.2);
            animation: greaseAnimation 3s ease-out forwards;
        }

        @keyframes greaseAnimation {
            from {
                opacity: 1;
                backdrop-filter: blur(5px);
                -webkit-backdrop-filter: blur(5px);
            }
            to {
                opacity: 0;
                backdrop-filter: blur(0px);
                -webkit-backdrop-filter: blur(0px);
            }
        }

        /* Flash Daze Effect */
        .flash-daze-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0));
            pointer-events: none;
            z-index: 999;
            animation: flashDazeAnimation 1s ease-out forwards;
        }

        @keyframes flashDazeAnimation {
            0% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }

        /* Obstacle Styles for Street Stage */
        .street-obstacle {
            position: absolute;
            background: linear-gradient(135deg, #8B4513, #654321);
            border: 2px solid #4B2414;
            border-radius: 10px;
        }

        /* Audio Controls */
        .audio-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1002;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .audio-btn {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .audio-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .audio-btn.muted {
            color: #FF0000;
        }

        .volume-sliders {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 10px;
            display: none;
            gap: 10px;
        }

        .volume-sliders.show {
            display: flex;
        }

        .volume-control {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .volume-control label {
            color: white;
            font-size: 0.8em;
            margin-bottom: 5px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .volume-control input[type="range"] {
            width: 80px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            border-radius: 2px;
        }

        .volume-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #FFD700;
            border-radius: 50%;
            cursor: pointer;
        }

        .volume-control input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #FFD700;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Hide volume sliders on mobile */
        @media (max-width: 768px) {
            .volume-sliders {
                display: none !important;
            }
            
        }

        /* Achievement System - Desktop Only */
        .achievement-board {
            position: fixed;
            left: 15px;
            top: 295px;
            transform: translateY(-50%);
            width: 280px;
            max-height: 250px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 10px;
            overflow-y: auto;
            z-index: 900;
            display: none;
        }

        /* When stage meter is active, move achievements further down */
        #stageMeterContainer:not([style*="display: none"]) ~ * .achievement-board {
            top: 305px;
        }

        .achievement-board.show {
            display: block;
        }

        .achievement-title {
            color: #FFD700;
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .achievement-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 5px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .achievement-item.unlocked {
            background: rgba(255, 215, 0, 0.2);
            border-color: rgba(255, 215, 0, 0.5);
            animation: achievementUnlock 0.5s ease;
        }

        @keyframes achievementUnlock {
            0% {
                transform: scale(0.9);
                opacity: 0;
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .achievement-icon {
            font-size: 1.2em;
            margin-right: 6px;
            filter: grayscale(100%);
            opacity: 0.3;
        }

        .achievement-item.unlocked .achievement-icon {
            filter: grayscale(0%);
            opacity: 1;
        }

        .achievement-info {
            flex: 1;
        }

        .achievement-name {
            color: white;
            font-weight: bold;
            font-size: 0.75em;
            margin-bottom: 1px;
        }

        .achievement-desc {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.65em;
        }

        /* Achievement Notification */
        .achievement-notification {
            position: fixed;
            top: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 165, 0, 0.9));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            padding: 15px 30px;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            animation: achievementSlideIn 0.5s ease;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        @keyframes achievementSlideIn {
            from {
                transform: translateX(-50%) translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        .achievement-notification-icon {
            font-size: 2em;
        }

        /* Score Multiplier Display */
        .multiplier-display {
            position: fixed;
            top: 150px;
            right: 30px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            padding: 10px 20px;
            color: #FFD700;
            font-weight: bold;
            font-size: 1.3em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 1001;
            display: none;
        }

        .multiplier-display.show {
            display: block;
            animation: multiplierPulse 0.3s ease;
        }

        @keyframes multiplierPulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        /* Hide achievement board on mobile */
        @media (max-width: 768px) {
            .achievement-board {
                display: none !important;
            }
        }

       /* Mobile Controls - Updated */
         .mobile-controls {
             position: fixed;
             bottom: 30px;
             left: 50%;
             transform: translateX(-50%);
             z-index: 1002;
             display: none;
             gap: 30px;
         }
         
         .mobile-controls.show {
             display: flex;
             justify-content: center;
             align-items: center;
         }
        
        /* Hide original power-up icons on mobile since mobile-controls provide them */
        @media (max-width: 768px) {
            .powerup-indicator {
                display: none !important;
            }
        }
        
        /* Move audio controls to bottom-left for both desktop and mobile */
        .audio-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            top: auto;
            right: auto;
            z-index: 1002;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .control-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.3);
        }

        /* Power-up Bar */
        .power-bar-container {
            margin-top: 10px;
        }

        .power-label {
            color: #FFD700;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .power-bar-bg {
            width: 100%;
            height: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 7px;
            overflow: hidden;
        }

        .power-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF4500, #FFD700);
            border-radius: 7px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
        }

        /* Combo Counter */
        .combo-display {
            position: fixed;
            top: 150px;
            right: 30px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            padding: 10px 20px;
            color: #FFD700;
            font-weight: bold;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 1001;
            display: none;
        }

        .combo-display.show {
            display: block;
            animation: comboPopup 0.3s ease;
        }

        @keyframes comboPopup {
            from {
                transform: scale(0.5);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Power-up Icons */
         .powerup-indicator {
             position: fixed;
             bottom: 20px;
             left: 50%;
             transform: translateX(-50%);
             display: flex;
             gap: 20px;
             z-index: 1002;
        }
        
        /* Show power-up icons on both desktop and mobile */
        @media (min-width: 769px) {
            .powerup-indicator {
                bottom: 20px; /* Same level as audio controls */
                gap: 30px; /* Wider spacing on desktop */
            }
        }
         
        .powerup-icon {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            opacity: 1;
            transition: all 0.3s ease;
            cursor: pointer;
           user-select: none;
           -webkit-tap-highlight-color: transparent;
        }

         .powerup-icon:hover {
            transform: scale(1.05);
            border-color: #FFD700;
        }
        
        .powerup-icon:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.3);
         }

        .powerup-icon.active {
            opacity: 1;
            animation: powerupGlow 1s infinite;
            border-color: #FFD700;
        }

        @keyframes powerupGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 1);
            }
        }

        /* Special Effects */
        .screen-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 999;
            opacity: 0;
        }

        .screen-flash.active {
            animation: flashEffect 0.3s ease;
        }

        @keyframes flashEffect {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .slow-motion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, transparent 40%, rgba(0, 150, 255, 0.2) 100%);
            pointer-events: none;
            z-index: 998;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .slow-motion-overlay.active {
            opacity: 1;
        }

       /* Results Screen - Complete Implementation */
.results-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    padding: 20px !important;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 8000 !important;
    color: white;
    visibility: hidden;
    opacity: 0;
    transform: translateY(-100vh);
    pointer-events: none;
}

.results-screen.show {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    z-index: 10000 !important;
    transform: translateY(0) !important;
    pointer-events: auto !important;
}

.results-card {
    background: linear-gradient(135deg, rgba(255, 212, 0, 0.9), rgba(255, 165, 0, 0.9)) !important;
    border-radius: 20px;
    padding: 30px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 215, 0, 0.3);
    max-width: 400px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* Mobile-specific centering for results screen */
@media (max-width: 768px) {
    .results-screen {
        padding: 13vh 20px !important;
        justify-content: center !important;
    }
    
    .results-card {
        max-height: 85vh !important;
        overflow-y: auto !important;
        padding: 20px !important;
    }
}

        .results-title {
            font-size: 2.2em;
            font-weight: bold;
            color: #1A2F85;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .results-score {
            font-size: 1.5em;
            color: #1A2F85;
            margin-bottom: 20px;
        }

        .results-stats {
            background: rgba(26, 47, 133, 0.3) !important;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            color: white;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            border: none !important;
        }

        .results-stats p {
            margin: 5px 0;
            font-size: 1.1em;
        }

        .results-stats strong {
            color: #FFD700;
        }

        .performance-rating-container {
            margin: 20px 0;
            text-align: center;
            background: transparent !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        .performance-rating {
            font-size: 1.4em;
            font-weight: bold;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1) !important;
            border-radius: 15px;
            margin: 15px 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        .product-section {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 25px 0;
            gap: 40px;
        }

        .qr-code {
            width: 90px;
            height: 90px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            color: black;
            text-align: center;
            padding: 5px;
            overflow: hidden;
            transform: translateX(0);
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        .qr-code canvas {
            width: 100%;
            height: 100%;
        }

        .fab-product {
            width: 90px;
            height: 90px;
            background: transparent;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-left: 5px;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        .ar-section {
            background: rgba(0, 151, 215, 0.1) !important;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 2px dashed rgba(0, 151, 215, 0.5) !important;
            min-height: 320px;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        .ar-title {
            color: #0097D7;
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .ar-description {
            font-size: 1.1em;
            color: #1A2F85;
            margin-bottom: 15px;
            text-align: center;
            line-height: 1.4;
        }

        .ar-description strong {
            color: #0097D7;
            font-weight: bold;
        }

        .product-3d-container {
            width: 100%;
            max-width: 300px;
            height: 200px;
            margin: 0 auto 15px auto;
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            background: transparent !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        #product3DCanvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .action-button {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease;
            font-size: 0.9em;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        .action-button:hover {
            transform: scale(1.05);
        }

        .save-code-btn {
            background: linear-gradient(45deg, #0097D7, #00B4E6);
            color: #000;
        }

        .buy-fab-btn {
            background: linear-gradient(45deg, #FFD400, #FFA500);
            color: #1A2F85;
        }

        .whatsapp-btn {
            background: linear-gradient(45deg, #25D366, #128C7E);
            color: white;
        }

        .play-again-btn {
            background: linear-gradient(45deg, #1A2F85, #2A3F95);
            color: white;
            width: 100%;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex !important;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
</head>
<body>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-card">
            <div class="fab-logo">
                <img src="https://assets.codepen.io/t-24779/FAB-Liquid.png" alt="FAB Liquid" class="fab-logo-img">
            </div>
            <h1 class="loading-title">Stain Slayer</h1>
            <h2 class="loading-subtitle">Loading Game...</h2>
            <div class="loading-progress">
                <div class="loading-progress-fill" id="progressFill"></div>
            </div>
            <p class="loading-tip">Protect everything - in politics and in laundry!</p>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="start-screen hidden">
        <div class="start-card">
            <div class="fab-logo">
                <img src="https://assets.codepen.io/t-24779/FAB-Liquid.png" alt="FAB Liquid" class="fab-logo-img">
            </div>
            <h1 class="game-main-title">Stain Slayer</h1>
            <div class="character-preview">
                <img src="https://assets.codepen.io/t-24779/game-start-image.png" alt="Game Character" class="character-preview-img">
            </div>
            <p class="game-subtitle">
                <strong>Block stains, score lasting freshness!</strong>
            </p>
            <button id="startButton" class="play-button">Play Game</button>
        </div>
    </div>

   <!-- Game HUD -->
<div id="gameHUD" class="game-hud">
    <div class="compact-hud-container">
        <div class="hud-item">
            <div class="hud-label">Reputation</div>
            <div class="hud-bar-bg">
                <div id="healthBar" class="hud-bar-fill health-bar" style="width: 100%"></div>
            </div>
        </div>
        
       <div class="hud-item">
            <div class="hud-label">FAB Power</div>
            <div class="hud-bar-bg">
                <div id="powerBar" class="hud-bar-fill power-bar" style="width: 0%"></div>
            </div>
        </div>
        
        <div class="hud-item score-item">
            <div class="hud-label">Score: <span id="scoreValue" class="score-value">0</span></div>
        </div>
        
        <!-- Dynamic stage-specific meter -->
        <div id="stageMeterContainer" class="hud-item stage-meter" style="display: none;">
            <div id="stageMeterLabel" class="hud-label"></div>
            <div class="hud-bar-bg">
                <div id="stageMeterBar" class="hud-bar-fill" style="width: 50%"></div>
            </div>
        </div>
    </div>
</div>

     <!-- Mobile Score Display -->
    <div id="mobileScoreDisplay" class="mobile-score-display">
        Score: <span id="mobileScoreValue">0</span>
    </div>

    <!-- Mobile-only notification container -->
    <div id="mobileNotificationContainer" class="mobile-notification-container">
    </div>

    <!-- Stage Indicator -->
    <div id="stageIndicator" class="stage-indicator">
        <span id="stageName">Political Rally</span>
    </div>

    <!-- Audio Controls -->
    <div id="audioControls" class="audio-controls">
        <button id="muteBtn" class="audio-btn" title="Mute/Unmute">🔊</button>
        <div class="volume-sliders">
            <div class="volume-control">
                <label>Music</label>
                <input type="range" id="musicVolume" min="0" max="100" value="50">
            </div>
            <div class="volume-control">
                <label>SFX</label>
                <input type="range" id="sfxVolume" min="0" max="100" value="70">
            </div>
        </div>
    </div>
    
    <!-- Achievement Board - Desktop Only -->
    <div id="achievementBoard" class="achievement-board">
        <div class="achievement-title">🏆 Achievements</div>
        <div id="achievementList"></div>
    </div>
    
    <!-- Score Multiplier Display -->
    <div id="multiplierDisplay" class="multiplier-display">
        x<span id="multiplierValue">1</span>
    </div>

    <!-- Combo Display -->
    <div id="comboDisplay" class="combo-display">
        Combo x<span id="comboValue">0</span>
    </div>

    <!-- Power-up Indicators - Updated for Mobile -->
    <div class="powerup-indicator">
        <div id="superShieldIcon" class="powerup-icon" title="Super Shield (Q)" data-power="shield">🛡️</div>
        <div id="slowMotionIcon" class="powerup-icon" title="Slow Motion (E)" data-power="slow">⏰</div>
        <div id="fabBombIcon" class="powerup-icon" title="FAB Bomb (R)" data-power="bomb">💥</div>
    </div>

    <!-- Special Effects -->
    <div class="screen-flash" id="screenFlash"></div>
    <div class="slow-motion-overlay" id="slowMotionOverlay"></div>

    <!-- Stage-Specific Mechanics UI -->
    
    <!-- Rally: Crowd Mood Meter -->
    <div id="crowdMoodContainer" class="stage-mechanic" style="display: none;">
        <div class="mechanic-label">Crowd Mood</div>
        <div class="mood-meter">
            <div id="crowdMoodBar" class="mood-bar"></div>
        </div>
    </div>
    
    <!-- Wedding: Splatter Meter -->
    <div id="splatterMeterContainer" class="stage-mechanic" style="display: none;">
        <div class="mechanic-label">Splatter Level</div>
        <div class="splatter-meter">
            <div id="splatterBar" class="splatter-bar"></div>
        </div>
    </div>
    
    <!-- Cricket: Power Hit Warning -->
    <div id="powerHitWarning" class="warning-indicator" style="display: none;">
        ⚡ POWER HIT INCOMING! ⚡
    </div>
    
    <!-- Debate: Perception Meter -->
    <div id="perceptionMeterContainer" class="stage-mechanic" style="display: none;">
        <div class="mechanic-label">Public Perception</div>
        <div class="perception-meter">
            <div id="perceptionBar" class="perception-bar"></div>
        </div>
    </div>
    
    <!-- Street: Grease Blur Effect -->
    <div id="greaseBlur" class="grease-effect" style="display: none;"></div>
    
    <!-- Debate: Flash Daze Effect -->
    <div id="flashDaze" class="flash-daze-effect" style="display: none;"></div>

    <!-- Mobile Controls - Updated without arrows -->
    <div id="mobileControls" class="mobile-controls">
        <button class="control-btn" id="jumpBtn">⬆️</button>
        <button class="control-btn" id="shieldBtn">🛡️</button>
        <button class="control-btn" id="pushBtn">💨</button>
    </div>

    <!-- Results Screen -->
    <div id="resultsScreen" class="results-screen">
        <div class="results-card">
            <h2 class="results-title">Game Over</h2>
            <div class="results-score">Score: <span id="finalScore">0</span></div>
            
            <div class="results-stats">
                <p>Your defense lasted <strong><span id="sessionTime">0</span> seconds!</strong></p>
                <p>Accuracy: <strong><span id="accuracyPercent">0</span>% (<span id="hitStats">0/0</span>)</strong></p>
                <p>Projectiles Blocked: <strong><span id="blockedCount">0</span></strong></p>
            </div>
            
            <div class="performance-rating-container">
                <div id="performanceRating" class="performance-rating"></div>
            </div>
            
            <div class="product-section">
                <div class="qr-code" id="qrCode">
                    <!-- QR code will be generated here -->
                </div>
                <div class="fab-product" onclick="buyFabProduct()">
                    <img src="https://assets.codepen.io/t-24779/fab-detergent-india.png" alt="FAB Detergent" style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;">
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="action-button save-code-btn" onclick="saveGameCode()">Save Code</button>
                <button class="action-button buy-fab-btn" onclick="buyFabProduct()">Stay Fab</button>
            </div>
            
            <div class="ar-section">
                <div class="ar-title">Interactive Product Showcase</div>
                <p class="ar-description">
                    Dono side Fab ka swag!<br>
                    <strong>Drag to rotate & Scroll to zoom in/out</strong>
                </p>
                <div class="product-3d-container" id="product3DContainer">
                    <canvas id="product3DCanvas"></canvas>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="action-button whatsapp-btn" onclick="shareOnWhatsApp()">WhatsApp</button>
            </div>
            
            <button class="action-button play-again-btn" onclick="playAgain()">Play Again</button>
        </div>
    </div>

  <script type="module">
// ============= RESULTS SCREEN FUNCTIONS (keeping existing) =============
function generateQRCode() {
    try {
        console.log("🎯 Generating QR code...");
        
        const qrDiv = document.getElementById('qrCode');
        if (!qrDiv || typeof QRious === 'undefined') {
            console.log("🎯 QR code generation failed - missing elements");
            return;
        }
        
        qrDiv.innerHTML = '';
        const canvas = document.createElement('canvas');
        qrDiv.appendChild(canvas);
        
        const gameScore = window.game ? window.game.score : 0;
        const utmParams = new URLSearchParams({
            utm_source: 'stain_slayer_qr',
            utm_medium: 'qr_code',
            utm_campaign: 'fab_detergent_2025',
            utm_content: 'results_qr',
            utm_term: 'godrej_fab_purchase',
            score: gameScore
        });
        
        new QRious({
            element: canvas,
            value: `https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061?${utmParams.toString()}`,
            size: 90,
            background: '#ffffff',
            foreground: '#000000',
            level: 'H'
        });
        
        console.log(`QR code generated with score: ${gameScore}`);
    } catch (error) {
        console.error('QR Code generation failed:', error);
        const qrDiv = document.getElementById('qrCode');
        if (qrDiv) {
            qrDiv.innerHTML = '<div style="font-size: 0.7em; color: #666;">QR<br>Code<br>Error</div>';
        }
    }
}

function saveGameCode() {
    try {
        const qrCanvas = document.querySelector('#qrCode canvas');
        if (!qrCanvas) {
            alert('QR code not found. Please wait for it to load.');
            return;
        }

        const link = document.createElement('a');
        link.download = `FAB-Stain-Slayer-QR-Score-${window.game ? window.game.score : 0}.png`;
        link.href = qrCanvas.toDataURL('image/png');
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        alert('QR code downloaded successfully!');
    } catch (error) {
        console.error('Download failed:', error);
        const gameCode = `FAB-${Math.random().toString(36).substr(2, 8).toUpperCase()}`;
        alert(`Download failed. Your game code: ${gameCode}`);
    }
}

function buyFabProduct() {
    const utmParams = new URLSearchParams({
        utm_source: 'stain_slayer_results',
        utm_medium: 'mobile_game',
        utm_campaign: 'fab_detergent_2025',
        utm_content: 'buy_fab_button',
        utm_term: 'godrej_fab_purchase'
    });
    
    const blinkitUrl = `https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061?${utmParams.toString()}`;
    window.open(blinkitUrl, '_blank');
}

function shareOnWhatsApp() {
    const finalScore = document.getElementById('finalScore')?.textContent || '0';
    const blockedCount = document.getElementById('blockedCount')?.textContent || '0';
    
    const messages = [
        `Yaar maine Stain Slayer khela - Political Rally mein ${finalScore} score kiya! ${blockedCount} projectiles block kiye!\n\nNeta ji ka safed kurta bachaya Godrej Fab se! Daag toh bhag gaye bhai!\n\nTu bhi khel aur Fab wala magic le: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Bro! Stain Slayer mein ${finalScore} points banaye! ${blockedCount} ande-tamatar se neta ko bachaya!\n\nFab ki power se politician ka reputation clean! Democracy bachao, Fab lagao!\n\nGame try kar aur Fab wala Power order kar: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Dekh bhai! Political Rally mein ${finalScore} score - ${blockedCount} missiles block kiye maine!\n\nNeta ji ka white shirt = Fab se protected! Stains ka kya haal kiya maine!\n\nTu bhi hero ban aur Fab wala magic le ja: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`
    ];
    
    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
    const message = encodeURIComponent(randomMessage);
    
    const whatsappUrl = `https://wa.me/?text=${message}`;
    window.open(whatsappUrl, '_blank');
}

// 3D Product Viewer (keeping existing)
class Product3DViewer {
    constructor(canvasId, containerId) {
        if (typeof THREE === 'undefined') {
            console.error('THREE.js is not available');
            return;
        }
        
        this.canvas = document.getElementById(canvasId);
        this.container = document.getElementById(containerId);
        
        if (!this.canvas || !this.container) {
            console.error('3D viewer elements not found');
            return;
        }
        
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.productPlane = null;
        this.isMouseDown = false;
        this.mouseX = 0;
        this.rotationY = 0;
        this.targetRotationY = 0;
        
        this.init();
    }
    
    init() {
        this.setupScene();
        this.createProduct();
        this.setupLighting();
        this.setupControls();
        this.animate();
    }

    setupScene() {
    this.scene = new THREE.Scene();
    this.scene.background = null;
    
    this.camera = new THREE.PerspectiveCamera(
        50,
        this.container.offsetWidth / this.container.offsetHeight,
        0.1,
        1000
    );
    this.camera.position.set(0, 0, 4);
    
    this.renderer = new THREE.WebGLRenderer({
        canvas: this.canvas,
        antialias: true,
        alpha: true
    });
    this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
}
        
    createProduct() {
        const loader = new THREE.TextureLoader();
        
        // Load FAB product textures
        const frontTexture = loader.load('https://assets.codepen.io/t-24779/fab-front-view-image.png');
        const backTexture = loader.load('https://assets.codepen.io/t-24779/fab-back-side-view.png');
        
        const planeGeometry = new THREE.PlaneGeometry(2.5, 3.2);
        this.productPlane = new THREE.Group();
        
        // Front face
        const frontMaterial = new THREE.MeshBasicMaterial({
            map: frontTexture,
            transparent: true,
            side: THREE.FrontSide
        });
        const frontPlane = new THREE.Mesh(planeGeometry, frontMaterial);
        frontPlane.position.z = 0.001;
        this.productPlane.add(frontPlane);
        
        // Back face
        const backMaterial = new THREE.MeshBasicMaterial({
            map: backTexture,
            transparent: true,
            side: THREE.BackSide
        });
        const backPlane = new THREE.Mesh(planeGeometry, backMaterial);
        backPlane.position.z = -0.001;
        backPlane.scale.x = -1;
        this.productPlane.add(backPlane);
        
        this.scene.add(this.productPlane);
    }
    
    setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(1, 1, 1);
        this.scene.add(directionalLight);
    }
    
    setupControls() {
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.onMouseUp());
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
        
        this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
        this.canvas.addEventListener('touchend', () => this.onTouchEnd());
    }
    
    onMouseDown(event) {
        this.isMouseDown = true;
        this.mouseX = event.clientX;
    }
    
    onMouseMove(event) {
        if (!this.isMouseDown) return;
        const deltaX = event.clientX - this.mouseX;
        this.targetRotationY += deltaX * 0.01;
        this.mouseX = event.clientX;
    }
    
    onMouseUp() {
        this.isMouseDown = false;
    }
    
    onTouchStart(event) {
        event.preventDefault();
        if (event.touches.length === 1) {
            this.isMouseDown = true;
            this.mouseX = event.touches[0].clientX;
        }
    }
    
    onTouchMove(event) {
        event.preventDefault();
        if (!this.isMouseDown || event.touches.length !== 1) return;
        const deltaX = event.touches[0].clientX - this.mouseX;
        this.targetRotationY += deltaX * 0.02;
        this.mouseX = event.touches[0].clientX;
    }
    
    onTouchEnd() {
        this.isMouseDown = false;
    }
    
    onWheel(event) {
        event.preventDefault();
        const zoom = event.deltaY * 0.002;
        this.camera.position.z = Math.max(2.5, Math.min(6, this.camera.position.z + zoom));
    }
    
    animate() {
        if (!this.renderer || !this.scene || !this.camera) return;
        
        requestAnimationFrame(() => this.animate());
        
        if (this.productPlane) {
            this.rotationY += (this.targetRotationY - this.rotationY) * 0.1;
            this.productPlane.rotation.y = this.rotationY;
            
            if (!this.isMouseDown) {
                this.productPlane.rotation.y += 0.03;
                this.targetRotationY = this.productPlane.rotation.y;
            }
        }
        
        this.renderer.render(this.scene, this.camera);
    }
    
    destroy() {
        if (this.renderer) {
            this.renderer.dispose();
            this.renderer = null;
        }
        this.scene = null;
        this.camera = null;
        this.productPlane = null;
    }
}

// ============= FIXED GAME ENGINE =============
class StainSlayerGame {
    constructor() {
        this.debugMode = true; // Add this line
    console.log("Debug mode explicitly enabled:", this.debugMode);

        this.canvas = document.getElementById('gameCanvas');
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.clock = new THREE.Clock();
        
        // Game state
        this.currentStage = 'rally';
        this.score = 0;
        this.health = 200;
        this.projectiles = [];
        this.blockedCount = 0;
        this.totalProjectiles = 0;
        this.gameStartTime = 0;
        this.isRunning = false;
        
        // Adaptive Difficulty System
        this.difficultyLevel = 1; // 1-5 scale
        this.performanceScore = 0; // Tracks recent performance
        this.recentBlocks = []; // Track last 10 blocks for performance analysis
        this.baseProjectileInterval = 1500;
        
        // Score Multiplier System
        this.scoreMultiplier = 1;
        this.maxMultiplier = 5;
        this.comboThresholds = [5, 10, 20, 30, 50]; // Combo counts for multipliers
        
        // Achievement System
        this.achievements = {
            firstBlock: { id: 'firstBlock', name: 'First Defense', desc: 'Block your first projectile', icon: '🛡️', unlocked: false },
            combo10: { id: 'combo10', name: 'Combo Master', desc: 'Reach 10x combo', icon: '🔥', unlocked: false },
            survivor: { id: 'survivor', name: 'Survivor', desc: 'Survive for 60 seconds', icon: '⏱️', unlocked: false },
            stageRunner: { id: 'stageRunner', name: 'Stage Runner', desc: 'Reach all 5 stages', icon: '🏆', unlocked: false },
            fabPowerUser: { id: 'fabPowerUser', name: 'FAB Power', desc: 'Use all 3 power-ups', icon: '⚡', unlocked: false },
            perfectMinute: { id: 'perfectMinute', name: 'Perfect Defense', desc: '100% accuracy for 30 seconds', icon: '💯', unlocked: false },
            highScorer: { id: 'highScorer', name: 'High Scorer', desc: 'Score 1000 points', icon: '🌟', unlocked: false },
            dodgeMaster: { id: 'dodgeMaster', name: 'Dodge Master', desc: 'Dodge 50 projectiles', icon: '💨', unlocked: false },
            stainCleaner: { id: 'stainCleaner', name: 'Stain Cleaner', desc: 'Use FAB Bomb 3 times', icon: '💣', unlocked: false },
            speedDemon: { id: 'speedDemon', name: 'Speed Demon', desc: 'Reach 5x multiplier', icon: '⚡', unlocked: false }
        };
        this.newAchievements = []; // Queue for showing notifications
        // Notification queue system
        this.notificationQueue = [];
        this.currentNotification = null;
        this.notificationProcessing = false;
        this.notificationContainer = null;
        this.usedPowerUps = new Set(); // Track which power-ups have been used
        
        // Performance optimization
        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.quality = this.isMobile ? 'low' : 'high';
        this.maxParticles = this.isMobile ? 5 : 10;
        this.shadowsEnabled = !this.isMobile;
        this.projectilePool = [];
        this.maxPoolSize = 20;
        
        // Analytics tracking
        this.analytics = {
            sessionId: this.generateSessionId(),
            sessionStart: Date.now(),
            stagesReached: [],
            totalProjectilesBlocked: 0,
            totalProjectilesDodged: 0,
            powerUpsCollected: 0,
            powerUpsUsed: {},
            peakCombo: 0,
            totalScore: 0,
            deathCause: '',
            deviceType: this.isMobile ? 'mobile' : 'desktop',
            screenResolution: `${window.innerWidth}x${window.innerHeight}`,
            fps: []
        };
        
        // Stage-specific mechanics
        this.crowdMood = 50; // Rally stage
        this.greaseBlurActive = false; // Street stage
        this.splatterMeter = 0; // Wedding stage
        this.powerHitWarning = false; // Cricket stage
        this.perceptionMeter = 50; // Debate stage
        this.flashDazeActive = false; // Debate stage
        this.obstacles = []; // Street stage obstacles
        
        // Power-ups
        this.powerUps = [];
        this.fabPower = 0;
        this.fabPowerMax = 100;
        this.superShieldActive = false;
        this.slowMotionActive = false;
        this.comboCount = 0;
        this.lastBlockTime = 0;
        // Perfect minute tracking
        this.recentActions = []; // Track last 30 seconds of actions
        
        // Player
        this.player = null;
        this.politician = null;
        this.podium = null;
        this.stains = [];

        // Crowd system
        this.crowdMembers = [];
        this.crowdSprites = {};
        this.crowdAnimationTime = 0;
        this.crowdReactionTime = 0;
        this.crowdMoodReactive = false;
        this.lastCrowdReaction = 0;
        this.crowdCheerActive = false;

      // Cloud system for rally stage
        this.cloudSprites = [];
        this.cloudAnimationTime = 0;
        
        // Player physics
        this.playerVelocityY = 0;
        this.isJumping = false;
        this.gravity = -25;
        this.jumpVelocity = 12;
        this.groundY = 0.75;
        
        // Audio context and systems
        this.audioContext = null;
        this.audioInitialized = false;
        this.masterVolume = 0.7;
        this.musicVolume = 0.5;
        this.sfxVolume = 0.7;
        this.currentMusic = null;
        this.musicGainNode = null;
        this.sfxGainNode = null;
        this.audioBuffers = {};
        this.musicLoops = {};
        this.soundVariations = {};
        this.currentMusicLoop = null;
        this.musicInitialized = false;
        this.continuousMusicPlaying = false;
        
        // Stage management
        this.stageGroup = null;
        this.stageAmbientLight = null;
        this.stageDirectionalLight = null;
        this.stageFog = null;
        this.atmosphericLights = [];
        this.lastProjectileTime = 0;
        this.projectileInterval = 3000;
        
        // Controls
        this.keys = {};
        this.touchControls = {
            left: false,
            right: false,
            jump: false,
            shield: false,
            push: false
        };
        
        // Swipe detection
        this.touchStartX = 0;
        this.touchStartY = 0;
        this.touchStartTime = 0;

        // Mobile dash mechanics
        this.dashCooldown = 0;
        this.dashVelocity = 0;
        this.dashDuration = 0;
        this.lastTapTime = 0;

        // Consecutive hit tracking system
        this.consecutiveHits = 0;
        this.maxConsecutiveHits = 5;

        // Warning overlap prevention
        this.warningShown3 = false;
        this.warningShown4 = false;
        this.criticalWarningTime = 0;

        // Global mute system
        this.globalMuted = false;
        this.audioLevelsBeforeMute = null;

        // Debug verification
        console.log("🎮 CONSTRUCTOR: Consecutive hit system initialized", this.consecutiveHits);
        
        this.init();

    }
    
updateDebugOverlay() {
    if (this.projectiles.length > 0) {
        console.log(`Active projectiles: ${this.projectiles.length}, Aide position: (${this.player.position.x.toFixed(2)}, ${this.player.position.y.toFixed(2)})`);
    }

    if (!this.debugMode || !this.debugOverlay) return;
    
    let debugInfo = `
<strong>🎮 COLLISION DEBUG</strong><br>
<strong>Aide:</strong> (${this.player.position.x.toFixed(2)}, ${this.player.position.y.toFixed(2)}, ${this.player.position.z.toFixed(2)})<br>
<strong>Shield:</strong> ${this.player.shield.visible ? '🛡️ ACTIVE' : '❌ OFF'}<br>
<strong>Jumping:</strong> ${this.isJumping ? '⬆️ YES' : '❌ NO'}<br>
<strong>Projectiles:</strong> ${this.projectiles.length}<br>
<hr style="margin: 5px 0;">
`;

    this.projectiles.slice(0, 3).forEach((p, i) => {
        const distance = p.position.distanceTo(this.player.position);
        const xDiff = Math.abs(this.player.position.x - p.position.x);
        const canBlock = distance < 2.0 && (this.player.shield.visible || this.isJumping || xDiff < 1.0);
        
        debugInfo += `
<strong>P${i} ${p.emoji}:</strong> (${p.position.x.toFixed(1)}, ${p.position.y.toFixed(1)}, ${p.position.z.toFixed(1)})<br>
<strong>Distance:</strong> ${distance.toFixed(2)} | <strong>X-Diff:</strong> ${xDiff.toFixed(2)}<br>
<strong>Blockable:</strong> ${canBlock ? '✅ YES' : '❌ NO'}<br>
<hr style="margin: 3px 0;">
`;
    });
    
    this.debugOverlay.innerHTML = debugInfo;
}
    
    init() {
        // Setup Three.js
        this.setupRenderer();
        this.setupScene();
        this.setupLights();
        this.setupControls();
        this.setupAudio();
        this.initNotificationSystem();
        
        // Load assets then show start screen
        this.loadAssets().then(() => {
            this.hideLoadingScreen();
            this.showStartScreen();
        });
    }
    
    
   setupScene() {
    this.scene = new THREE.Scene();
    this.scene.background = null; // Remove background color to prevent bleeding
    
    // Adjust camera FOV and position based on device
    const fov = this.isMobile ? 60 : 75; // Optimized FOV for desktop gameplay
    this.camera = new THREE.PerspectiveCamera(
        fov,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    
    if (this.isMobile) {
        this.camera.position.set(0, 2, 6);
    } else {
        this.camera.position.set(0, 1.8, 6.8); // Adjusted camera position for better coverage
    }
    
    this.camera.lookAt(0, 1, 0);
}
  
    setupLights() {
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
    directionalLight.position.set(5, 10, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.near = 0.1;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -10;
    directionalLight.shadow.camera.right = 10;
    directionalLight.shadow.camera.top = 10;
    directionalLight.shadow.camera.bottom = -10;
    this.scene.add(directionalLight);
}

    
   setupControls() {
    // Keyboard controls
    document.addEventListener('keydown', (e) => {

        // Track key timing for conflict resolution
            if (!this.lastKeyTime) this.lastKeyTime = {};
            if (e.key === 'ArrowLeft') this.lastKeyTime.left = Date.now();
            if (e.key === 'ArrowRight') this.lastKeyTime.right = Date.now();
        // Desktop-specific key handling
        if (!this.isMobile) {
            e.preventDefault(); // Prevent browser shortcuts on desktop
        }
        this.keys[e.key] = true;
        
        // Jump on space
        if (e.key === ' ' && !this.isJumping) {
            e.preventDefault();
            this.jump();
        }
        
        // Shield on Shift
        if (e.key === 'Shift') {
            e.preventDefault();
        }

        // Desktop power-up shortcuts (immediate activation)
        if (!this.isMobile && this.isRunning) {
            switch(e.key.toLowerCase()) {
                case 'q':
                    e.preventDefault();
                    this.activateSuperShield();
                    break;
                case 'e':
                    e.preventDefault();
                    this.activateSlowMotion();
                    break;
                case 'r':
                    e.preventDefault();
                    this.activateFABBomb();
                    break;
            }
        }
    });
    
    document.addEventListener('keyup', (e) => {
        this.keys[e.key] = false;
    });
    
    // Setup power-up controls
    this.setupPowerUpControls();
    
    // Touch controls for swipe detection (mobile only)
    if (this.isMobile) {
        this.canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            this.touchStartX = touch.clientX;
            this.touchStartY = touch.clientY;
            this.touchStartTime = Date.now();
        });
        
        this.canvas.addEventListener('touchend', (e) => {
            const touchEndTime = Date.now();
            const touchDuration = touchEndTime - this.touchStartTime;
            
            if (e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - this.touchStartX;
                const deltaY = touch.clientY - this.touchStartY;
                const swipeSpeed = Math.abs(deltaX) / touchDuration;
                // Calculate dynamic bounds for swipes
                const aspectRatio = window.innerWidth / window.innerHeight;
                const vFov = this.camera.fov * Math.PI / 180;
                const cameraZ = this.camera.position.z;
                const playerZ = this.player.position.z;
                const distance = cameraZ - playerZ;
                const visibleHeight = 2 * Math.tan(vFov / 2) * distance;
                const visibleWidth = visibleHeight * aspectRatio;
                const spriteHalfWidth = 0.75;
                const boundLimit = (visibleWidth / 2) - spriteHalfWidth - 0.5;
                const mobileBoundLimit = this.isMobile ? Math.min(boundLimit, 3.5) : boundLimit;
                
                // Detect swipes
                if (touchDuration < 500) {
                    const isHorizontalSwipe = Math.abs(deltaX) > Math.abs(deltaY);
                    const isVerticalSwipe = Math.abs(deltaY) > Math.abs(deltaX);
                    
                    if (isHorizontalSwipe && Math.abs(deltaX) > 50 && swipeSpeed > 0.3) {
                        // Fast swipe triggers dash
                        if (this.dashCooldown <= 0) {
                            const dashDirection = deltaX > 0 ? 1 : -1;
                            this.dashVelocity = dashDirection * 8; // Fast dash speed
                            this.dashDuration = 0.3; // 300ms dash
                            this.dashCooldown = 1.0; // 1 second cooldown
                            this.playSound('push'); // Audio feedback
                        }
                    } else if (isHorizontalSwipe && Math.abs(deltaX) > 30) {
                        // Normal swipe - standard movement
                        const moveAmount = this.isMobile ? 1.0 : 1.5;
                        if (deltaX > 0) {
                            
                            this.player.position.x = Math.min(mobileBoundLimit, this.player.position.x + moveAmount);
                        } else {
                           
                            this.player.position.x = Math.max(-mobileBoundLimit, this.player.position.x - moveAmount);
                        }
                    }
                    
                    if (isVerticalSwipe && deltaY < -50 && !this.isJumping) {
                        // Swipe up - jump
                        this.jump();
                    }
                }
            }
        });
    }
         
        // Mobile button controls - PROPERLY ACTIVATED
        const jumpBtn = document.getElementById('jumpBtn');
        const shieldBtn = document.getElementById('shieldBtn');
        const pushBtn = document.getElementById('pushBtn');
        
        if (jumpBtn) {
            // Jump button
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!this.isJumping) {
                    this.jump();
                }
            });
            
            jumpBtn.addEventListener('click', (e) => {
                e.preventDefault();
                if (!this.isJumping) {
                    this.jump();
                }
            });
        }
        
        if (shieldBtn) {
            // Shield button - hold to activate
            shieldBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.touchControls.shield = true;
                this.player.shield.visible = true;
            });
            
            shieldBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                this.touchControls.shield = false;
                this.player.shield.visible = false;
            });
            
            shieldBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.touchControls.shield = true;
                this.player.shield.visible = true;
            });
            
            shieldBtn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                this.touchControls.shield = false;
                this.player.shield.visible = false;
            });
        }
        
        if (pushBtn) {
            // Push button
            pushBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.handlePush();
            });
            
            pushBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.handlePush();
            });
        }
        
        // Start button
        const startBtn = document.getElementById('startButton');
        if (startBtn) {
            startBtn.addEventListener('click', () => {
                this.startGame();
                this.trackEvent('game_started', {
                    device: this.isMobile ? 'mobile' : 'desktop',
                    quality: this.quality
                });
            });
        }
    }
    
    jump() {
        if (!this.isJumping) {
            this.isJumping = true;
            this.playerVelocityY = this.jumpVelocity;
            this.playSound('jump');
        }
    }
    
    setupAudio() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (error) {
            console.warn('Audio context creation failed:', error);
            this.audioInitialized = false;
            return;
        }
        
        // Create master gain nodes
        this.masterGainNode = this.audioContext.createGain();
        this.musicGainNode = this.audioContext.createGain();
        this.sfxGainNode = this.audioContext.createGain();
        
        // Connect audio graph
        this.musicGainNode.connect(this.masterGainNode);
        this.sfxGainNode.connect(this.masterGainNode);
        this.masterGainNode.connect(this.audioContext.destination);
                
        // Set initial volumes
        this.masterGainNode.gain.value = this.masterVolume;
        this.musicGainNode.gain.value = this.musicVolume;
        this.sfxGainNode.gain.value = this.sfxVolume;
        
        // Setup audio controls
        this.setupAudioControls();

        // Initialize background music WAV file
        this.backgroundMusic = new Audio('https://assets.codepen.io/t-24779/stain-slayer-background-loop.wav');
        this.backgroundMusic.loop = true;
        this.backgroundMusic.volume = 0.12; 
        this.backgroundMusic.preload = 'auto';
        
        // Handle loading errors gracefully
        this.backgroundMusic.addEventListener('error', () => {
            console.warn('Background music failed to load');
        });
        
        this.audioInitialized = true;
    }
    
   setupAudioControls() {
    const muteBtn = document.getElementById('muteBtn');
    const musicVolumeSlider = document.getElementById('musicVolume');
    const sfxVolumeSlider = document.getElementById('sfxVolume');
    
    // Ensure button exists before adding events
    if (!muteBtn) {
        console.warn('Audio mute button not found');
        return;
    }
    
    if (muteBtn) {
        const toggleAudio = () => {
            this.toggleGlobalMute();
            muteBtn.textContent = this.globalMuted ? '🔇' : '🔊';
            muteBtn.classList.toggle('muted', this.globalMuted);
        };
        
        // Add both click and touch events for cross-platform compatibility
        muteBtn.addEventListener('click', toggleAudio);
        muteBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleAudio();
        });

        // Ensure button is touchable on mobile
        muteBtn.style.touchAction = 'manipulation';
        muteBtn.style.userSelect = 'none';

        // Show/hide volume sliders on desktop
        if (!this.isMobile) {
            muteBtn.addEventListener('mouseenter', () => {
                if (volumeSliders) volumeSliders.classList.add('show');
            });
            
            document.querySelector('.audio-controls').addEventListener('mouseleave', () => {
                if (volumeSliders) volumeSliders.classList.remove('show');
            });
        }
    }
    
    if (musicVolumeSlider) {
        musicVolumeSlider.addEventListener('input', (e) => {
            this.musicVolume = e.target.value / 100;
            this.updateAudioLevels();
        });
    }
    
    if (sfxVolumeSlider) {
        sfxVolumeSlider.addEventListener('input', (e) => {
            this.sfxVolume = e.target.value / 100;
            this.updateAudioLevels();
        });
    }
}
    
    initializeStageMusicLoops() {
        // Create procedural music loops for each stage
        this.musicLoops = {
            rally: () => this.createRallyMusic(),
            street: () => this.createStreetMusic(),
            wedding: () => this.createWeddingMusic(),
            cricket: () => this.createCricketMusic(),
            debate: () => this.createDebateMusic()
        };
    }
    
    createRallyMusic() {
        // Political Rally - Drums and chants rhythm
        const now = this.audioContext.currentTime;
        const tempo = 120; // BPM
        const beatLength = 60 / tempo;
        const measureLength = beatLength * 4;
        
        // Create drum pattern
        for (let i = 0; i < 4; i++) {
            this.playDrum('kick', now + i * beatLength, 0.8);
            this.playDrum('snare', now + (i + 0.5) * beatLength, 0.6);
            if (i % 2 === 0) {
                this.playDrum('hihat', now + i * beatLength + beatLength/4, 0.4);
            }
        }
        
        // Add crowd chant simulation
        this.playChant(now, measureLength);
        
        // Schedule next loop
        this.currentMusicLoop = setTimeout(() => {
            if (this.isRunning && this.currentStage === 'rally') {
                this.createRallyMusic();
            }
        }, measureLength * 1000);
    }
    
    createStreetMusic() {
        // Street - Tabla and market sounds
        const now = this.audioContext.currentTime;
        const tempo = 100;
        const beatLength = 60 / tempo;
        const measureLength = beatLength * 8; // 8-beat cycle for tabla
        
        // Tabla pattern
        const tablaPattern = [1, 0, 0.5, 0, 1, 0.5, 0, 0.5];
        tablaPattern.forEach((volume, i) => {
            if (volume > 0) {
                this.playTabla(now + i * beatLength, volume);
            }
        });
        
        // Add ambient market sounds
        this.playAmbientSound('market', now, measureLength);
        
        // Schedule next loop
        this.currentMusicLoop = setTimeout(() => {
            if (this.isRunning && this.currentStage === 'street') {
                this.createStreetMusic();
            }
        }, measureLength * 1000);
    }
    
    createWeddingMusic() {
        // Wedding - Dhol and shehnai
        const now = this.audioContext.currentTime;
        const tempo = 140; // Faster, celebratory
        const beatLength = 60 / tempo;
        const measureLength = beatLength * 4;
        
        // Dhol pattern
        this.playDhol(now, measureLength);
        
        // Shehnai melody (simplified)
        const melody = [261.63, 293.66, 329.63, 349.23]; // C, D, E, F
        melody.forEach((freq, i) => {
            this.playShehnai(freq, now + i * beatLength, beatLength * 0.8);
        });
        
        // Schedule next loop
        this.currentMusicLoop = setTimeout(() => {
            if (this.isRunning && this.currentStage === 'wedding') {
                this.createWeddingMusic();
            }
        }, measureLength * 1000);
    }
    
    createCricketMusic() {
        // Cricket - Stadium atmosphere
        const now = this.audioContext.currentTime;
        const tempo = 130;
        const beatLength = 60 / tempo;
        const measureLength = beatLength * 4;
        
        // Stadium drums
        for (let i = 0; i < 4; i++) {
            this.playDrum('kick', now + i * beatLength, 1.0);
            this.playDrum('clap', now + (i + 0.5) * beatLength, 0.7);
        }
        
        // Crowd roar
        this.playCrowdRoar(now, measureLength);
        
        // Schedule next loop
        this.currentMusicLoop = setTimeout(() => {
            if (this.isRunning && this.currentStage === 'cricket') {
                this.createCricketMusic();
            }
        }, measureLength * 1000);
    }
    
    createDebateMusic() {
        // Debate - News tension music
        const now = this.audioContext.currentTime;
        const tempo = 90; // Slower, tense
        const beatLength = 60 / tempo;
        const measureLength = beatLength * 8;
        
        // Tension synth pad
        this.playTensionPad(now, measureLength);
        
        // Subtle percussion
        for (let i = 0; i < 8; i++) {
            if (i % 2 === 0) {
                this.playDrum('tick', now + i * beatLength, 0.3);
            }
        }
        
        // Schedule next loop
        this.currentMusicLoop = setTimeout(() => {
            if (this.isRunning && this.currentStage === 'debate') {
                this.createDebateMusic();
            }
        }, measureLength * 1000);
    }
    
    // Music instrument methods
    playDrum(type, time, volume) {
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.musicGainNode);
        
        switch(type) {
            case 'kick':
                osc.frequency.setValueAtTime(60, time);
                osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);
                filter.frequency.setValueAtTime(100, time);
                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                break;
            case 'snare':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, time);
                filter.frequency.setValueAtTime(1000, time);
                gain.gain.setValueAtTime(volume * 0.5, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                break;
            case 'hihat':
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, time);
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(5000, time);
                gain.gain.setValueAtTime(volume * 0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                break;
            case 'clap':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(1500, time);
                filter.frequency.setValueAtTime(2000, time);
                gain.gain.setValueAtTime(volume * 0.4, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.03);
                break;
            case 'tick':
                osc.frequency.setValueAtTime(1000, time);
                gain.gain.setValueAtTime(volume * 0.2, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.02);
                break;
        }
        
        osc.start(time);
        osc.stop(time + 0.5);
    }
    
    playTabla(time, volume) {
        const osc1 = this.audioContext.createOscillator();
        const osc2 = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc1.connect(gain);
        osc2.connect(gain);
        gain.connect(this.musicGainNode);
        
        // Tabla has complex harmonics
        osc1.frequency.setValueAtTime(90, time);
        osc2.frequency.setValueAtTime(180, time);
        
        gain.gain.setValueAtTime(volume * 0.6, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
        
        osc1.start(time);
        osc2.start(time);
        osc1.stop(time + 0.3);
        osc2.stop(time + 0.3);
    }
    
    playDhol(time, duration) {
        // Dhol - deep bass drum
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.connect(gain);
        gain.connect(this.musicGainNode);
        
        osc.frequency.setValueAtTime(50, time);
        osc.frequency.exponentialRampToValueAtTime(30, time + 0.2);
        
        gain.gain.setValueAtTime(0.7, time);
        gain.gain.setValueAtTime(0.7, time + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
        
        osc.start(time);
        osc.stop(time + 0.4);
    }
    
    playShehnai(frequency, time, duration) {
        // Shehnai - nasal wind instrument
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.musicGainNode);
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(frequency, time);
        
        // Add vibrato
        const vibrato = this.audioContext.createOscillator();
        const vibratoGain = this.audioContext.createGain();
        vibrato.connect(vibratoGain);
        vibratoGain.connect(osc.frequency);
        
        vibrato.frequency.setValueAtTime(5, time);
        vibratoGain.gain.setValueAtTime(frequency * 0.02, time);
        
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(frequency * 2, time);
        filter.Q.setValueAtTime(5, time);
        
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.3, time + 0.05);
        gain.gain.setValueAtTime(0.3, time + duration - 0.05);
        gain.gain.linearRampToValueAtTime(0, time + duration);
        
        osc.start(time);
        vibrato.start(time);
        osc.stop(time + duration);
        vibrato.stop(time + duration);
    }
    
    playChant(time, duration) {
        // Simulated crowd chant
        const frequencies = [130.81, 146.83, 164.81]; // C3, D3, E3
        
        frequencies.forEach((freq, i) => {
            const osc = this.audioContext.createOscillator();
            const gain = this.audioContext.createGain();
            const filter = this.audioContext.createBiquadFilter();
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.musicGainNode);
            
            osc.type = 'square';
            osc.frequency.setValueAtTime(freq, time + i * 0.2);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(500, time);
            
            gain.gain.setValueAtTime(0.2, time + i * 0.2);
            gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
            
            osc.start(time + i * 0.2);
            osc.stop(time + duration);
        });
    }
    
    playCrowdRoar(time, duration) {
        // White noise filtered for crowd effect
        const bufferSize = this.audioContext.sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        
        const source = this.audioContext.createBufferSource();
        const filter = this.audioContext.createBiquadFilter();
        const gain = this.audioContext.createGain();
        
        source.buffer = buffer;
        source.connect(filter);
        filter.connect(gain);
        gain.connect(this.musicGainNode);
        
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(300, time);
        filter.Q.setValueAtTime(1, time);
        
        gain.gain.setValueAtTime(0.15, time);
        
        source.start(time);
        source.stop(time + duration);
    }
    
    playTensionPad(time, duration) {
        // Low tension pad for debate
        const osc1 = this.audioContext.createOscillator();
        const osc2 = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.musicGainNode);
        
        osc1.type = 'sine';
        osc2.type = 'sine';
        osc1.frequency.setValueAtTime(65.41, time); // C2
        osc2.frequency.setValueAtTime(82.41, time); // E2
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, time);
        
        gain.gain.setValueAtTime(0.1, time);
        gain.gain.setValueAtTime(0.1, time + duration - 0.5);
        gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
        
        osc1.start(time);
        osc2.start(time);
        osc1.stop(time + duration);
        osc2.stop(time + duration);
    }
    
    playAmbientSound(type, time, duration) {
        // Placeholder for ambient sounds
        // In production, you'd load actual ambient audio files
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.connect(gain);
        gain.connect(this.musicGainNode);
        
        osc.frequency.setValueAtTime(100, time);
        gain.gain.setValueAtTime(0.05, time);
        
        osc.start(time);
        osc.stop(time + duration);
    }
    
    // Enhanced sound effects with variations
    initializeSoundVariations() {
        this.soundVariations = {
            block: [
                () => this.playBlockSound(523.25, 'sine'),
                () => this.playBlockSound(587.33, 'sine'),
                () => this.playBlockSound(659.25, 'sine')
            ],
            hit: [
                () => this.playHitSound(200, 'triangle'),
                () => this.playHitSound(150, 'sawtooth'),
                () => this.playHitSound(180, 'square')
            ],
            powerup: [
                () => this.playPowerUpSound(800),
                () => this.playPowerUpSound(1000),
                () => this.playPowerUpSound(1200)
            ]
        };
    }
    
    playBlockSound(frequency, waveType) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.sfxGainNode);
        
        oscillator.type = waveType;
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.1);
    }
    
    playHitSound(frequency, waveType) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.sfxGainNode);
        
        oscillator.type = waveType;
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(frequency * 2, this.audioContext.currentTime);
        
        gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.2);
    }
    
    playPowerUpSound(frequency) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.sfxGainNode);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(frequency * 2, this.audioContext.currentTime + 0.2);
        
        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + 0.3);
    }
    
    playSound(type) {
         if (!this.audioContext || !this.audioInitialized || this.globalMuted) return;
        
        // Play sound variations
        if (this.soundVariations[type]) {
            const variations = this.soundVariations[type];
            const randomVariation = variations[Math.floor(Math.random() * variations.length)];
            randomVariation();
        } else {
            // Fallback to original simple sounds
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(this.sfxGainNode);
            
            switch(type) {
                case 'jump':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    break;
                case 'push':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    break;
                default:
                    oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
            }
            
            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + 0.2);
        }
    }
    

   startStageMusic() {
     // Stop current music
     this.stopMusic();
     
     if (this.globalMuted) return;
     
    // Start WAV background music
    if (this.backgroundMusic) {
        this.backgroundMusic.currentTime = 0; // Reset to beginning
        this.backgroundMusic.volume = 0.12;
        this.backgroundMusic.play().catch(error => {
            console.warn('Background music play failed:', error);
        });
        console.log("🎵 Background music started");
    }
 }
 
 stopMusic() {
     if (this.currentMusicLoop) {
         clearInterval(this.currentMusicLoop);
         this.currentMusicLoop = null;
         console.log("🎵 Music loop stopped");
     }
 }
    
    async loadAssets() {
        // Simulate loading
        const progressFill = document.getElementById('progressFill');
        if (progressFill) {
            for (let i = 0; i <= 100; i += 10) {
                progressFill.style.width = i + '%';
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        // Create player and politician sprites
        this.createPlayer();
        this.createPolitician();
        this.createPodium('rally');
        // Load crowd sprites
        this.loadCrowdSprites();
        this.crowdSheetsReady = false;
    }
    
    createPlayer() {
        // Create sprite with texture
        const loader = new THREE.TextureLoader();
        const aideTexture = loader.load('https://assets.codepen.io/t-24779/aide_frontal_sheet1.png');
        
       // Mobile-responsive sprite sizing
        const spriteSize = this.isMobile ? 1.1 : 1.5;
        const geometry = new THREE.PlaneGeometry(spriteSize, spriteSize);
        const material = new THREE.MeshPhongMaterial({ 
            map: aideTexture,
            transparent: true,
            side: THREE.DoubleSide
        });
        
        this.player = new THREE.Mesh(geometry, material);
        this.player.position.set(0, this.groundY, 3);
        this.player.castShadow = true;
        this.player.receiveShadow = true;
        
        // Setup sprite animation
        this.player.frameIndex = 0;
        this.player.totalFrames = 12;
        this.player.animationTime = 0;
        
       // Enhanced FAB-branded shield with glow effect
this.player.shield = new THREE.Group();

// Main shield disc with FAB colors
const shieldGeometry = new THREE.RingGeometry(0.8, 1.2, 32);
const shieldMaterial = new THREE.MeshPhongMaterial({
    color: 0x00B4E6, // FAB brand blue
    transparent: true,
    opacity: 0.7,
    side: THREE.DoubleSide,
    emissive: 0x00B4E6,
    emissiveIntensity: 0.4
});
const shieldRing = new THREE.Mesh(shieldGeometry, shieldMaterial);
shieldRing.rotation.x = -Math.PI / 2; // Make it horizontal
this.player.shield.add(shieldRing);

// Outer glow ring
const glowGeometry = new THREE.RingGeometry(1.2, 1.6, 32);
const glowMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFD400, // FAB yellow accent
    transparent: true,
    opacity: 0.3,
    side: THREE.DoubleSide
});
const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
glowRing.rotation.x = -Math.PI / 2;
this.player.shield.add(glowRing);

// Inner energy core
const coreGeometry = new THREE.CircleGeometry(0.4, 16);
const coreMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide
});
const core = new THREE.Mesh(coreGeometry, coreMaterial);
core.rotation.x = -Math.PI / 2;
this.player.shield.add(core);

this.player.shield.position.set(0, 0, 0.3);
this.player.shield.visible = false;
this.player.add(this.player.shield);

// Store references for animation
this.player.shield.userData = {
    ring: shieldRing,
    glow: glowRing,
    core: core,
    pulseTime: 0
};

// Debug: Verify shield structure
console.log('Shield userData created:', this.player.shield.userData);
        
        // Load different direction sprites
        this.player.textures = {
            front: aideTexture,
            left: loader.load('https://assets.codepen.io/t-24779/aide_left_sheet2.png'),
            right: loader.load('https://assets.codepen.io/t-24779/aide_right_sheet3.png')
        };
        
        // Update UV mapping for sprite sheet
        this.updateSpriteFrame(this.player);
    }
    
    createPolitician() {
        // Create sprite with texture - LARGER SIZE
        const loader = new THREE.TextureLoader();
        const politicianTexture = loader.load('https://assets.codepen.io/t-24779/politician_front_sheet.png');
        
        const geometry = new THREE.PlaneGeometry(2.2, 2.6); // Increased size
        const material = new THREE.MeshPhongMaterial({ 
            map: politicianTexture,
            transparent: true,
            side: THREE.DoubleSide
        });
        
        this.politician = new THREE.Mesh(geometry, material);
        this.politician.position.set(0, 1.8, -2); // Higher position to be visible above podium
        this.politician.castShadow = true;
        this.politician.receiveShadow = true;
        
        // Setup sprite animation
        this.politician.frameIndex = 0;
        this.politician.totalFrames = 12;
        this.politician.animationTime = 0;
        
        // Load different direction sprites
        this.politician.textures = {
            front: politicianTexture,
            left: loader.load('https://assets.codepen.io/t-24779/politician_left_sheet.png'),
            right: loader.load('https://assets.codepen.io/t-24779/politician_right_sheet.png')
        };
        
        // Update UV mapping for sprite sheet
        this.updateSpriteFrame(this.politician);
    }
    
   createPodium(stage = 'rally') {
    // Remove existing podium if present
    if (this.podium) {
        this.scene.remove(this.podium);
    }
    
    const podiumGroup = new THREE.Group();
    
    // Select texture based on stage
    let podiumTexture;
    let podiumColor;
    
    switch(stage) {
        case 'rally':
            podiumTexture = this.createMarbleTexture();
            podiumColor = 0xF8F8FF;
            break;
        case 'street':
            podiumTexture = this.createWoodTexture();
            podiumColor = 0x8B4513;
            break;
        case 'wedding':
            podiumTexture = this.createOrnateWoodTexture();
            podiumColor = 0xD2691E;
            break;
        case 'cricket':
            podiumTexture = this.createWoodTexture();
            podiumColor = 0x654321;
            break;
        case 'debate':
            podiumTexture = this.createMetalTexture();
            podiumColor = 0xC0C0C0;
            break;
        default:
            podiumTexture = this.createWoodTexture();
            podiumColor = 0x8B4513;
    }
    
    // Enhanced podium box with stage-specific texture
    const podiumGeometry = new THREE.BoxGeometry(2.2, 1.6, 1.1);
    const podiumMaterial = new THREE.MeshPhongMaterial({ 
        map: podiumTexture,
        color: podiumColor,
        shininess: stage === 'debate' ? 100 : 30
    });
    const podiumBox = new THREE.Mesh(podiumGeometry, podiumMaterial);
    podiumBox.position.set(0, 0.8, -2);
    podiumBox.castShadow = true;
    podiumBox.receiveShadow = true;
    podiumGroup.add(podiumBox);
    
    // Enhanced podium details based on stage
    if (stage === 'rally' || stage === 'debate') {
        // Add metallic trim for formal stages
        const trimGeometry = new THREE.BoxGeometry(2.3, 0.1, 1.2);
        const trimMaterial = new THREE.MeshPhongMaterial({ 
            map: this.createMetalTexture(),
            color: 0xDAA520,
            shininess: 80
        });
        const trim = new THREE.Mesh(trimGeometry, trimMaterial);
        trim.position.set(0, 1.55, -2);
        podiumGroup.add(trim);
    }
    
    // Enhanced microphone stand
    const standGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1.6);
    const standMaterial = new THREE.MeshPhongMaterial({ 
        map: this.createMetalTexture(),
        color: 0x2F4F4F,
        shininess: 60
    });
    const stand = new THREE.Mesh(standGeometry, standMaterial);
    stand.position.set(0, 1.6, -1.4);
    podiumGroup.add(stand);
    
    // Enhanced microphone
    const micGeometry = new THREE.SphereGeometry(0.1, 12, 12);
    const micMaterial = new THREE.MeshPhongMaterial({ 
        map: this.createMetalTexture(),
        color: 0x1C1C1C,
        shininess: 90,
        emissive: 0x111111,
        emissiveIntensity: 0.2
    });
    const mic = new THREE.Mesh(micGeometry, micMaterial);
    mic.position.set(0, 2.4, -1.4);
    mic.castShadow = true;
    podiumGroup.add(mic);
    
    this.podium = podiumGroup;
}

 createStageFloor(stage = 'rally') {
        // Remove existing stage floor if present
        if (this.stageFloor) {
            this.scene.remove(this.stageFloor);
        }
        
        let floorTexture;
        let floorColor;
        
        switch(stage) {
            case 'rally':
                floorTexture = this.createMarbleTexture();
                floorColor = 0xF0F0F0;
                break;
            case 'street':
                floorTexture = this.createConcreteTexture();
                floorColor = 0x696969;
                break;
            case 'wedding':
                floorTexture = this.createDecorativeTileTexture();
                floorColor = 0xF5F5DC;
                break;
            case 'cricket':
                floorTexture = this.createWoodTexture();
                floorColor = 0x228B22;
                break;
            case 'debate':
                floorTexture = this.createMetalTexture();
                floorColor = 0x2F4F4F;
                break;
            default:
                floorTexture = this.createWoodTexture();
                floorColor = 0x654321;
        }
        
        // Enhanced floor with proper texture scaling
        const floorGeometry = new THREE.PlaneGeometry(20, 10);
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(4, 2);
        
        const floorMaterial = new THREE.MeshPhongMaterial({ 
            map: floorTexture,
            color: floorColor,
            shininess: stage === 'debate' ? 80 : 20
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        
        this.stageFloor = floor;
        return floor;
    }

   // Crowd System Implementation
    loadCrowdSprites() {
        const loader = new THREE.TextureLoader();
        this.loadedSheets = 0;
        this.totalSheets = 2;
        
        // Load crowd sprite sheets with error handling
        this.crowdSprites = {
           sheet1: null,
           sheet2: null
        };

       // Load sheet 1 with error handling
        this.crowdSprites.sheet1 = loader.load(
            'https://assets.codepen.io/t-24779/crowd_sheet_1.png',
            () => {
                console.log('✅ Crowd sheet 1 loaded successfully');
                this.loadedSheets++;
                if (this.loadedSheets === this.totalSheets) this.onAllCrowdSheetsLoaded();
            },
            undefined,
            () => console.error('❌ Failed to load crowd_sheet_1.png')
        );
        
        // Load sheet 2 with error handling
        this.crowdSprites.sheet2 = loader.load(
            'https://assets.codepen.io/t-24779/crowd_sheet_2.png',
            () => {
                console.log('✅ Crowd sheet 2 loaded successfully');
                this.loadedSheets++;
                if (this.loadedSheets === this.totalSheets) this.onAllCrowdSheetsLoaded();
            },
            undefined,
            () => console.error('❌ Failed to load crowd_sheet_2.png')
        );
       
        
        // Define crowd character types with animation data
        this.crowdTypes = {
            flag_bearer: { sheet: 'sheet1', frames: [0, 1, 2], duration: 250, energy: 'high' },
            sign_holder: { sheet: 'sheet1', frames: [3, 4, 5], duration: 250, energy: 'medium' },
            megaphone: { sheet: 'sheet1', frames: [6, 7, 8], duration: 200, energy: 'high' },
            angry: { sheet: 'sheet1', frames: [9, 10, 11], duration: 150, energy: 'high' },
            woman_clapping: { sheet: 'sheet2', frames: [0, 1, 2], duration: 350, energy: 'positive' },
            old_man: { sheet: 'sheet2', frames: [3, 4, 5], duration: 350, energy: 'calm' },
            angry_fist: { sheet: 'sheet2', frames: [6, 7, 8], duration: 350, energy: 'high' },
            tricolor_scarf: { sheet: 'sheet2', frames: [9, 10, 11], duration: 350, energy: 'positive' }
        };
    }

    onAllCrowdSheetsLoaded() {
        console.log('🎭 All crowd sheets loaded, creating initial crowd');
        this.crowdSheetsReady = true;
        if (this.currentStage === 'rally') {
            this.createStageSpecificCrowd('rally');
            // Create rally stage animations
            this.createAnimatedClouds();
        }
    }
    
    createCrowdMember(type, position, row) {
        const crowdData = this.crowdTypes[type];
      if (!crowdData || !this.crowdSprites[crowdData.sheet]) {
            console.warn(`Cannot create crowd member ${type}: missing data or texture`);
            return null;
        }
        
        // Create sprite geometry
        const geometry = new THREE.PlaneGeometry(1, 1);
        const material = new THREE.MeshPhongMaterial({
            map: this.crowdSprites[crowdData.sheet],
            transparent: true,
            side: THREE.DoubleSide
        });
        
        const crowdSprite = new THREE.Mesh(geometry, material);
        
        // Position based on row and position
        const rowDepth = -3.5 - (row * 0.8); // Behind podium but in camera view
        const scale = 1.4 - (row * 0.25); // Smaller with distance
        const spacing = scale * 1.6; // Tighter spacing for better distribution
        const positionsPerRow = 8; // Consistent 8 positions per row
        const totalWidth = (positionsPerRow - 1) * spacing;
        const startX = -totalWidth / 2; // Center around x=0 (podium position)
        
        crowdSprite.position.set(
            startX + (position * spacing) + (Math.random() - 0.5) * 0.2, // Less random offset
            0.5 + scale * 0.3 + (Math.random() * 0.1), // Consistent height,
            rowDepth + (Math.random() - 0.5) * 0.1
        );
        
        crowdSprite.scale.set(scale, scale, scale);
        
        // Animation properties
        crowdSprite.userData = {
            type: type,
            frames: crowdData.frames,
            currentFrame: Math.floor(Math.random() * 3),
            animationTime: Math.random() * (crowdData.duration / 1000),
            frameDuration: crowdData.duration / 1000,
            energy: crowdData.energy,
            baseY: crowdSprite.position.y,
            bobPhase: Math.random() * Math.PI * 2,
            row: row,
            reactionDelay: Math.random() * 1000
        };
        
        // Set initial UV mapping for sprite sheet
        this.updateCrowdSpriteFrame(crowdSprite);
        
        return crowdSprite;
    }
    
     updateCrowdSpriteFrame(sprite) {
        const userData = sprite.userData;
        const frameIndex = userData.frames[userData.currentFrame];
        const crowdData = this.crowdTypes[userData.type];
         
        let frameHeight, yOffset;
        
        if (crowdData.sheet === 'sheet1') {
            // Crowd sheet 1: 64px × 2304px = 36 frames (192px each)
            frameHeight = 1 / 36; // 36 total frames in sheet1
            yOffset = frameIndex * frameHeight;
        } else {
            // Crowd sheet 2: 64px × 768px = 12 frames (64px each)  
            frameHeight = 1 / 12; // 12 total frames in sheet2
            yOffset = frameIndex * frameHeight;
        }
         
         const uvAttribute = sprite.geometry.attributes.uv;
         if (uvAttribute) {
             uvAttribute.setXY(0, 0, 1 - yOffset);
             uvAttribute.setXY(1, 1, 1 - yOffset);
             uvAttribute.setXY(2, 0, 1 - yOffset - frameHeight);
             uvAttribute.setXY(3, 1, 1 - yOffset - frameHeight);
             uvAttribute.needsUpdate = true;
         }
     }
    
   createPoliticalRallyCrowd() {
    // Clear existing crowd
    this.crowdMembers.forEach(member => this.scene.remove(member));
    this.crowdMembers = [];
    
    console.log('Creating political rally crowd, current stage:', this.currentStage);
  
    // Check if crowd sheets are ready
    if (!this.crowdSheetsReady) {
        console.log('⏳ Crowd sheets not ready yet, skipping crowd creation');
        return;
    }

    // Device-responsive crowd composition
    const isCurrentlyMobile = window.innerWidth <= 768;
    
    const mobileRowCompositions = [
        // Mobile: 3 rows, 6 members each (total: ~18)
        ['megaphone', 'angry', 'flag_bearer', 'angry_fist', 'sign_holder', 'megaphone'],
        ['woman_clapping', 'tricolor_scarf', 'old_man', 'flag_bearer', 'angry_fist', 'woman_clapping'],
        ['old_man', 'tricolor_scarf', 'woman_clapping', 'tricolor_scarf', 'old_man', 'woman_clapping']
    ];
    
    const desktopRowCompositions = [
        // Desktop: 4 rows, 8 members each (total: ~32)
        ['megaphone', 'angry', 'flag_bearer', 'angry_fist', 'megaphone', 'sign_holder', 'angry', 'flag_bearer'],
        ['flag_bearer', 'woman_clapping', 'sign_holder', 'tricolor_scarf', 'angry_fist', 'old_man', 'megaphone', 'woman_clapping'],
        ['woman_clapping', 'tricolor_scarf', 'old_man', 'flag_bearer', 'woman_clapping', 'sign_holder', 'tricolor_scarf', 'old_man'],
        ['old_man', 'tricolor_scarf', 'woman_clapping', 'old_man', 'tricolor_scarf', 'woman_clapping', 'old_man', 'tricolor_scarf']
    ];
    
    const rowCompositions = isCurrentlyMobile ? mobileRowCompositions : desktopRowCompositions;
    
    // Create crowd members
    rowCompositions.forEach((rowTypes, rowIndex) => {
        rowTypes.forEach((type, position) => {
            const crowdMember = this.createCrowdMember(type, position, rowIndex);
            if (crowdMember) {
                this.crowdMembers.push(crowdMember);
                this.scene.add(crowdMember);
            }
        });
    });
    
    console.log(`Created ${this.crowdMembers.length} crowd members for political rally (${isCurrentlyMobile ? 'mobile' : 'desktop'} mode)`);
}
    
   updateCrowd(deltaTime) {
    if (this.crowdMembers.length === 0) return;

    // Desktop optimization: cache expensive calculations
    const isDesktop = !this.isMobile;
    const frameSkip = isDesktop ? 1 : 3; // Desktop processes every frame, mobile every 3rd
    
    this.crowdAnimationTime += deltaTime;
    this.crowdReactionTime += deltaTime;
    
    // Only update crowd reactions on appropriate frames
    if (Math.floor(this.crowdAnimationTime * 60) % frameSkip !== 0 && !isDesktop) return;
    
    // Check for crowd reactions to gameplay events
    const now = Date.now();
    if (now - this.lastBlockTime < 1000 && !this.crowdCheerActive) {
        this.triggerCrowdCheer();
    }

    // Desktop-optimized atmosphere effects
    if (typeof this.updateStageAtmosphereEffects === 'function') {
        if (isDesktop) {
            this.updateStageAtmosphereEffects(deltaTime, isDesktop);
        } else if (Math.floor(this.crowdAnimationTime * 60) % 5 === 0) {
            // Mobile: reduced frequency atmosphere effects
            this.updateStageAtmosphereEffects(deltaTime, false);
        }
    }
    
    // Update each crowd member
    this.crowdMembers.forEach(member => {
        const userData = member.userData;
        
        // Frame animation
        userData.animationTime += deltaTime;
        if (userData.animationTime >= userData.frameDuration) {
            userData.currentFrame = (userData.currentFrame + 1) % userData.frames.length;
            this.updateCrowdSpriteFrame(member);
            userData.animationTime = 0;
        }
        
        // Subtle bobbing animation - enhanced for desktop
        userData.bobPhase += deltaTime * (isDesktop ? 0.8 : 0.5);
        const bobAmount = userData.energy === 'high' ? (isDesktop ? 0.12 : 0.08) : (isDesktop ? 0.06 : 0.04);
        member.position.y = userData.baseY + Math.sin(userData.bobPhase) * bobAmount;
        
        // Crowd mood reactions - enhanced for desktop
        if (this.crowdCheerActive && userData.energy === 'high') {
            const reactionIntensity = isDesktop ? 0.15 : 0.1;
            member.position.y += Math.sin(this.crowdReactionTime * 3) * reactionIntensity;
        }
        
        // Responsive to crowd mood meter (rally stage)
        if (this.currentStage === 'rally' && this.crowdMood < 30) {
            // Angry crowd - more aggressive animation
            if (userData.energy === 'high') {
                userData.frameDuration = Math.max(0.1, userData.frameDuration * 0.8);
            }
        }
    });
    
    // Reset crowd cheer after duration
    if (this.crowdCheerActive && this.crowdReactionTime > 2) {
        this.crowdCheerActive = false;
        this.crowdReactionTime = 0;
    }
}
    
   triggerCrowdCheer() {
    this.crowdCheerActive = true;
    this.crowdReactionTime = 0;
    
    // Mobile-first device detection
    const isDesktop = window.innerWidth > 768;
    const particleMultiplier = isDesktop ? 2.5 : 1;
    const maxBurstParticles = Math.floor((isDesktop ? 12 : 5) * particleMultiplier);
    
    // Speed up animations of energetic crowd members
    this.crowdMembers.forEach(member => {
        if (member.userData.energy === 'high' || member.userData.energy === 'positive') {
            member.userData.frameDuration *= 0.5; // Double animation speed temporarily
            
            // Enhanced crowd reaction with vertical bounce
            const originalY = member.userData.baseY;
            member.userData.cheerBounce = true;
            member.userData.bouncePhase = Math.random() * Math.PI * 2;
        }
    });
    
    // Stage-specific celebration particle burst
    this.createCelebrationBurst(maxBurstParticles);
    
    // Enhanced audio feedback for desktop
    if (isDesktop) {
        this.playSound('block'); // Trigger additional block sound for crowd reaction
    }
    
    // Reset animation speeds and effects after cheer
    setTimeout(() => {
        this.crowdMembers.forEach(member => {
            const originalDuration = this.crowdTypes[member.userData.type].duration / 1000;
            member.userData.frameDuration = originalDuration;
            member.userData.cheerBounce = false;
        });
    }, 2000);
}

createCelebrationBurst(maxParticles) {
    const stageColors = {
        'rally': [0xFFD700, 0xFF6B35, 0xFF4500],
        'wedding': [0xFFB6C1, 0xFFC0CB, 0xFFE4E1, 0xF0E68C],
        'cricket': [0x0066CC, 0xFF6600, 0x228B22],
        'debate': [0x4169E1, 0x9370DB, 0xF5F5F5],
        'street': [0xFFD700, 0xFFA500, 0xFF7F50]
    };
    
    const colors = stageColors[this.currentStage] || stageColors['rally'];
    
    for (let i = 0; i < maxParticles; i++) {
        const particle = new THREE.Sprite(
            new THREE.SpriteMaterial({
                color: new THREE.Color(colors[Math.floor(Math.random() * colors.length)]),
                transparent: true,
                opacity: 0.8
            })
        );
        
        // Mobile-optimized particle size
        const size = (window.innerWidth > 768) ? (0.08 + Math.random() * 0.04) : (0.06 + Math.random() * 0.02);
        particle.scale.set(size, size, 1);
        
        // Spawn from crowd area
        particle.position.set(
            (Math.random() - 0.5) * 8,
            1 + Math.random() * 1.5,
            -4 - Math.random() * 2
        );
        
        // Burst velocity - outward from crowd
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.5 + Math.random() * 1.5;
        particle.velocity = new THREE.Vector3(
            Math.cos(angle) * speed,
            1 + Math.random() * 1.5,
            Math.sin(angle) * speed * 0.3
        );
        
        particle.rotationSpeed = (Math.random() - 0.5) * 0.2;
        particle.lifetime = 2 + Math.random() * 1.5;
        particle.gravity = -1.2;
        
        this.scene.add(particle);
        this.animateCelebrationParticle(particle);
    }
}

animateCelebrationParticle(particle) {
    const animate = () => {
        if (particle.lifetime <= 0 || !particle.parent) {
            this.scene.remove(particle);
            return;
        }
        
        // Physics update
        particle.position.add(particle.velocity.clone().multiplyScalar(0.016));
        particle.velocity.y += particle.gravity * 0.016;
        particle.lifetime -= 0.016;
        
        // Visual effects
        particle.material.opacity = Math.max(0, particle.lifetime / 3);
        particle.rotation.z += particle.rotationSpeed;
        
        // Continue animation
        requestAnimationFrame(animate);
    };
    animate();
}

updateStageAtmosphereEffects(deltaTime, isDesktop) {
        // Mobile-first spawn rates - desktop gets 3x more particles
        const baseSpawnRate = isDesktop ? 0.008 : 0.003;
        const stageMultiplier = {
            'rally': 1.5,        // More energetic
            'wedding': 1.3,      // More noticeable
            'cricket': 1.4,      // More exciting
            'debate': 0.9,       // Still visible but minimal
            'street': 1.2        // More visible dust
        };
        
        const finalSpawnRate = baseSpawnRate * (stageMultiplier[this.currentStage] || 1.0);
        
        switch(this.currentStage) {
            case 'rally':
                this.createRallyAtmosphere(finalSpawnRate, isDesktop);
                break;
            case 'wedding':
                this.createWeddingAtmosphere(finalSpawnRate, isDesktop);
                break;
            case 'cricket':
                this.createCricketAtmosphere(finalSpawnRate, isDesktop);
                break;
            case 'debate':
                this.createDebateAtmosphere(finalSpawnRate, isDesktop);
                break;
            case 'street':
                this.createStreetAtmosphere(finalSpawnRate, isDesktop);
                break;
        }
    }
    
    createRallyAtmosphere(spawnRate, isDesktop) {
        if (Math.random() < spawnRate) {
            // Flag particles floating upward
            const colors = [0xFFD700, 0xFF6B35, 0xFFFFFF]; // Gold, orange, white
            const particle = new THREE.Sprite(
                new THREE.SpriteMaterial({
                    color: new THREE.Color(colors[Math.floor(Math.random() * colors.length)]),
                    transparent: true,
                    opacity: isDesktop ? 0.8 : 0.6 // Much more visible
                })
            );
            
            const size = isDesktop ? (0.08 + Math.random() * 0.04) : (0.06 + Math.random() * 0.02); // Doubled size
            particle.scale.set(size, size * 0.6, 1); // Rectangular flag shape
            
            particle.position.set(
                (Math.random() - 0.5) * (isDesktop ? 7 : 5),
                1.2 + Math.random() * 1.2,
                -4.5 - Math.random() * 1.5
            );
            
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                0.3 + Math.random() * 0.2,
                (Math.random() - 0.5) * 0.1
            );
            
            particle.wavePhase = Math.random() * Math.PI * 2;
            particle.lifetime = isDesktop ? (4 + Math.random() * 2) : (3 + Math.random() * 1);
            
            this.scene.add(particle);
            this.animateAtmosphereParticle(particle, 'flag');
        }
    }
    
    createWeddingAtmosphere(spawnRate, isDesktop) {
        if (Math.random() < spawnRate) {
            // Flower petals falling gently
            const colors = [0xFFB6C1, 0xFFC0CB, 0xFFE4E1, 0xF0E68C];
            const particle = new THREE.Sprite(
                new THREE.SpriteMaterial({
                    color: new THREE.Color(colors[Math.floor(Math.random() * colors.length)]),
                    transparent: true,
                    opacity: isDesktop ? 0.8 : 0.65 // More visible
                })
            );
            
            const size = isDesktop ? (0.06 + Math.random() * 0.03) : (0.05 + Math.random() * 0.02); // Doubled size
            particle.scale.set(size, size, 1);
            
            particle.position.set(
                (Math.random() - 0.5) * (isDesktop ? 6 : 4),
                3 + Math.random() * 0.5,
                -3.5 - Math.random() * 2
            );
            
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.15,
                -0.15 - Math.random() * 0.1,
                0
            );
            
            particle.rotationSpeed = (Math.random() - 0.5) * 0.03;
            particle.swayPhase = Math.random() * Math.PI * 2;
            particle.lifetime = isDesktop ? (5 + Math.random() * 3) : (4 + Math.random() * 2);
            
            this.scene.add(particle);
            this.animateAtmosphereParticle(particle, 'petal');
        }
    }
   
    createCricketAtmosphere(spawnRate, isDesktop) {
        if (Math.random() < spawnRate) {
            // Team streamers waving
            const teamColors = [0x0066CC, 0xFF6600]; // Blue and orange
            const particle = new THREE.Sprite(
                new THREE.SpriteMaterial({
                    color: new THREE.Color(teamColors[Math.floor(Math.random() * teamColors.length)]),
                    transparent: true,
                    opacity: isDesktop ? 0.7 : 0.5 // More visible
                })
            );
            
            const size = isDesktop ? (0.1 + Math.random() * 0.05) : (0.08 + Math.random() * 0.03); // Much larger
            particle.scale.set(size, size * 0.3, 1); // Streamer shape
            
            particle.position.set(
                (Math.random() - 0.5) * (isDesktop ? 8 : 6),
                2 + Math.random() * 1.5,
                -4 - Math.random() * 2
            );
            
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.4,
                0.1 + Math.random() * 0.2,
                0
            );
            
            particle.wavePhase = Math.random() * Math.PI * 2;
            particle.lifetime = isDesktop ? (3 + Math.random() * 2) : (2.5 + Math.random() * 1);
            
            this.scene.add(particle);
            this.animateAtmosphereParticle(particle, 'streamer');
        }
    }
    
    createDebateAtmosphere(spawnRate, isDesktop) {
        if (Math.random() < spawnRate) {
            // Subtle paper/document particles
            const particle = new THREE.Sprite(
                new THREE.SpriteMaterial({
                    color: new THREE.Color(0xF8F8FF),
                    transparent: true,
                    opacity: isDesktop ? 0.5 : 0.35 // More visible even in debate
                })
            );
            
            const size = isDesktop ? (0.05 + Math.random() * 0.025) : (0.04 + Math.random() * 0.02); // Doubled
            particle.scale.set(size, size * 1.4, 1); // Paper rectangle shape
            
            particle.position.set(
                (Math.random() - 0.5) * (isDesktop ? 5 : 3),
                2.5 + Math.random() * 0.5,
                -3 - Math.random() * 1.5
            );
            
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.08,
                -0.05 - Math.random() * 0.03,
                0
            );
            
            particle.rotationSpeed = (Math.random() - 0.5) * 0.02;
            particle.lifetime = isDesktop ? (6 + Math.random() * 4) : (5 + Math.random() * 2);
            
            this.scene.add(particle);
            this.animateAtmosphereParticle(particle, 'paper');
        }
    }
    
    createStreetAtmosphere(spawnRate, isDesktop) {
        if (Math.random() < spawnRate) {
            // Light dust particles
            const particle = new THREE.Sprite(
                new THREE.SpriteMaterial({
                    color: new THREE.Color(0xD2B48C),
                    transparent: true,
                    opacity: isDesktop ? 0.6 : 0.45 // Much more visible
                })
            );
            
            const size = isDesktop ? (0.04 + Math.random() * 0.02) : (0.03 + Math.random() * 0.015); // Doubled
            particle.scale.set(size, size, 1);
            
            particle.position.set(
                (Math.random() - 0.5) * (isDesktop ? 7 : 5),
                1.8 + Math.random() * 1,
                -3.5 - Math.random() * 1.8
            );
            
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.25,
                0.08 + Math.random() * 0.12,
                0
            );
            
            particle.driftPhase = Math.random() * Math.PI * 2;
            particle.lifetime = isDesktop ? (4 + Math.random() * 3) : (3 + Math.random() * 2);
            
            this.scene.add(particle);
            this.animateAtmosphereParticle(particle, 'dust');
        }
    }
    
    animateAtmosphereParticle(particle, type) {
        const animate = () => {
            if (particle.lifetime <= 0 || !particle.parent) {
                this.scene.remove(particle);
                return;
            }
            
            // Basic physics
            particle.position.add(particle.velocity.clone().multiplyScalar(0.016));
            particle.lifetime -= 0.016;
            
            // Type-specific animations
            switch(type) {
                case 'flag':
                    particle.wavePhase += 0.1;
                    particle.position.x += Math.sin(particle.wavePhase) * 0.002;
                    particle.velocity.y -= 0.003; // Light gravity
                    break;
                case 'petal':
                    particle.swayPhase += 0.05;
                    particle.position.x += Math.sin(particle.swayPhase) * 0.001;
                    particle.velocity.y -= 0.008; // More gravity
                    if (particle.rotationSpeed) {
                        particle.rotation.z += particle.rotationSpeed;
                    }
                    break;
                case 'streamer':
                    particle.wavePhase += 0.08;
                    particle.position.y += Math.sin(particle.wavePhase) * 0.002;
                    particle.velocity.y -= 0.004;
                    break;
                case 'paper':
                    particle.velocity.y -= 0.006;
                    if (particle.rotationSpeed) {
                        particle.rotation.z += particle.rotationSpeed;
                    }
                    break;
                case 'dust':
                    particle.driftPhase += 0.03;
                    particle.position.x += Math.sin(particle.driftPhase) * 0.001;
                    particle.velocity.y -= 0.002;
                    break;
            }
            
            // Fade out over time
            particle.material.opacity *= 0.9985;
            
            requestAnimationFrame(animate);
        };
        animate();
    }
    
    createStageSpecificCrowd(stage) {
        // Clear existing crowd first
        this.crowdMembers.forEach(member => this.scene.remove(member));
        this.crowdMembers = [];
        console.log('Creating crowd for stage:', stage);

         if (!this.crowdSheetsReady) {
            console.log('⏳ Crowd sheets not ready, deferring crowd creation');
            return;
        }
        
        switch(stage) {
            case 'rally':
                this.createPoliticalRallyCrowd();
                break;
            case 'street':
                this.createStreetCrowd();
                break;
            case 'wedding':
                this.createWeddingCrowd();
                break;
            case 'cricket':
                this.createCricketCrowd();
                break;
            case 'debate':
                this.createDebateCrowd();
                break;
        }
    }
    
 createStreetCrowd() {
    // Sparse pedestrians for street stage
    const streetTypes = ['old_man', 'woman_clapping', 'tricolor_scarf'];
    
    const isCurrentlyMobile = window.innerWidth <= 768;
    
    const mobileStreetPositions = [
        // Mobile: 6 pedestrians for performance
        [-2, 0], [-1, 0], [0, 0], [1, 0], [2, 0], [0, 1]
    ];
    
    const desktopStreetPositions = [
        // Desktop: 8 pedestrians (your current setup)
        [-3, 0], [-1.5, 0], [0, 0], [1.5, 0], [3, 0], [-2, 1], [2, 1], [0, 1]
    ];
    
    const streetPositions = isCurrentlyMobile ? mobileStreetPositions : desktopStreetPositions;
    
    streetPositions.forEach((pos, i) => {
        const type = streetTypes[Math.floor(Math.random() * streetTypes.length)];
        const crowdMember = this.createCrowdMember(type, 0, 0); // Use custom positioning
        if (crowdMember) {
            crowdMember.position.x = pos[0];
            crowdMember.position.z = -4 - pos[1];
            this.crowdMembers.push(crowdMember);
            this.scene.add(crowdMember);
        }
    });
    
    console.log(`Created ${streetPositions.length} street pedestrians (${isCurrentlyMobile ? 'mobile' : 'desktop'} mode)`);
}
    
    createWeddingCrowd() {
        // Seated wedding guests
        const weddingTypes = ['woman_clapping', 'old_man', 'tricolor_scarf'];
          for (let row = 0; row < 4; row++) {
          for (let seat = 0; seat < 8; seat++) { // Increased seats per row
                const type = weddingTypes[Math.floor(Math.random() * weddingTypes.length)];
                const crowdMember = this.createCrowdMember(type, seat, row);
                if (crowdMember) {
                    this.crowdMembers.push(crowdMember);
                    this.scene.add(crowdMember);
                }
            }
        }
    }
    
    createCricketCrowd() {
        // Stadium crowd with team supporters
        const cricketTypes = ['flag_bearer', 'megaphone', 'woman_clapping', 'angry', 'tricolor_scarf'];
        for (let row = 0; row < 4; row++) {
            for (let pos = 0; pos < 8; pos++) {
                const type = cricketTypes[Math.floor(Math.random() * cricketTypes.length)];
                const crowdMember = this.createCrowdMember(type, pos, row);
                if (crowdMember) {
                    this.crowdMembers.push(crowdMember);
                    this.scene.add(crowdMember);
                }
            }
        }
    }
    
  createDebateCrowd() {
    // Small studio audience
    const debateTypes = ['old_man', 'woman_clapping', 'tricolor_scarf'];
    
    const isCurrentlyMobile = window.innerWidth <= 768;
    
    const mobileDebateSeating = [
        // Mobile: 8 seats spread across stage width
        [-3, 0], [-1, 0], [1, 0], [3, 0], // Front row - 4 seats (wide spread)
        [-3.5, 1], [-1.5, 1], [1.5, 1], [3.5, 1] // Back row - 4 seats (wider spread)
    ];
    
    const desktopDebateSeating = [
        // Desktop: 14 seats spread across full stage width
        [-4, 0], [-2.5, 0], [-1, 0], [1, 0], [2.5, 0], [4, 0], // Front row - 6 seats
        [-4.5, 1], [-3, 1], [-1.5, 1], [0, 1], [1.5, 1], [3, 1], [4.5, 1], // Back row - 7 seats  
        [-2, 2] // VIP center - 1 seat
    ];
    
    const debateSeating = isCurrentlyMobile ? mobileDebateSeating : desktopDebateSeating;
    
    debateSeating.forEach((seat, i) => {
        const type = debateTypes[Math.floor(Math.random() * debateTypes.length)];
        const crowdMember = this.createCrowdMember(type, 0, 0); // Use custom positioning
        if (crowdMember) {
            crowdMember.position.x = seat[0];
            crowdMember.position.z = -4 - seat[1] * 1.5;
            this.crowdMembers.push(crowdMember);
            this.scene.add(crowdMember);
        }
    });
    
    console.log(`Created ${debateSeating.length} debate audience members (${isCurrentlyMobile ? 'mobile' : 'desktop'} mode)`);
}


// Animated Cloud System for Rally Stage
  createCloudTexture(cloudType = 1) {
    const canvas = document.createElement('canvas');
    canvas.width = 192;  // Increased from 128 for larger clouds
    canvas.height = 96;  // Increased from 64
    const ctx = canvas.getContext('2d');
    
    // Clear background (transparent)
    ctx.clearRect(0, 0, 192, 96);
    
    // Lighter cloud color with reduced opacity
    const gradient = ctx.createRadialGradient(96, 48, 15, 96, 48, 70);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');  // Reduced from 0.9
    gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.25)'); // Reduced from 0.6
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');   // Reduced from 0.2
    
    ctx.fillStyle = gradient;
    
    // Larger cloud shapes based on type
    switch(cloudType) {
        case 1:
            // Fluffy cumulus cloud - larger
            ctx.beginPath();
            ctx.arc(45, 48, 22, 0, Math.PI * 2);   // Increased sizes
            ctx.arc(75, 38, 28, 0, Math.PI * 2);
            ctx.arc(105, 45, 25, 0, Math.PI * 2);
            ctx.arc(135, 52, 22, 0, Math.PI * 2);
            ctx.fill();
            break;
        case 2:
            // Stretched cloud - larger
            ctx.beginPath();
            ctx.arc(38, 48, 18, 0, Math.PI * 2);
            ctx.arc(68, 42, 24, 0, Math.PI * 2);
            ctx.arc(98, 45, 21, 0, Math.PI * 2);
            ctx.arc(128, 51, 18, 0, Math.PI * 2);
            ctx.arc(150, 54, 15, 0, Math.PI * 2);
            ctx.fill();
            break;
        case 3:
            // Small wispy cloud - larger
            ctx.beginPath();
            ctx.arc(60, 48, 15, 0, Math.PI * 2);
            ctx.arc(83, 45, 18, 0, Math.PI * 2);
            ctx.arc(105, 50, 14, 0, Math.PI * 2);
            ctx.fill();
            break;
    }
    
    return new THREE.CanvasTexture(canvas);
}
    
  createAnimatedClouds() {
    // Only create clouds for rally stage
    if (this.currentStage !== 'rally') return;
    
    // Clear existing clouds
    this.cloudSprites.forEach(cloud => this.scene.remove(cloud));
    this.cloudSprites = [];
    
    // Device-responsive cloud count
    const isCurrentlyMobile = window.innerWidth <= 768;
    const cloudCount = isCurrentlyMobile ? 4 : 6;
    
    for (let i = 0; i < cloudCount; i++) {
        const cloudType = Math.floor(Math.random() * 3) + 1;
        const cloudTexture = this.createCloudTexture(cloudType);
        
        const cloudMaterial = new THREE.SpriteMaterial({
            map: cloudTexture,
            transparent: true,
            opacity: 0.5  // Reduced from 0.7 for lighter appearance
        });
        
        const cloudSprite = new THREE.Sprite(cloudMaterial);
        
        // Much larger scale for more natural appearance
        const scale = isCurrentlyMobile ? (3 + Math.random() * 2) : (4 + Math.random() * 3); // Increased from 1.5-2/2-3.5
        cloudSprite.scale.set(scale, scale * 0.6, 1);
        
        // More spread out positioning across wider area
        cloudSprite.position.set(
            (Math.random() - 0.5) * 35, // Increased spread from 20 to 35
            5 + Math.random() * 3,      // Higher sky position
            -12 - Math.random() * 8     // Further back, increased from -8 to -12
        );
        
        // Cloud movement properties
        cloudSprite.userData = {
            speed: 0.3 + Math.random() * 0.5, // Slower, more natural movement
            initialX: cloudSprite.position.x,
            driftRange: 20 + Math.random() * 15, // Larger drift range
            bobPhase: Math.random() * Math.PI * 2,
            bobAmount: 0.05 + Math.random() * 0.05 // Gentler bobbing
        };
        
        this.cloudSprites.push(cloudSprite);
        this.scene.add(cloudSprite);
    }
    
    console.log(`Created ${cloudCount} animated clouds for rally stage`);
}
    
   updateAnimatedClouds(deltaTime) {
    // CRITICAL: Remove clouds immediately if not in rally stage
    if (this.currentStage !== 'rally') {
        if (this.cloudSprites.length > 0) {
            console.log(`🌥️ Removing ${this.cloudSprites.length} clouds - wrong stage: ${this.currentStage}`);
            this.removeAnimatedClouds();
        }
        return; // Exit completely
    }
    
    // Only animate if we have clouds and are in rally stage
    if (this.cloudSprites.length === 0) return;
    
    this.cloudAnimationTime += deltaTime;
    
    this.cloudSprites.forEach((cloud, index) => {
        const userData = cloud.userData;
        
        // Horizontal drift movement
        cloud.position.x += userData.speed * deltaTime;
        
        // Vertical bobbing motion
        userData.bobPhase += deltaTime * 0.5;
        cloud.position.y += Math.sin(userData.bobPhase) * userData.bobAmount * deltaTime;
        
        // Reset position when cloud drifts too far
        if (cloud.position.x > userData.initialX + userData.driftRange) {
            cloud.position.x = userData.initialX - userData.driftRange;
            cloud.position.y = 5 + Math.random() * 3;
        }
    });
}
    
 removeAnimatedClouds() {
    if (this.cloudSprites.length > 0) {
        console.log(`🗑️ Cleaning up ${this.cloudSprites.length} cloud sprites`);
    }
    
    // Clean up clouds when leaving rally stage
    this.cloudSprites.forEach(cloud => {
        this.scene.remove(cloud);
        // Clean up texture memory
        if (cloud.material.map) {
            cloud.material.map.dispose();
        }
        cloud.material.dispose();
    });
    this.cloudSprites = [];
}

     // Enhanced Texture System
    createMarbleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Base marble color
        const gradient = ctx.createLinearGradient(0, 0, 512, 512);
        gradient.addColorStop(0, '#F8F8FF');
        gradient.addColorStop(0.3, '#E6E6FA');
        gradient.addColorStop(0.7, '#D3D3D3');
        gradient.addColorStop(1, '#C0C0C0');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);
        
        // Add marble veining
        ctx.strokeStyle = 'rgba(105, 105, 105, 0.3)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 15; i++) {
            ctx.beginPath();
            const startX = Math.random() * 512;
            const startY = Math.random() * 512;
            let currentX = startX;
            let currentY = startY;
            
            ctx.moveTo(currentX, currentY);
            for (let j = 0; j < 20; j++) {
                currentX += (Math.random() - 0.5) * 40;
                currentY += (Math.random() - 0.5) * 40;
                ctx.lineTo(currentX, currentY);
            }
            ctx.stroke();
        }
        
        // Fine marble details
        ctx.strokeStyle = 'rgba(169, 169, 169, 0.2)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 25; i++) {
            ctx.beginPath();
            ctx.moveTo(Math.random() * 512, Math.random() * 512);
            ctx.lineTo(Math.random() * 512, Math.random() * 512);
            ctx.stroke();
        }
        
        return new THREE.CanvasTexture(canvas);
    }
    
    createOrnateWoodTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Rich wood base
        const gradient = ctx.createLinearGradient(0, 0, 512, 512);
        gradient.addColorStop(0, '#8B4513');
        gradient.addColorStop(0.2, '#A0522D');
        gradient.addColorStop(0.5, '#CD853F');
        gradient.addColorStop(0.8, '#D2691E');
        gradient.addColorStop(1, '#8B4513');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);
        
        // Wood grain pattern
        ctx.strokeStyle = 'rgba(101, 67, 33, 0.6)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 512; i += 12) {
            ctx.beginPath();
            ctx.moveTo(0, i + Math.sin(i * 0.02) * 8);
            ctx.lineTo(512, i + Math.sin(i * 0.02) * 8);
            ctx.stroke();
        }
        
        // Ornate carved details
        ctx.fillStyle = 'rgba(160, 82, 45, 0.8)';
        for (let i = 0; i < 8; i++) {
            const x = (i % 4) * 128 + 64;
            const y = Math.floor(i / 4) * 256 + 128;
            
            // Decorative rosette
            ctx.beginPath();
            for (let j = 0; j < 8; j++) {
                const angle = (j / 8) * Math.PI * 2;
                const px = x + Math.cos(angle) * 20;
                const py = y + Math.sin(angle) * 20;
                if (j === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.fill();
        }
        
        return new THREE.CanvasTexture(canvas);
    }
    
    createMetalTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Brushed metal base
        const gradient = ctx.createLinearGradient(0, 0, 512, 0);
        gradient.addColorStop(0, '#C0C0C0');
        gradient.addColorStop(0.5, '#A8A8A8');
        gradient.addColorStop(1, '#909090');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);
        
        // Brushed metal lines
        ctx.strokeStyle = 'rgba(192, 192, 192, 0.8)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 512; i += 2) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i + Math.random() * 20 - 10, 512);
            ctx.stroke();
        }
        
        // Metal highlights
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 100; i++) {
            ctx.beginPath();
            ctx.moveTo(Math.random() * 512, Math.random() * 512);
            ctx.lineTo(Math.random() * 512, Math.random() * 512);
            ctx.stroke();
        }
        
        return new THREE.CanvasTexture(canvas);
    }
    
    createConcreteTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Concrete base color
        ctx.fillStyle = '#808080';
        ctx.fillRect(0, 0, 512, 512);
        
        // Concrete aggregate texture
        for (let i = 0; i < 2000; i++) {
            const size = Math.random() * 4 + 1;
            const x = Math.random() * 512;
            const y = Math.random() * 512;
            const shade = Math.random() * 100 + 100;
            
            ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Concrete cracks
        ctx.strokeStyle = 'rgba(96, 96, 96, 0.5)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            const startX = Math.random() * 512;
            const startY = Math.random() * 512;
            let currentX = startX;
            let currentY = startY;
            
            ctx.moveTo(currentX, currentY);
            for (let j = 0; j < 15; j++) {
                currentX += (Math.random() - 0.5) * 30;
                currentY += (Math.random() - 0.5) * 30;
                ctx.lineTo(currentX, currentY);
            }
            ctx.stroke();
        }
        
        return new THREE.CanvasTexture(canvas);
    }
    
    createDecorativeTileTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Tile pattern base
        ctx.fillStyle = '#F5F5DC';
        ctx.fillRect(0, 0, 512, 512);
        
        // Create decorative tile pattern
        const tileSize = 64;
        for (let x = 0; x < 512; x += tileSize) {
            for (let y = 0; y < 512; y += tileSize) {
                // Tile border
                ctx.strokeStyle = '#D2691E';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, tileSize, tileSize);
                
                // Decorative pattern in each tile
                ctx.fillStyle = '#DEB887';
                ctx.beginPath();
                ctx.arc(x + tileSize/2, y + tileSize/2, tileSize/4, 0, Math.PI * 2);
                ctx.fill();
                
                // Corner decorations
                ctx.fillStyle = '#CD853F';
                const cornerSize = 8;
                ctx.fillRect(x, y, cornerSize, cornerSize);
                ctx.fillRect(x + tileSize - cornerSize, y, cornerSize, cornerSize);
                ctx.fillRect(x, y + tileSize - cornerSize, cornerSize, cornerSize);
                ctx.fillRect(x + tileSize - cornerSize, y + tileSize - cornerSize, cornerSize, cornerSize);
            }
        }
        
        return new THREE.CanvasTexture(canvas);
    }
    
    
    createWoodTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // Wood grain effect
        const gradient = ctx.createLinearGradient(0, 0, 256, 256);
        gradient.addColorStop(0, '#8B4513');
        gradient.addColorStop(0.3, '#A0522D');
        gradient.addColorStop(0.7, '#8B4513');
        gradient.addColorStop(1, '#654321');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 256);
        
        // Add wood grain lines
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 256; i += 8) {
            ctx.beginPath();
            ctx.moveTo(0, i + Math.random() * 4);
            ctx.lineTo(256, i + Math.random() * 4);
            ctx.stroke();
        }
        
        return new THREE.CanvasTexture(canvas);
    }
    
    updateSpriteFrame(sprite) {
        if (!sprite.geometry || !sprite.geometry.attributes.uv) return;
        
        const frameHeight = 1 / sprite.totalFrames;
        const yOffset = sprite.frameIndex * frameHeight;
        
        const uvAttribute = sprite.geometry.attributes.uv;
        uvAttribute.setXY(0, 0, 1 - yOffset);
        uvAttribute.setXY(1, 1, 1 - yOffset);
        uvAttribute.setXY(2, 0, 1 - yOffset - frameHeight);
        uvAttribute.setXY(3, 1, 1 - yOffset - frameHeight);
        uvAttribute.needsUpdate = true;
    }
    
    animateSprite(sprite, deltaTime, state = 'idle') {
        sprite.animationTime += deltaTime;
        
        // Different animation speeds for different states
        let frameRate = 0.1;
        if (state === 'shield') frameRate = 0.15;
        if (state === 'push') frameRate = 0.05;
        if (state === 'victory') frameRate = 0.08;
        if (state === 'jump') frameRate = 0.08;
        
        if (sprite.animationTime > frameRate) {
            sprite.frameIndex = (sprite.frameIndex + 1) % sprite.totalFrames;
            this.updateSpriteFrame(sprite);
            sprite.animationTime = 0;
        }
    }
    
  createStageBackground(stageName) {
    // Remove old background
    if (this.stageGroup) {
        this.scene.remove(this.stageGroup);
    }
    
    this.stageGroup = new THREE.Group();
    
    // Set scene background color per stage
    switch(stageName) {
        case 'rally':
            this.scene.background = new THREE.Color(0x87CEEB); // Sky blue for rally
            break;
        case 'street':
            this.scene.background = new THREE.Color(0x696969); // Gray for street
            break;
        case 'wedding':
            this.scene.background = new THREE.Color(0xFFB6C1); // Pink for wedding
            break;
        case 'cricket':
            this.scene.background = new THREE.Color(0x228B22); // Green for cricket field
            break;
        case 'debate':
            this.scene.background = new THREE.Color(0x191970); // Dark blue for studio
            break;
        default:
            this.scene.background = new THREE.Color(0x000000); // Black fallback
    }
    
    // Enhanced stage floor (your existing floor creation code)
    const stageFloor = this.createStageFloor(stageName);
    this.stageGroup.add(stageFloor);
    
    this.scene.add(this.stageGroup);
}
    
  createProjectile() {
    // Expanded emoji sets with 5 more aggressive/demeaning projectiles per stage
    const projectileEmojis = {
        'rally': ['🍅', '🥚', '👞', '🥤', '🍌', '🍎', '💩', '🧻', '🗑️', '🤢', '🚮'],
        'street': ['☕', '🥟', '🥔', '🌸', '💰', '🦴', '🥫', '🧽', '🪣', '🗞️'],
        'wedding': ['🍯', '🧆', '🫓', '🌸', '🍰', '🧊', '🥛', '🍼', '🧈'],
        'cricket': ['🏏', '🪵', '🥤', '🧢', '🩴', '⚾', '🥎', '🪨', '⚽', '🏐'],
        'debate': ['💣', '📰', '💨', '😡', '📺', '🔥', '⚡', '💀', '🎯']
    };
    
    const stageEmojis = projectileEmojis[this.currentStage] || projectileEmojis['rally'];
    const emoji = stageEmojis[Math.floor(Math.random() * stageEmojis.length)];
    
    const projectileGroup = new THREE.Group();
    
    // Much smaller projectiles for better gameplay
    const isMobile = window.innerWidth <= 768;
    const projectileSize = isMobile ? 0.12 : 0.15;
    
    // Create emoji texture with NO background
    const canvas = document.createElement('canvas');
    canvas.width = 48;
    canvas.height = 48;
    const ctx = canvas.getContext('2d');
    
    // Keep canvas transparent - NO background fill
    ctx.clearRect(0, 0, 48, 48);
    
    // Draw emoji only
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Add slight white outline for visibility
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineWidth = 2;
    ctx.strokeText(emoji, 24, 24);
    
    // Fill emoji with black
    ctx.fillStyle = '#000000';
    ctx.fillText(emoji, 24, 24);
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    
    // Pure sprite projectile - no glass sphere backing
    const spriteMaterial = new THREE.SpriteMaterial({ 
        map: texture,
        transparent: true,
        alphaTest: 0.1
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    
    // Much smaller sprite scale
    sprite.scale.set(projectileSize * 8, projectileSize * 8, 1);
    projectileGroup.add(sprite);
    
   // Enhanced flat glowing ring system - TIGHTER and STATIC
   const ringGeometry = new THREE.RingGeometry(projectileSize * 2.8, projectileSize * 3.4, 32);
   const ringMaterial = new THREE.MeshBasicMaterial({
    color: 0x00B4E6, // FAB light blue brand color
    transparent: true,
    opacity: 0.8,
    side: THREE.DoubleSide
});
const glowRing = new THREE.Mesh(ringGeometry, ringMaterial);

// Keep ring FLAT and STATIC - no rotation changes
glowRing.rotation.x = -Math.PI / 2; // Fixed flat horizontal orientation

// Determine priority level and combo points
const priorityEmojis = ['💣', '🍅', '💩', '🔥', '⚡', '💀'];
const isPriority = priorityEmojis.includes(emoji);
const comboPoints = isPriority ? 35 : 10;

// Tighter outer glow
const outerGlowGeometry = new THREE.RingGeometry(projectileSize * 3.4, projectileSize * 4.2, 32);
const outerGlowMaterial = new THREE.MeshBasicMaterial({
    color: 0x00B4E6,
    transparent: true,
    opacity: 0.4,
    side: THREE.DoubleSide
});
const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
outerGlow.rotation.x = -Math.PI / 2; // Also keep flat

// Create combo points - ATTACHED to ring position
const pointsCanvas = document.createElement('canvas');
pointsCanvas.width = 64;
pointsCanvas.height = 32;
const pointsCtx = pointsCanvas.getContext('2d');

pointsCtx.clearRect(0, 0, 64, 32);
pointsCtx.fillStyle = '#FFFFFF';
pointsCtx.font = 'bold 18px Arial';
pointsCtx.textAlign = 'center';
pointsCtx.textBaseline = 'middle';
pointsCtx.fillText(`+${comboPoints}`, 32, 16);

const pointsTexture = new THREE.CanvasTexture(pointsCanvas);
pointsTexture.needsUpdate = true;
const pointsMaterial = new THREE.SpriteMaterial({ 
    map: pointsTexture,
    transparent: true
});
const pointsSprite = new THREE.Sprite(pointsMaterial);
pointsSprite.scale.set(0.4, 0.2, 1);
pointsSprite.position.y = projectileSize * 5; // Closer to ring

// Static userData - NO animation rotation
glowRing.userData = { 
    pulseTime: 0,
    isPriority: isPriority,
    isStatic: true // Prevent rotation
};

projectileGroup.add(outerGlow);
projectileGroup.add(glowRing);
projectileGroup.add(pointsSprite);
    
    // Enhanced spawn positioning for multi-directional gameplay
    const spawnDistance = 10;
    const maxSpawnX = this.isMobile ? 3.5 : 6; // Balanced spawn range for desktop
    const spawnRoll = Math.random();
    let spawnX, spawnZ, spawnHeight;
    
    console.log(`🎲 SPAWN ROLL: ${spawnRoll.toFixed(3)}`);
    if (spawnRoll < 0.4) {
        // Front spawn from ABOVE (40% chance) - requires jump
        spawnX = (Math.random() - 0.5) * 2 * maxSpawnX;
        spawnZ = spawnDistance;
        spawnHeight = 3.5 + Math.random() * 1.5; // 3.5-5.0 height (above aide)
        console.log(`📍 HIGH SPAWN: x=${spawnX.toFixed(2)}, y=${spawnHeight.toFixed(2)}, z=${spawnZ}`);
    } else if (spawnRoll < 0.7) {
        // Left side spawn AT AIDE LEVEL (30% chance) - requires left movement
        spawnX = -maxSpawnX - (this.isMobile ? 1.5 : 2.0); // Wider left spawn on desktop
        spawnZ = 5 + Math.random() * 2; // 5-7 z distance
        spawnHeight = 0.75 + (Math.random() - 0.5) * 0.2; // GROUND LEVEL ±0.1
        console.log(`📍 LEFT AIDE-LEVEL: x=${spawnX.toFixed(2)}, y=${spawnHeight.toFixed(2)}, z=${spawnZ}`);
    } else {
        // Right side spawn AT AIDE LEVEL (30% chance) - requires right movement
        spawnX = maxSpawnX + (this.isMobile ? 1.5 : 2.0); // Wider right spawn on desktop
        spawnZ = 5 + Math.random() * 2; // 5-7 z distance
        spawnHeight = 0.75 + (Math.random() - 0.5) * 0.2; // GROUND LEVEL ±0.1
        console.log(`📍 RIGHT AIDE-LEVEL: x=${spawnX.toFixed(2)}, y=${spawnHeight.toFixed(2)}, z=${spawnZ}`);
    }
    projectileGroup.position.set(spawnX, spawnHeight, spawnZ);
    // CRITICAL DEBUG: Verify spawn positions
    console.log(`🎯 SPAWN CONFIRMED: Projectile ${emoji} at (${spawnX.toFixed(2)}, ${spawnHeight.toFixed(2)}, ${spawnZ.toFixed(2)})`);
    console.log(`🏃 AIDE POSITION: (${this.player.position.x.toFixed(2)}, ${this.player.position.y.toFixed(2)}, ${this.player.position.z.toFixed(2)})`);
    // Verify spawn type
    if (spawnHeight < 2) {
        console.log(`✅ SIDE-LEVEL PROJECTILE SPAWNED - Should be blockable by movement`);
    } else {
        console.log(`⬆️ HIGH PROJECTILE SPAWNED - Requires jumping`);
    }
    // TARGETING: Side projectiles aim toward aide's interception zone
    let targetY, targetX;
    if (spawnRoll < 0.4) {
        // High projectiles target politician
        targetY = this.politician.position.y + (Math.random() - 0.3) * 0.8;
        targetX = this.politician.position.x + (Math.random() - 0.5) * 0.4;
    } else {
        // Side projectiles target aide's blocking zone
        targetY = 0.75 + (Math.random() - 0.5) * 0.3; // Aide level
        targetX = (Math.random() - 0.5) * 3; // Spread across aide movement area
        console.log(`🎯 SIDE TARGET: toward aide zone (${targetX.toFixed(2)}, ${targetY.toFixed(2)})`);
    }
    
    const direction = new THREE.Vector3(
        targetX - projectileGroup.position.x,
        targetY - projectileGroup.position.y,
        this.politician.position.z - projectileGroup.position.z
    );
    direction.normalize();
    
    const speed = this.slowMotionActive ? 1.5 : (2.5 + Math.random() * 1.5); // Much slower projectiles for testing
    projectileGroup.velocity = direction.multiplyScalar(speed);
    projectileGroup.emoji = emoji;
    projectileGroup.isPriority = isPriority;
    projectileGroup.rotationSpeed = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
    );
    
    return projectileGroup;
}
    
    spawnProjectile() {
        const projectile = this.createProjectile();
        this.projectiles.push(projectile);
        this.scene.add(projectile);
        this.totalProjectiles++;
    }
    
updateProjectiles(deltaTime) {
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
        const projectile = this.projectiles[i];
        
        // Move projectile
        projectile.position.add(
            projectile.velocity.clone().multiplyScalar(deltaTime)
        );
        
        // Rotate for effect
        if (projectile.rotationSpeed) {
            projectile.rotation.x += projectile.rotationSpeed.x * deltaTime;
            projectile.rotation.y += projectile.rotationSpeed.y * deltaTime;
            projectile.rotation.z += projectile.rotationSpeed.z * deltaTime;
        }
        
        // Enhanced collision detection for desktop accuracy
        const playerDistance = projectile.position.distanceTo(this.player.position);
        const xDiff = Math.abs(this.player.position.x - projectile.position.x);
        const yDiff = Math.abs(this.player.position.y - projectile.position.y);
        const zDiff = Math.abs(this.player.position.z - projectile.position.z);
        
        // Tighter collision bounds for desktop precision
        const collisionRadius = this.isMobile ? 3.2 : 2.8;
        
        if (playerDistance < collisionRadius) {
            // Multiple blocking conditions - REQUIRE ACTIVE PLAYER INPUT
            const shieldBlock = this.player.shield.visible;
            const jumpBlock = this.isJumping && yDiff < 2.2 && xDiff < 1.8;
            
            // Special handling for side-spawned projectiles based on trajectory
            const projectileFromSide = Math.abs(projectile.position.x) > Math.abs(projectile.position.z);
            const sideTrajectoryBlock = projectileFromSide && xDiff < 1.5 && yDiff < 1.2 && zDiff < 2.0;
            
            // Only allow blocking with ACTIVE player input (shield, jump, or precise positioning)
            const canBlock = shieldBlock || jumpBlock || sideTrajectoryBlock;
            
            if (canBlock) {
                // Reset consecutive hits ONLY on successful active block
                console.log("🛡️ BLOCK: Resetting consecutive hits from", this.consecutiveHits, "to 0");
                this.consecutiveHits = 0;
                
                this.handleBlock(projectile);
                this.scene.remove(projectile);
                this.projectiles.splice(i, 1);
                continue;
            }
        }
        
        // Check collision with politician
        const politicianDistance = projectile.position.distanceTo(this.politician.position);
        if (politicianDistance < 1.2) {
            this.handleHit(projectile);
            this.createStain(projectile);
            this.scene.remove(projectile);
            this.projectiles.splice(i, 1);
            continue;
        }
        
        // Remove if out of bounds
        if (projectile.position.z < -10 || Math.abs(projectile.position.x) > 15 || projectile.position.y < -5) {
            this.scene.remove(projectile);
            this.projectiles.splice(i, 1);
        }
    }
}
  createStain(projectile) {
    // Create realistic Three.js particle-based stain effects
    const stainGroup = new THREE.Group();
    const stainType = this.getStainType(projectile.emoji);
    const baseColor = this.getStainColor(projectile.emoji);
    
    // Random impact position on politician
    const impactX = this.politician.position.x + (Math.random() - 0.5) * 0.8;
    const impactY = this.politician.position.y + (Math.random() - 0.5) * 1.2;
    const impactZ = this.politician.position.z + 0.1;
    
    this.createStainParticles(stainGroup, stainType, baseColor, impactX, impactY, impactZ);
    
    this.stains.push(stainGroup);
    this.scene.add(stainGroup);
    
    // Remove stain after a while
    setTimeout(() => {
        this.scene.remove(stainGroup);
        const index = this.stains.indexOf(stainGroup);
        if (index > -1) {
            this.stains.splice(index, 1);
        }
    }, 5000);
}

createStainParticles(stainGroup, stainType, baseColor, x, y, z) {
    const particleCount = window.innerWidth <= 768 ? 6 : 12;
    
    for (let i = 0; i < particleCount; i++) {
        const size = 0.02 + Math.random() * 0.04;
        const geometry = new THREE.SphereGeometry(size, 6, 6);
        const material = new THREE.MeshBasicMaterial({
            color: new THREE.Color(baseColor).offsetHSL(0, 0, (Math.random() - 0.5) * 0.3),
            transparent: true,
            opacity: 0.8 - (Math.random() * 0.2)
        });
        const particle = new THREE.Mesh(geometry, material);
        
        // Position based on stain type
        switch(stainType) {
            case 'drip': // Eggs, liquids - drip downward
                particle.position.set(
                    x + (Math.random() - 0.5) * 0.2,
                    y - Math.random() * 0.5 - (i * 0.08), // Progressive drip
                    z + Math.random() * 0.02
                );
                break;
            case 'splatter': // Tomatoes, wet items - radial splatter
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.35;
                particle.position.set(
                    x + Math.cos(angle) * radius,
                    y + Math.sin(angle) * radius * 0.7,
                    z + Math.random() * 0.02
                );
                break;
            case 'dust': // Dry items - scattered dust cloud
                particle.position.set(
                    x + (Math.random() - 0.5) * 0.4,
                    y + (Math.random() - 0.5) * 0.25,
                    z + Math.random() * 0.06
                );
                material.opacity = 0.5;
                break;
        }
        
        stainGroup.add(particle);
    }
}

getStainType(emoji) {
    const dripItems = ['🥚', '🥤', '☕', '🍯', '🥛', '💧']; // Liquids that drip
    const splatterItems = ['🍅', '🍎', '🧆', '🫓', '🥔', '🥟']; // Items that splatter
    const dustItems = ['👞', '🦴', '🥫', '🧢', '🩴', '📰', '💨']; // Dry items that create dust
    
    if (dripItems.includes(emoji)) return 'drip';
    if (splatterItems.includes(emoji)) return 'splatter';
    if (dustItems.includes(emoji)) return 'dust';
    return 'splatter'; // Default
}

getStainColor(emoji) {
    const stainColors = {
        '🍅': 0xFF0000,
        '🥚': 0xFFFFAA,
        '👞': 0x444444,
        '🥤': 0x8B4513,
        '🍌': 0xFFFF00,
        '🍎': 0xFF0000,
        '☕': 0x4B2F20,
        '🥟': 0xFFEBCD,
        '🥔': 0x8B7355,
        '🌸': 0xFFB6C1,
        '💰': 0xFFD700,
        '🍯': 0xFFB300,
        '🧆': 0x8B4513,
        '🫓': 0xDEB887,
        '🏏': 0x8B4513,
        '🪵': 0x654321,
        '🧢': 0x000080,
        '🩴': 0x8B4513,
        '💣': 0x333333,
        '📰': 0x999999,
        '💨': 0xCCCCCC,
        '😡': 0xFF0000
    };
    return stainColors[emoji] || 0x888888;
}
    
 handleHit(projectile) {
    console.log("❤️ HEALTH DEBUG - Before hit:", this.health);
    console.log("💥 HANDLE HIT CALLED - Before increment:", this.consecutiveHits);
    
    // Track consecutive hits for game over condition
    this.consecutiveHits++;
    console.log("💥 HANDLE HIT - After increment:", this.consecutiveHits);
    
    // Reduce health (reputation)
    this.health -= 5;
    console.log("❤️ HEALTH DEBUG - After hit:", this.health);
    if (this.health < 0) this.health = 0;
    this.updateHealth();
    this.playSound('hit');
    this.resetCombo();
    
    // Stage-specific hit effects
    if (this.currentStage === 'street' && (projectile.emoji === '☕' || projectile.emoji === '🥔')) {
        this.greaseBlurActive = true;
    }
    
    if (this.currentStage === 'wedding') {
        this.splatterMeter = Math.min(100, this.splatterMeter + 15);
    }
    
    if (projectile.isPowerHit) {
        this.health -= 5;
        console.log("❤️ POWER HIT - Extra damage, health now:", this.health);
    }
    
    console.log("📊 CONSECUTIVE HITS STATUS:", this.consecutiveHits, "of", this.maxConsecutiveHits);
    
    // UNIFIED GAME OVER SYSTEM - Check consecutive hits first, then health
    if (this.consecutiveHits >= this.maxConsecutiveHits) {
        // Ensure at least 2 seconds passed since critical warning
        const timeSinceWarning = Date.now() - this.criticalWarningTime;
        if (timeSinceWarning >= 2000 || this.criticalWarningTime === 0) {
            console.log("🔥 GAME OVER TRIGGER - Grace period expired or no warning given");
            this.analytics.deathCause = 'consecutive_failures';
            this.showCenterWarning('💀 5 CONSECUTIVE HITS! GAME OVER!');
            this.endGame();
            return;
        } else {
            // Still in grace period - show countdown
            const remaining = Math.ceil((2000 - timeSinceWarning) / 1000);
            console.log(`⏰ Grace period: ${remaining} second(s) remaining`);
            return; // Don't end game yet
        }
    } else if (this.consecutiveHits === 3) {
        // Warning at 3 hits - prevent notification overlap
        console.log("🚨 3-HIT CHECK - warningShown3:", this.warningShown3);
        if (!this.warningShown3) {
            this.warningShown3 = true;
            console.log("✅ SHOWING 3-HIT WARNING");
            this.showCenterWarning('⚠️ WARNING: 3 HITS IN A ROW!');
        } else {
            console.log("❌ 3-HIT WARNING BLOCKED - Already shown");
        }
    } else if (this.consecutiveHits === 4) {
        // Final warning at 4 hits - prevent notification overlap
        console.log("🚨 4-HIT CHECK - warningShown4:", this.warningShown4);
        if (!this.warningShown4) {
            this.warningShown4 = true;
            console.log("✅ SHOWING 4-HIT WARNING");
            this.showCenterWarning('🚨 CRITICAL: ONE MORE HIT = GAME OVER!');
            this.criticalWarningTime = Date.now(); // Start grace period timer
        } else {
            console.log("❌ 4-HIT WARNING BLOCKED - Already shown");
        }
    } else if (this.health <= 0) {
        // Secondary condition: health depletion
        this.analytics.deathCause = 'health_depleted';
        this.showCenterWarning('💀 REPUTATION DESTROYED! GAME OVER!');
        this.endGame();
        return;
    }
    
    // Track missed projectile for perfect minute achievement
    this.recentActions.push({
        time: Date.now(),
        blocked: false
    });
}
    
    trackFPS() {
        const fps = 1 / this.clock.getDelta();
        this.analytics.fps.push(fps);
        
        // Keep only last 60 frames
        if (this.analytics.fps.length > 60) {
            this.analytics.fps.shift();
        }
    }
    
    getAverageFPS() {
        if (this.analytics.fps.length === 0) return 60;
        const sum = this.analytics.fps.reduce((a, b) => a + b, 0);
        return Math.round(sum / this.analytics.fps.length);
    }
    
  // Performance Optimization Methods
setupRenderer() {
    this.renderer = new THREE.WebGLRenderer({ 
        canvas: this.canvas,
        antialias: !this.isMobile,
        alpha: false,
        powerPreference: this.isMobile ? 'low-power' : 'high-performance'
    });
    
    // Force exact pixel dimensions to eliminate gaps
    const width = window.innerWidth;
    const height = window.innerHeight;
    this.renderer.setSize(width, height, false); // false prevents CSS styling
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, this.isMobile ? 1.5 : 2));

    // Desktop-only visual enhancements
    if (!this.isMobile) {
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.1;
        
        // Initialize selective bloom effect for desktop
        this.setupBloomEffect();
    }
    
    // Force canvas to exact viewport positioning
    this.canvas.style.position = 'fixed';
    this.canvas.style.top = '0px';
    this.canvas.style.left = '0px';
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
    this.canvas.style.margin = '0';
    this.canvas.style.padding = '0';
    this.canvas.style.display = 'block';
    this.canvas.style.zIndex = '1';
    this.canvas.style.overflow = 'hidden';
    
    // Force body and html to eliminate any default spacing
    document.body.style.margin = '0';
    document.body.style.padding = '0';
    document.body.style.height = '100vh';
    document.body.style.overflow = 'hidden';
    document.documentElement.style.margin = '0';
    document.documentElement.style.padding = '0';
    document.documentElement.style.height = '100vh';
    
    // Conditional shadow settings
    if (this.shadowsEnabled) {
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    } else {
        this.renderer.shadowMap.enabled = false;
    }
    
    window.addEventListener('resize', () => this.onResize());
    
    this.trackEvent('renderer_initialized', {
        quality: this.quality,
        shadows: this.shadowsEnabled,
        devicePixelRatio: Math.min(window.devicePixelRatio, this.isMobile ? 1.5 : 2)
    });
}

setupBloomEffect() {
    // Selective bloom system - only affects specified glowing elements
    this.bloomObjects = new Set();
    
    // Create dedicated render target for bloom pass (half resolution for performance)
    this.bloomRenderTarget = new THREE.WebGLRenderTarget(
        Math.floor(window.innerWidth * 0.5), 
        Math.floor(window.innerHeight * 0.5),
        {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            type: THREE.FloatType
        }
    );
    
    // Bloom overlay material for selective glow rendering
    this.bloomMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.6
    });
    
    // Bloom intensity control
    this.bloomStrength = 0.4;
    this.bloomEnabled = true;
    
    console.log('Selective bloom effect initialized for desktop');
}
    
    // Object Pooling for Projectiles
    getPooledProjectile() {
        if (this.projectilePool.length > 0) {
            const projectile = this.projectilePool.pop();
            projectile.visible = true;
            return projectile;
        }
        return null;
    }
    
    returnToPool(projectile) {
        if (this.projectilePool.length < this.maxPoolSize) {
            projectile.visible = false;
            projectile.position.set(0, -100, 0);
            this.projectilePool.push(projectile);
        } else {
            this.scene.remove(projectile);
        }
    }
    
  // Power-Up System Implementation
setupPowerUpControls() {
    // Enhanced mobile power-up controls
    this.setupMobilePowerUpControls();
    
    // Enhanced desktop visual indicators
    this.setupDesktopPowerUpIndicators();
}

setupMobilePowerUpControls() {
    if (!this.isMobile) return;
    
    const superShieldIcon = document.getElementById('superShieldIcon');
    const slowMotionIcon = document.getElementById('slowMotionIcon');
    const fabBombIcon = document.getElementById('fabBombIcon');
    
    [
        { element: superShieldIcon, power: 'shield', cost: 25 },
        { element: slowMotionIcon, power: 'slow', cost: 30 },
        { element: fabBombIcon, power: 'bomb', cost: 50 }
    ].forEach(({ element, power, cost }) => {
        if (element) {
            element.style.cursor = 'pointer';
            element.dataset.power = power;
            element.dataset.cost = cost;
            
            element.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.handlePowerUpActivation(power, cost);
            });
            
            element.addEventListener('click', (e) => {
                e.preventDefault();
                this.handlePowerUpActivation(power, cost);
            });
        }
    });
}

setupDesktopPowerUpIndicators() {
    if (this.isMobile) return;
    
    // Add keyboard hints, cost info, and click handlers to power-up icons
    const superShieldIcon = document.getElementById('superShieldIcon');
    const slowMotionIcon = document.getElementById('slowMotionIcon');
    const fabBombIcon = document.getElementById('fabBombIcon');
    
    [
       { element: superShieldIcon, power: 'shield', cost: 25, key: 'Q', name: 'Super Shield' },
        { element: slowMotionIcon, power: 'slow', cost: 30, key: 'E', name: 'Slow Motion' },
        { element: fabBombIcon, power: 'bomb', cost: 50, key: 'R', name: 'FAB Bomb' }
    ].forEach(({ element, power, cost, key, name }) => {
        if (element) {
            element.title = `${name} (${key}) - ${cost} FAB Power`;
            element.dataset.power = power;
            element.dataset.cost = cost;
            element.style.cursor = 'pointer';
            
            // Add click handler for desktop
            element.addEventListener('click', (e) => {
                e.preventDefault();
                this.handlePowerUpActivation(power, cost);
            });
            
            // Add visual feedback for desktop
            element.addEventListener('mousedown', (e) => {
                e.preventDefault();
                element.style.transform = 'scale(0.95)';
            });
            
            element.addEventListener('mouseup', (e) => {
                e.preventDefault();
                element.style.transform = 'scale(1)';
            });
            
            element.addEventListener('mouseleave', (e) => {
                element.style.transform = 'scale(1)';
            });
        }
    });

}

handlePowerUpActivation(powerType, cost = 0) {
    if (!this.isRunning) return;
    
    // Visual feedback for insufficient power
    if (cost > 0 && this.fabPower < cost) {
        this.showInsufficientPowerFeedback(powerType, cost);
        return;
    }
    
    switch(powerType) {
        case 'shield':
            this.activateSuperShield();
            break;
        case 'slow':
            this.activateSlowMotion();
            break;
        case 'bomb':
            this.activateFABBomb();
            break;
    }
}

showInsufficientPowerFeedback(powerType, cost) {
    const powerNames = {
        'shield': 'Super Shield',
        'slow': 'Slow Motion', 
        'bomb': 'FAB Bomb'
    };
    
    this.showNotification(`${powerNames[powerType]} needs ${cost} FAB Power! (${this.fabPower}/${cost})`);
    
    // Flash the power bar briefly to draw attention
    const powerBar = document.getElementById('powerBar');
    if (powerBar) {
        powerBar.style.animation = 'powerBarFlash 0.5s ease';
        setTimeout(() => {
            powerBar.style.animation = '';
        }, 500);
    }
    
    // Shake the power-up icon to indicate insufficient power
    const iconIds = { 'shield': 'superShieldIcon', 'slow': 'slowMotionIcon', 'bomb': 'fabBombIcon' };
    const icon = document.getElementById(iconIds[powerType]);
    if (icon) {
        icon.style.animation = 'iconShake 0.3s ease';
        setTimeout(() => {
            icon.style.animation = '';
        }, 300);
    }
}

// Enhanced power bar update with visual feedback
updatePowerBar() {
    const powerBar = document.getElementById('powerBar');
    if (powerBar) {
        powerBar.style.width = (this.fabPower / this.fabPowerMax * 100) + '%';
    }
    
    const superShieldIcon = document.getElementById('superShieldIcon');
    const slowMotionIcon = document.getElementById('slowMotionIcon');
    const fabBombIcon = document.getElementById('fabBombIcon');
    
    // Enhanced visual feedback with color coding
    if (superShieldIcon) {
        const canAfford = this.fabPower >= 25;
        superShieldIcon.style.opacity = canAfford ? '1' : '0.4';
        superShieldIcon.style.filter = canAfford ? 'none' : 'grayscale(70%)';
    }
    if (slowMotionIcon) {
        const canAfford = this.fabPower >= 30;
        slowMotionIcon.style.opacity = canAfford ? '1' : '0.4';
        slowMotionIcon.style.filter = canAfford ? 'none' : 'grayscale(70%)';
    }
    if (fabBombIcon) {
        const canAfford = this.fabPower >= 50;
        fabBombIcon.style.opacity = canAfford ? '1' : '0.4';
        fabBombIcon.style.filter = canAfford ? 'none' : 'grayscale(70%)';
    }
}

createPowerUp(type = 'random') {
    const powerUpTypes = ['fabBoost', 'healthPack', 'speedBoost', 'shield', 'slowTime'];
    const selectedType = type === 'random' ? 
        powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)] : type;
    
    const powerUpGroup = new THREE.Group();
    
    // Simplified geometry for mobile
    const segments = this.isMobile ? 8 : 16;
    const geometry = new THREE.SphereGeometry(0.4, segments, segments);
    const material = new THREE.MeshPhongMaterial({
        color: this.getPowerUpColor(selectedType),
        emissive: this.getPowerUpColor(selectedType),
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.8
    });
    
    const sphere = new THREE.Mesh(geometry, material);
    if (this.shadowsEnabled) {
        sphere.castShadow = true;
        sphere.receiveShadow = true;
    }
    powerUpGroup.add(sphere);
    
    // Simplified sprite for mobile
    if (!this.isMobile || this.quality === 'high') {
        const canvas = document.createElement('canvas');
        canvas.width = this.isMobile ? 64 : 128;
        canvas.height = this.isMobile ? 64 : 128;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.arc(canvas.width/2, canvas.height/2, canvas.width/2 - 4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.font = `bold ${this.isMobile ? 32 : 64}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.getPowerUpEmoji(selectedType), canvas.width/2, canvas.height/2);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(1, 1, 1);
        powerUpGroup.add(sprite);
    }
    
    // Random position
    powerUpGroup.position.set(
        (Math.random() - 0.5) * 6,
        1.5,
        2
    );
    
    powerUpGroup.powerType = selectedType;
    powerUpGroup.lifetime = 10;
    powerUpGroup.bobTime = 0;
    
    return powerUpGroup;
}

updatePowerUps(deltaTime) {
    // Spawn power-ups based on performance settings
    const spawnChance = this.isMobile ? 0.001 : 0.002;
    const maxPowerUps = this.isMobile ? 1 : 2;
    
    if (Math.random() < spawnChance && this.powerUps.length < maxPowerUps) {
        const powerUp = this.createPowerUp();
        this.powerUps.push(powerUp);
        this.scene.add(powerUp);
        
        this.trackEvent('powerup_spawned', { type: powerUp.powerType });
    }
    
    // Update existing power-ups
    for (let i = this.powerUps.length - 1; i >= 0; i--) {
        const powerUp = this.powerUps[i];
        
        // Simplified animation for mobile
        if (!this.isMobile || this.quality === 'high') {
            powerUp.bobTime += deltaTime * 2;
            powerUp.position.y = 1.5 + Math.sin(powerUp.bobTime) * 0.2;
            powerUp.rotation.y += deltaTime;
        }
        
        // Check collection
        const distance = powerUp.position.distanceTo(this.player.position);
        if (distance < 1.5) {
            this.collectPowerUp(powerUp);
            this.scene.remove(powerUp);
            this.powerUps.splice(i, 1);
            continue;
        }
        
        // Remove if expired
        powerUp.lifetime -= deltaTime;
        if (powerUp.lifetime <= 0) {
            this.scene.remove(powerUp);
            this.powerUps.splice(i, 1);
        }
    }
    
    // Update FAB power bar with enhanced feedback
    this.updatePowerBar();
}

collectPowerUp(powerUp) {
    this.playSound('powerup');
    this.analytics.powerUpsCollected++;
    
    switch(powerUp.powerType) {
        case 'fabBoost':
            this.fabPower = Math.min(this.fabPowerMax, this.fabPower + 30);
            this.showNotification('FAB Power +30!');
            break;
        case 'healthPack':
            this.health = Math.min(200, this.health + 20);
            this.updateHealth();
            this.showNotification('Health Restored!');
            break;
        case 'speedBoost':
            this.activateSpeedBoost();
            break;
        case 'shield':
            this.fabPower = Math.min(this.fabPowerMax, this.fabPower + 25);
            this.showNotification('Shield Power +25!');
            break;
        case 'slowTime':
            this.fabPower = Math.min(this.fabPowerMax, this.fabPower + 30);
            this.showNotification('Slow Time Power +30!');
            break;
    }
    
    this.trackEvent('powerup_collected', { 
        type: powerUp.powerType,
        fabPower: this.fabPower,
        health: this.health
    });
}

activateSuperShield() {
    if (this.fabPower < 25) {
        this.showNotification('Not enough FAB Power! (25 required)');
        return;
    }
    
    this.fabPower -= 25;
    this.superShieldActive = true;
    this.showNotification('Super Shield Activated!');

    // Track power-up usage for achievements
    this.usedPowerUps.add('shield');
    
    // Track usage
    if (!this.analytics.powerUpsUsed.shield) this.analytics.powerUpsUsed.shield = 0;
    this.analytics.powerUpsUsed.shield++;
    this.trackEvent('powerup_activated', { type: 'shield' });
    this.usedPowerUps.add('shield');
    // Check achievements immediately after power-up use
    this.checkAchievements();
    
    // Visual effect
    const shieldIcon = document.getElementById('superShieldIcon');
    if (shieldIcon) shieldIcon.classList.add('active');
    
    // Enhanced shield visual using same logic as keyboard activation
    this.player.shield.visible = true;
    if (this.player.shield.userData && this.player.shield.userData.ring) {
        this.player.shield.userData.ring.material.emissiveIntensity = 1.0; // Extra bright for power-up
        this.player.shield.userData.glow.material.opacity = 0.8; // Extra bright for power-up
        this.player.shield.scale.set(1.5, 1.5, 1.5); // Larger for power-up
        console.log('Super Shield activated with enhanced glow');
    }
    
    setTimeout(() => {
        this.superShieldActive = false;
        this.player.shield.visible = false;
        
        // Reset shield visual effects using userData structure
        if (this.player.shield.userData && this.player.shield.userData.ring) {
            this.player.shield.userData.ring.material.emissiveIntensity = 0.4;
            this.player.shield.userData.glow.material.opacity = 0.3;
            this.player.shield.scale.set(1, 1, 1);
        }
        
        if (shieldIcon) shieldIcon.classList.remove('active');
    }, 5000);
}

activateSlowMotion() {
    if (this.fabPower < 30) {
        this.showNotification('Not enough FAB Power! (30 required)');
        return;
    }
    
    this.fabPower -= 30;
    this.slowMotionActive = true;
    this.projectileInterval *= 2;
    this.showNotification('Time Slowed!');

    // Track power-up usage for achievements
    this.usedPowerUps.add('slow');
    
    // Track usage
    if (!this.analytics.powerUpsUsed.slowMotion) this.analytics.powerUpsUsed.slowMotion = 0;
    this.analytics.powerUpsUsed.slowMotion++;
    this.trackEvent('powerup_activated', { type: 'slowMotion' });
    this.usedPowerUps.add('slowMotion');
    // Check achievements immediately after power-up use
    this.checkAchievements();
    
    // Visual effect
    const overlay = document.getElementById('slowMotionOverlay');
    const icon = document.getElementById('slowMotionIcon');
    if (overlay) overlay.classList.add('active');
    if (icon) icon.classList.add('active');
    
    // Slow projectiles
    this.projectiles.forEach(p => {
        if (p.velocity) {
            p.velocity.multiplyScalar(0.3);
        }
    });
    
    setTimeout(() => {
        this.slowMotionActive = false;
        this.projectileInterval = Math.max(500, this.projectileInterval / 2);
        if (overlay) overlay.classList.remove('active');
        if (icon) icon.classList.remove('active');
    }, 4000);
}

activateFABBomb() {
    if (this.fabPower < 50) {
        this.showNotification('Not enough FAB Power! (50 required)');
        return;
    }
    
    this.fabPower -= 50;
    this.showNotification('FAB BOMB!');

    // Track FAB Bomb usage for achievement
        if (!this.fabBombCount) this.fabBombCount = 0;
        this.fabBombCount++;
        this.usedPowerUps.add('bomb');
    
    // Track usage
    if (!this.analytics.powerUpsUsed.fabBomb) this.analytics.powerUpsUsed.fabBomb = 0;
    this.analytics.powerUpsUsed.fabBomb++;
    this.trackEvent('powerup_activated', { type: 'fabBomb' });
    this.usedPowerUps.add('fabBomb');
    // Check achievements immediately after FAB bomb use
    this.checkAchievements();
    
    // Visual effect
    const icon = document.getElementById('fabBombIcon');
    if (icon) icon.classList.add('active');
    
    // Flash effect
    const flash = document.getElementById('screenFlash');
    if (flash) {
        flash.classList.add('active');
        setTimeout(() => flash.classList.remove('active'), 300);
    }
    
    // Clear all projectiles
    this.projectiles.forEach(projectile => {
        this.createBlockParticles(projectile.position);
        this.returnToPool(projectile);
    });
    this.projectiles = [];
    
    // Clean all stains
    if (this.politician && this.stains) {
        this.stains.forEach(stain => {
            this.scene.remove(stain);
        });
        this.stains = [];
    }
    
    // Bonus points
    this.score += 100;
    this.updateScore();
    
    // Visual celebration with reduced particles on mobile
    this.createCelebrationParticles();
    
    // Remove active state after effect
    setTimeout(() => {
        if (icon) icon.classList.remove('active');
    }, 1000);
}
    
    createBlockParticles(position) {
        const particleCount = this.maxParticles;
        const particles = [];
        
        for (let i = 0; i < particleCount; i++) {
            const size = this.isMobile ? 0.15 : 0.1;
            const geometry = new THREE.SphereGeometry(size, 4, 4); // Less segments on mobile
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                transparent: true
            });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.copy(position);
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                Math.random() * 5,
                (Math.random() - 0.5) * 5
            );
            particle.lifetime = 1;
            particles.push(particle);
            this.scene.add(particle);
        }
        
        const animateParticles = () => {
            particles.forEach((particle, index) => {
                particle.position.add(particle.velocity.clone().multiplyScalar(0.02));
                particle.velocity.y -= 0.1;
                particle.lifetime -= 0.02;
                particle.material.opacity = particle.lifetime;
                
                if (particle.lifetime <= 0) {
                    this.scene.remove(particle);
                    particles.splice(index, 1);
                }
            });
            
            if (particles.length > 0) {
                requestAnimationFrame(animateParticles);
            }
        };
        
        animateParticles();
    }
    
    createCelebrationParticles() {
        const colors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF];
        const particleCount = this.isMobile ? 25 : 50;
        
        for (let i = 0; i < particleCount; i++) {
            const size = this.isMobile ? 0.15 : 0.1;
            const geometry = new THREE.SphereGeometry(size, 4, 4);
            const material = new THREE.MeshBasicMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true
            });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.set(
                this.politician.position.x + (Math.random() - 0.5) * 2,
                this.politician.position.y,
                this.politician.position.z
            );
            
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                Math.random() * 10,
                (Math.random() - 0.5) * 10
            );
            
            this.scene.add(particle);
            
            const animateParticle = () => {
                particle.position.add(particle.velocity.clone().multiplyScalar(0.02));
                particle.velocity.y -= 0.2;
                particle.material.opacity -= 0.01;
                
                if (particle.material.opacity > 0) {
                    requestAnimationFrame(animateParticle);
                } else {
                    this.scene.remove(particle);
                }
            };
            animateParticle();
        }
    }
    updateStageMechanics(deltaTime) {
        switch(this.currentStage) {
            case 'rally':
                this.updateRallyMechanics(deltaTime);
                break;
            case 'street':
                this.updateStreetMechanics(deltaTime);
                break;
            case 'wedding':
                this.updateWeddingMechanics(deltaTime);
                break;
            case 'cricket':
                this.updateCricketMechanics(deltaTime);
                break;
            case 'debate':
                this.updateDebateMechanics(deltaTime);
                break;
        }
    }
    
    // Rally Stage - Crowd Mood
    updateRallyMechanics(deltaTime) {
        // Update crowd mood based on performance
        if (this.comboCount > 0) {
            this.crowdMood = Math.min(100, this.crowdMood + deltaTime * 5);
        } else {
            this.crowdMood = Math.max(0, this.crowdMood - deltaTime * 2);
        }
        
        // Update UI
        const moodBar = document.getElementById('crowdMoodBar');
        if (moodBar) {
            moodBar.style.width = this.crowdMood + '%';
        }
        
        // Heckler fast throws when mood is low
        if (this.crowdMood < 30) {
            this.projectileInterval = Math.max(500, this.projectileInterval - 100);
            
            // Spawn heckler projectile
            if (Math.random() < 0.02) {
                const hecklerProjectile = this.createProjectile();
                hecklerProjectile.velocity.multiplyScalar(1.5); // Faster
                hecklerProjectile.isHeckler = true;
                this.projectiles.push(hecklerProjectile);
                this.scene.add(hecklerProjectile);
                this.totalProjectiles++;
            }
        }
    }
    
    // Street Stage - Grease Stains and Obstacles
    updateStreetMechanics(deltaTime) {
        
        // Check for grease projectile hits
        if (this.greaseBlurActive) {
            // Player moves slower when greased
            const greaseElement = document.getElementById('greaseBlur');
            if (greaseElement) {
                greaseElement.style.display = 'block';
                setTimeout(() => {
                    greaseElement.style.display = 'none';
                    this.greaseBlurActive = false;
                }, 3000);
            }
        }
    }

    // Wedding Stage - Splatter Meter
    updateWeddingMechanics(deltaTime) {
        // Update splatter meter
        const splatterBar = document.getElementById('splatterBar');
        if (splatterBar) {
            splatterBar.style.width = Math.min(100, this.splatterMeter) + '%';
        }
        
        // Chapati blocks - special wide projectiles
        if (Math.random() < 0.005) {
            const chapatiProjectile = this.createProjectile();
            chapatiProjectile.scale.set(2, 2, 0.3); // Wide and flat
            chapatiProjectile.isChapati = true;
            chapatiProjectile.children.forEach(child => {
                if (child.type === 'Sprite') {
                    child.visible = false; // Hide emoji for chapati
                }
            });
            this.projectiles.push(chapatiProjectile);
            this.scene.add(chapatiProjectile);
            this.totalProjectiles++;
        }
        
        // Flower obscuration when splatter is high
        if (this.splatterMeter > 70) {
            this.createFlowerObscuration();
        }
    }
    
    createFlowerObscuration() {
        if (Math.random() < 0.01) {
            const flowerGeometry = new THREE.PlaneGeometry(0.5, 0.5);
            const flowerMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFC0CB,
                transparent: true,
                opacity: 0.7
            });
            const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
            flower.position.set(
                (Math.random() - 0.5) * 8,
                Math.random() * 4,
                5
            );
            
            this.scene.add(flower);
            
            // Animate falling
            const animateFlower = () => {
                flower.position.y -= 0.02;
                flower.position.z -= 0.05;
                flower.rotation.z += 0.05;
                
                if (flower.position.z > -5) {
                    requestAnimationFrame(animateFlower);
                } else {
                    this.scene.remove(flower);
                }
            };
            animateFlower();
        }
    }
    
    // Cricket Stage - Power Hits
    updateCricketMechanics(deltaTime) {
        // Random power hits
        if (!this.powerHitWarning && Math.random() < 0.003) {
            this.powerHitWarning = true;
            const warningElement = document.getElementById('powerHitWarning');
            if (warningElement) {
                warningElement.style.display = 'block';
                
                // Spawn power hit after warning
                setTimeout(() => {
                    const powerHit = this.createProjectile();
                    powerHit.scale.set(1.5, 1.5, 1.5); // Bigger
                    powerHit.velocity.multiplyScalar(2); // Much faster
                    powerHit.isPowerHit = true;
                    
                    // Add glow effect
                    const glowGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFF0000,
                        transparent: true,
                        opacity: 0.5
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    powerHit.add(glow);
                    
                    this.projectiles.push(powerHit);
                    this.scene.add(powerHit);
                    this.totalProjectiles++;
                    
                    warningElement.style.display = 'none';
                    this.powerHitWarning = false;
                }, 2000);
            }
        }
        
        // Tumbling bat pieces
        if (Math.random() < 0.004) {
            this.createTumblingBat();
        }
    }
    
    createTumblingBat() {
        const batGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1);
        const batMaterial = new THREE.MeshPhongMaterial({
            color: 0x8B4513
        });
        const bat = new THREE.Mesh(batGeometry, batMaterial);
        bat.position.set(
            (Math.random() - 0.5) * 6,
            4,
            6
        );
        bat.rotationSpeed = new THREE.Vector3(
            Math.random() * 0.2,
            Math.random() * 0.2,
            Math.random() * 0.2
        );
        
        this.scene.add(bat);
        
        // Animate tumbling
        const animateBat = () => {
            bat.position.z -= 0.1;
            bat.position.y -= 0.05;
            bat.rotation.x += bat.rotationSpeed.x;
            bat.rotation.y += bat.rotationSpeed.y;
            bat.rotation.z += bat.rotationSpeed.z;
            
            if (bat.position.z > -5) {
                requestAnimationFrame(animateBat);
            } else {
                this.scene.remove(bat);
            }
        };
        animateBat();
    }
    
    // Debate Stage - Perception and Flash
    updateDebateMechanics(deltaTime) {
        // Update perception based on performance
        if (this.blockedCount > this.totalProjectiles * 0.7) {
            this.perceptionMeter = Math.min(100, this.perceptionMeter + deltaTime * 3);
        } else {
            this.perceptionMeter = Math.max(0, this.perceptionMeter - deltaTime * 2);
        }
        
        // Update UI
        const perceptionBar = document.getElementById('perceptionBar');
        if (perceptionBar) {
            perceptionBar.style.width = this.perceptionMeter + '%';
        }
        
        // Flash daze effect - CORRECTED VERSION
if (!this.flashDazeActive && Math.random() < 0.003) {
    this.flashDazeActive = true;
    const flashElement = document.getElementById('flashDaze');
    if (flashElement) {
        flashElement.style.display = 'block';
        
        // Store original key states before swapping
        this.originalKeyStates = {
            left: this.keys['ArrowLeft'],
            right: this.keys['ArrowRight']
        };
        
        // Temporarily reverse controls
        const tempLeft = this.keys['ArrowLeft'];
        this.keys['ArrowLeft'] = this.keys['ArrowRight'];
        this.keys['ArrowRight'] = tempLeft;
        
        setTimeout(() => {
            flashElement.style.display = 'none';
            this.flashDazeActive = false;
            
            // Properly restore original states
            this.keys['ArrowLeft'] = this.originalKeyStates.left;
            this.keys['ArrowRight'] = this.originalKeyStates.right;
            
            delete this.originalKeyStates;
        }, 1500);
    }
}
        
        // Truth bombs - special projectiles
        if (Math.random() < 0.004) {
            const truthBomb = this.createProjectile();
            truthBomb.isTruthBomb = true;
            truthBomb.scale.set(1.2, 1.2, 1.2);
            
            // Add pulsing effect
            const pulseEffect = () => {
                if (truthBomb.parent) {
                    truthBomb.scale.x = 1.2 + Math.sin(Date.now() * 0.01) * 0.2;
                    truthBomb.scale.y = 1.2 + Math.sin(Date.now() * 0.01) * 0.2;
                    requestAnimationFrame(pulseEffect);
                }
            };
            pulseEffect();
            
            this.projectiles.push(truthBomb);
            this.scene.add(truthBomb);
            this.totalProjectiles++;
        }
    }
    

    // Update integrated stage meter in HUD
updateIntegratedStageMeter() {
    const container = document.getElementById('stageMeterContainer');
    const label = document.getElementById('stageMeterLabel');
    const bar = document.getElementById('stageMeterBar');
    
    if (!container || !label || !bar) return;
    
    switch(this.currentStage) {
        case 'rally':
            container.style.display = 'block';
            label.textContent = 'Crowd Mood';
            bar.style.width = this.crowdMood + '%';
            bar.style.background = 'linear-gradient(90deg, #FF0000, #FFD700, #00FF00)';
            break;
        case 'wedding':
            container.style.display = 'block';
            label.textContent = 'Splatter Level';
            bar.style.width = Math.min(100, this.splatterMeter) + '%';
            bar.style.background = 'linear-gradient(90deg, #8B4513, #D2691E)';
            break;
        case 'debate':
            container.style.display = 'block';
            label.textContent = 'Public Perception';
            bar.style.width = this.perceptionMeter + '%';
            bar.style.background = 'linear-gradient(90deg, #9370DB, #4169E1)';
            break;
        default:
            container.style.display = 'none';
            break;
    }
}
    // Show/hide stage mechanics UI
    showStageMechanics(stage) {
        // Stage mechanics now handled by integrated meter
        this.updateIntegratedStageMeter();
    }
    
    // Real-time achievement checking
    checkAchievements() {
        const sessionTime = (Date.now() - this.gameStartTime) / 1000;
        let newUnlocks = [];
        
        // Check each achievement
        if (!this.achievements.firstBlock.unlocked && this.blockedCount >= 1) {
            this.achievements.firstBlock.unlocked = true;
            newUnlocks.push('firstBlock');
        }
        
        if (!this.achievements.combo10.unlocked && this.comboCount >= 10) {
            this.achievements.combo10.unlocked = true;
            newUnlocks.push('combo10');
        }
        
        if (!this.achievements.survivor.unlocked && sessionTime >= 60) {
            this.achievements.survivor.unlocked = true;
            newUnlocks.push('survivor');
        }    
        
        if (!this.achievements.stageRunner.unlocked && this.currentStage === 'debate') {
            this.achievements.stageRunner.unlocked = true;
            newUnlocks.push('stageRunner');
        }
        
        if (!this.achievements.fabPowerUser.unlocked && this.usedPowerUps.size >= 3) {
            this.achievements.fabPowerUser.unlocked = true;
            newUnlocks.push('fabPowerUser');
        }

        // Enhanced accuracy tracking for perfectMinute achievement
        if (!this.achievements.perfectMinute.unlocked && sessionTime >= 30) {
          const thirtySecondsAgo = Date.now() - 30000;
            const recentActions = this.recentActions.filter(action => action.time >= thirtySecondsAgo);
            
            if (recentActions.length >= 10) {
                const recentBlocked = recentActions.filter(action => action.blocked).length;
                const recentAccuracy = (recentBlocked / recentActions.length) * 100;
                
                if (recentAccuracy === 100) {
                    this.achievements.perfectMinute.unlocked = true;
                    newUnlocks.push('perfectMinute');
            }
        }
    
            // Clean up old actions (keep only last 60 seconds for performance)
            this.recentActions = this.recentActions.filter(action => action.time >= Date.now() - 60000);
        
    } 

        
        if (!this.achievements.highScorer.unlocked && this.score >= 1000) {
            this.achievements.highScorer.unlocked = true;
            newUnlocks.push('highScorer');
        }

        // Track dodge count for dodgeMaster achievement
        if (!this.achievements.dodgeMaster.unlocked) {
            if (!this.dodgeCount) this.dodgeCount = 0;
            // Increment dodge count when projectile misses both player and politician
            // This will be tracked in the projectile update method
        }
        
        if (!this.achievements.speedDemon.unlocked && this.scoreMultiplier >= 5) {
            this.achievements.speedDemon.unlocked = true;
            newUnlocks.push('speedDemon');
        }

        // Track FAB Bomb usage for stainCleaner achievement
        if (!this.achievements.stainCleaner.unlocked) {
            if (!this.fabBombCount) this.fabBombCount = 0;
            if (this.fabBombCount >= 3) {
                this.achievements.stainCleaner.unlocked = true;
                newUnlocks.push('stainCleaner');
            }
        }
        
       // Always refresh visual state to ensure real-time updates
        this.refreshAchievementVisuals();
    }

toggleGlobalMute() {
    this.globalMuted = !this.globalMuted;
    console.log("🔊 Global mute toggled:", this.globalMuted);
    
    if (this.globalMuted) {
        // Store current levels and mute everything
        this.audioLevelsBeforeMute = {
            master: this.masterVolume,
            music: this.musicVolume,
            sfx: this.sfxVolume
        };
        this.masterVolume = 0;
        this.musicVolume = 0;
        this.sfxVolume = 0;
        this.stopMusic(); // Stop current music
        
        // Mute background music
        if (this.backgroundMusic) {
            this.backgroundMusic.volume = 0;
        }
    } else {
        // Restore previous levels
        if (this.audioLevelsBeforeMute) {
            this.masterVolume = this.audioLevelsBeforeMute.master;
            this.musicVolume = this.audioLevelsBeforeMute.music;
            this.sfxVolume = this.audioLevelsBeforeMute.sfx;
        } else {
            // Default levels if no previous state
            this.masterVolume = 0.7;
            this.musicVolume = 0.5;
            this.sfxVolume = 0.7;
        }
        // Restart music if game is running
        if (this.backgroundMusic && this.isRunning) {
            this.backgroundMusic.volume = 0.15;
            this.backgroundMusic.play().catch(error => {
                console.warn('Failed to resume background music:', error);
            });
        }
        if (this.isRunning) {
            this.startStageMusic();
        }
    }
    
    this.updateAudioLevels();
}

updateAudioLevels() {
    if (!this.audioContext || !this.audioInitialized) return;
    
    if (this.masterGainNode) {
        this.masterGainNode.gain.setValueAtTime(
            this.masterVolume,
            this.audioContext.currentTime
        );
    }
    if (this.musicGainNode) {
        this.musicGainNode.gain.setValueAtTime(
            this.musicVolume,
            this.audioContext.currentTime
        );
    }
    if (this.sfxGainNode) {
        this.sfxGainNode.gain.setValueAtTime(
            this.sfxVolume,
            this.audioContext.currentTime
        );
    }
}

    // Analytics & Tracking Methods
    generateSessionId() {
        return 'ss_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    trackEvent(eventName, eventData = {}) {
        const event = {
            sessionId: this.analytics.sessionId,
            timestamp: Date.now(),
            event: eventName,
            data: eventData,
            stage: this.currentStage,
            score: this.score,
            health: this.health
        };
        
        // Log to console for debugging
        console.log('Analytics Event:', event);
        
        // Store locally for session summary
        if (!this.analytics.events) this.analytics.events = [];
        this.analytics.events.push(event);
    }

   showCenterWarning(message) {
    const warningDiv = document.createElement('div');
    warningDiv.textContent = message;
    warningDiv.style.cssText = `
        position: fixed;
        top: 200px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 12px;
        padding: 12px 24px;
        color: white;
        font-weight: bold;
        font-size: 1.1em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        text-align: center;
        z-index: 1005;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        animation: slideDown 0.5s ease;
    `;
    document.body.appendChild(warningDiv);
    
    setTimeout(() => {
        if (warningDiv.parentNode) {
            document.body.removeChild(warningDiv);
        }
    }, 2000);
}

    handleBlock(projectile) {
          // Reset warning flags on successful block
        this.warningShown3 = false;
        this.warningShown4 = false;
        this.criticalWarningTime = 0;
        this.score += 10;
        this.updateCombo();
        
        if (this.superShieldActive) {
            this.score += 5;
            this.fabPower = Math.min(this.fabPowerMax, this.fabPower + 2);
        }
        
        this.fabPower = Math.min(this.fabPowerMax, this.fabPower + 1);
        this.blockedCount++;
        this.updateScore();
        this.playSound('block');
        
        // Track action for perfect minute achievement
        this.recentActions.push({
            time: Date.now(),
            blocked: true
        });
        
        this.createBlockParticles(projectile.position);
        
        // Check achievements immediately after blocking
        this.checkAchievements();
        this.refreshAchievementVisuals();
    }
    
    updateAchievementDisplay(newUnlocks = []) {
        const achievementList = document.getElementById('achievementList');
        if (!achievementList) return;
        
        Object.values(this.achievements).forEach(achievement => {
            const element = document.querySelector(`[data-achievement="${achievement.id}"]`);
            if (element) {
                element.classList.toggle('unlocked', achievement.unlocked);
                if (newUnlocks.includes(achievement.id)) {
                   element.classList.add('fab-glow');
                    // Remove glow after 5 seconds
                    setTimeout(() => {
                        element.classList.remove('fab-glow');
                    }, 5000);
                }
            }
        });
    }

    refreshAchievementVisuals() {
        const achievementList = document.getElementById('achievementList');
        if (!achievementList || this.isMobile) return;
        
        Object.values(this.achievements).forEach(achievement => {
            const element = document.querySelector(`[data-achievement="${achievement.id}"]`);
            if (element) {
                // Force visual state update
                if (achievement.unlocked) {
                    element.classList.add('unlocked');
                    const icon = element.querySelector('.achievement-icon');
                    if (icon) {
                        icon.style.filter = 'grayscale(0%)';
                        icon.style.opacity = '1';
                    }
                } else {
                    element.classList.remove('unlocked');
                    const icon = element.querySelector('.achievement-icon');
                    if (icon) {
                        icon.style.filter = 'grayscale(100%)';
                        icon.style.opacity = '0.3';
                    }
                }
            }
        });
    }
    
    handlePush() {
        this.playSound('push');
        
        // Push back nearby projectiles
        this.projectiles.forEach(projectile => {
            const distance = projectile.position.distanceTo(this.player.position);
            if (distance < 3) {
                projectile.velocity.multiplyScalar(-1.5);
            }
        });
    }
    
    updateCombo() {
        const now = Date.now();
        if (now - this.lastBlockTime < 2000) {
            this.comboCount++;
            this.lastBlockTime = now;
            
            const comboDisplay = document.getElementById('comboDisplay');
            const comboValue = document.getElementById('comboValue');
            if (comboDisplay && comboValue) {
                comboValue.textContent = this.comboCount;
                comboDisplay.classList.add('show');
                
                if (this.comboCount >= 5) {
                    this.fabPower = Math.min(this.fabPowerMax, this.fabPower + 5);
                    if (this.comboCount % 10 === 0) {
                        this.showNotification(`MEGA COMBO x${this.comboCount}!`);
                        this.score += 50;
                        // Check achievements after big combo
                        this.checkAchievements();
                    }
                }
            }
        } else {
            this.resetCombo();
        }
    }
    
    resetCombo() {
        this.comboCount = 0;
        const comboDisplay = document.getElementById('comboDisplay');
        if (comboDisplay) {
            comboDisplay.classList.remove('show');
        }
    }
    
    createBlockParticles(position) {
        const particleCount = 10;
        const particles = [];
        
        for (let i = 0; i < particleCount; i++) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                transparent: true
            });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.copy(position);
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                Math.random() * 5,
                (Math.random() - 0.5) * 5
            );
            particle.lifetime = 1;
            particles.push(particle);
            this.scene.add(particle);
        }
        
        const animateParticles = () => {
            particles.forEach((particle, index) => {
                particle.position.add(particle.velocity.clone().multiplyScalar(0.02));
                particle.velocity.y -= 0.1;
                particle.lifetime -= 0.02;
                particle.material.opacity = particle.lifetime;
                
                if (particle.lifetime <= 0) {
                    this.scene.remove(particle);
                    particles.splice(index, 1);
                }
            });
            
            if (particles.length > 0) {
                requestAnimationFrame(animateParticles);
            }
        };
        
        animateParticles();
    }
    
 updatePlayer(deltaTime) {
    const speed = 5;
    let playerState = 'idle';
    let direction = 'front';
    
    // Apply dash velocity (mobile swipe-to-dash)
    if (this.dashDuration > 0) {
        this.player.position.x += this.dashVelocity * deltaTime;
        this.dashDuration -= deltaTime;
        if (this.dashDuration <= 0) {
            this.dashVelocity = 0;
        }
    }
    
    // Update dash cooldown
    if (this.dashCooldown > 0) {
        this.dashCooldown -= deltaTime;
    }

    // Handle horizontal movement - prevent conflicting inputs
    const leftPressed = this.keys['ArrowLeft'] || this.touchControls.left;
    const rightPressed = this.keys['ArrowRight'] || this.touchControls.right;

    // Priority system: if both keys pressed, use most recent input
    if (leftPressed && rightPressed) {
        // Both pressed - check which was pressed more recently or default to no movement
        if (this.lastKeyTime && this.lastKeyTime.left > this.lastKeyTime.right) {
            this.player.position.x -= speed * deltaTime;
            direction = 'left';
        } else if (this.lastKeyTime && this.lastKeyTime.right > this.lastKeyTime.left) {
            this.player.position.x += speed * deltaTime;
            direction = 'right';
        }
        // If no clear priority, don't move
    } else if (leftPressed && !rightPressed) {
        this.player.position.x -= speed * deltaTime;
        direction = 'left';
    } else if (rightPressed && !leftPressed) {
        this.player.position.x += speed * deltaTime;
        direction = 'right';
    }
    
    // Real-time mobile detection for accurate boundaries
    const isCurrentlyMobile = window.innerWidth <= 768;
    
    // Account for sprite width (1.5 units) - subtract half width (0.75) from bounds
    const spriteHalfWidth = 0.75;
    const stageBounds = {  
        'rally': isCurrentlyMobile ? (1.8 - spriteHalfWidth) : (4.0 - spriteHalfWidth),
        'street': isCurrentlyMobile ? (1.6 - spriteHalfWidth) : (3.8 - spriteHalfWidth), 
        'wedding': isCurrentlyMobile ? (1.8 - spriteHalfWidth) : (4.0 - spriteHalfWidth),
        'cricket': isCurrentlyMobile ? (1.8 - spriteHalfWidth) : (4.0 - spriteHalfWidth),
        'debate': isCurrentlyMobile ? (1.4 - spriteHalfWidth) : (3.6 - spriteHalfWidth)
    }; 

    const boundLimit = stageBounds[this.currentStage] || (isCurrentlyMobile ? (1.6 - spriteHalfWidth) : (3.5 - spriteHalfWidth));

    // Anti-sticking logic with bounce-back
    if (this.player.position.x > boundLimit) {
        this.player.position.x = boundLimit - 0.05; // Bounce slightly inward
    } else if (this.player.position.x < -boundLimit) {
        this.player.position.x = -boundLimit + 0.05; // Bounce slightly inward
    }

    // Ensure bounds are respected
    this.player.position.x = Math.max(-boundLimit, Math.min(boundLimit, this.player.position.x));

// ENHANCED DEBUG: Complete boundary sticking analysis - ADD THIS BLOCK
if (this.currentStage === 'debate') {
    const currentX = this.player.position.x;
    const leftKey = this.keys['ArrowLeft'];
    const rightKey = this.keys['ArrowRight'];
    const hasInput = leftKey || rightKey;
    
    // Track previous position and movement history
    if (!this.debugData) {
        this.debugData = {
            prevX: currentX,
            stuckFrames: 0,
            movementHistory: [],
            lastInputTime: 0
        };
    }
    
    const positionChanged = Math.abs(currentX - this.debugData.prevX) > 0.001;
    const timeSinceInput = Date.now() - this.debugData.lastInputTime;
    
    // Record movement attempt
    if (hasInput) {
        this.debugData.lastInputTime = Date.now();
        this.debugData.movementHistory.push({
            frame: Date.now(),
            x: currentX,
            leftKey,
            rightKey,
            moved: positionChanged
        });
        
        // Keep only last 10 movements
        if (this.debugData.movementHistory.length > 10) {
            this.debugData.movementHistory.shift();
        }
    }
    
    // Detect boundary sticking
    const isAtLeftBoundary = Math.abs(currentX - (-boundLimit)) < 0.02;
    const isAtRightBoundary = Math.abs(currentX - boundLimit) < 0.02;
    const isAtAnyBoundary = isAtLeftBoundary || isAtRightBoundary;
    
    // Count stuck frames
    if (hasInput && !positionChanged && isAtAnyBoundary) {
        this.debugData.stuckFrames++;
    } else {
        this.debugData.stuckFrames = 0;
    }
    
    // Log detailed sticking info when stuck for multiple frames
    if (this.debugData.stuckFrames > 0 && this.debugData.stuckFrames % 30 === 1) {
        console.group("🚨 BOUNDARY STICKING ANALYSIS");
        console.log("Position:", currentX.toFixed(4));
        console.log("Bound limit:", boundLimit.toFixed(4));
        console.log("Stuck side:", isAtLeftBoundary ? 'LEFT' : 'RIGHT');
        console.log("Input:", {leftKey, rightKey});
        console.log("Stuck frames:", this.debugData.stuckFrames);
        console.log("Expected movement:", leftKey ? 'LEFT (inward)' : 'RIGHT (inward)');
        
        // Check if trying to move inward (should work) or outward (should be blocked)
        const tryingToMoveInward = (isAtLeftBoundary && rightKey) || (isAtRightBoundary && leftKey);
        const tryingToMoveOutward = (isAtLeftBoundary && leftKey) || (isAtRightBoundary && rightKey);
        
        console.log("Movement direction:", {
            inward: tryingToMoveInward,
            outward: tryingToMoveOutward,
            problem: tryingToMoveInward ? "SHOULD MOVE BUT STUCK" : "correctly blocked"
        });
        
        // Check movement speed calculation
        const speed = 5;
        const deltaTime = 1/60; // Approximate
        const expectedMovement = speed * deltaTime;
        console.log("Movement calculation:", {
            speed,
            deltaTime: deltaTime.toFixed(4),
            expectedMovement: expectedMovement.toFixed(4)
        });
        
        // Show recent movement history
        console.log("Recent movement attempts:", this.debugData.movementHistory.slice(-5));
        
        // Test manual position setting
        if (tryingToMoveInward) {
            const testX = isAtLeftBoundary ? currentX + 0.1 : currentX - 0.1;
            console.log("Testing manual position set:", testX.toFixed(4));
            this.player.position.x = testX;
            console.log("After manual set:", this.player.position.x.toFixed(4));
        }
        
        console.groupEnd();
    }
    
    // Track position changes
    this.debugData.prevX = currentX;
    
    // Emergency unstick after being stuck too long
    if (this.debugData.stuckFrames > 120) { // 2 seconds at 60fps
        console.warn("EMERGENCY UNSTICK ACTIVATED");
        if (isAtLeftBoundary) {
            this.player.position.x = -boundLimit + 0.2;
        } else if (isAtRightBoundary) {
            this.player.position.x = boundLimit - 0.2;
        }
        this.debugData.stuckFrames = 0;
    }
}
// END ENHANCED DEBUG BLOCK
// END DEBUG BLOCK

    // Handle jumping physics
    if (this.isJumping) {
        this.playerVelocityY += this.gravity * deltaTime;
        this.player.position.y += this.playerVelocityY * deltaTime;
    
        if (this.player.position.y <= this.groundY) {
            this.player.position.y = this.groundY;
            this.isJumping = false;
            this.playerVelocityY = 0;
        }
        playerState = 'jump';
    }
    

    // Shield
if (this.keys['Shift'] || this.touchControls.shield) {
    this.player.shield.visible = true;
    
    // Desktop shield glow effect matching mobile
    if (!this.isMobile) {
        console.log('Activating desktop shield glow');
        console.log('Shield userData:', this.player.shield.userData);
        
        if (this.player.shield.userData && this.player.shield.userData.ring) {
            this.player.shield.userData.ring.material.emissiveIntensity = 0.8;
            this.player.shield.userData.glow.material.opacity = 0.6;
            this.player.shield.scale.set(1.2, 1.2, 1.2);
            console.log('Shield glow activated - ring intensity:', this.player.shield.userData.ring.material.emissiveIntensity);
        }
    }
    playerState = 'shield';
} else {
    this.player.shield.visible = false;
    
    // Reset shield glow when not active
    if (!this.isMobile && this.player.shield.userData && this.player.shield.userData.ring) {
        this.player.shield.userData.ring.material.emissiveIntensity = 0.4;
        this.player.shield.userData.glow.material.opacity = 0.3;
        this.player.shield.scale.set(1, 1, 1);
    }
}
    
    // Push
    if (this.keys['x'] || this.keys['X']) {
        this.handlePush();
        playerState = 'push';
        this.keys['x'] = false;
        this.keys['X'] = false;
    }
    
    // Update sprite texture based on direction
    if (this.player.textures && this.player.textures[direction]) {
        this.player.material.map = this.player.textures[direction];
        this.player.material.needsUpdate = true;
    }
    
    // Animate sprite
    this.animateSprite(this.player, deltaTime, playerState);
}

initNotificationSystem() {
    this.notificationContainer = document.createElement('div');
    this.notificationContainer.id = 'unifiedNotificationContainer';
    this.notificationContainer.style.cssText = `
        position: fixed;
        z-index: 1010;
        pointer-events: none;
        display: none;
    `;
    document.body.appendChild(this.notificationContainer);
}

queueNotification(message, duration = 2500) {
    console.log("📢 QUEUE NOTIFICATION:", message, "Queue length:", this.notificationQueue.length);
    this.notificationQueue.push({ message, duration, timestamp: Date.now() });
    
    if (!this.notificationProcessing) {
        this.processNotificationQueue();
    }
}

processNotificationQueue() {
    if (this.notificationQueue.length === 0) {
        this.notificationProcessing = false;
        console.log("📢 QUEUE EMPTY - Processing stopped");
        return;
    }
    
    console.log("📢 PROCESSING NOTIFICATION QUEUE - Length:", this.notificationQueue.length);
    this.notificationProcessing = true;
    const notification = this.notificationQueue.shift();
    this.displayNotification(notification);
}

displayNotification(notification) {
    console.log('displayNotification CALLED with:', notification.message);
    console.log('Current container before changes:', this.notificationContainer.style.cssText);
    
    const currentWidth = window.innerWidth;
    const isMobileScreen = currentWidth <= 768;
    
    console.log("displayNotification executing - width:", currentWidth, "isMobile:", isMobileScreen);
    
    // Mobile vs Desktop positioning
    let topPosition, leftPosition, rightPosition, transform, textAlign, maxWidth;
    
    if (isMobileScreen) {
        // Position under score container on mobile
        topPosition = '60px';
        rightPosition = '15px';
        leftPosition = 'auto';
        transform = 'none';
        textAlign = 'right';
        maxWidth = '200px';
    } else {
        // Center position for desktop
        topPosition = '120px';
        leftPosition = '50%';
        rightPosition = 'auto';
        transform = 'translateX(-50%)';
        textAlign = 'center';
        maxWidth = '400px';
    }
    
    console.log("Calculated topPosition:", topPosition);
    
    const fontSize = isMobileScreen ? '0.75em' : '1.1em';
    const padding = isMobileScreen ? '8px 12px' : '15px 30px';
    const borderRadius = isMobileScreen ? '8px' : '12px';
    
    // Set content first
    this.notificationContainer.innerHTML = `
        <div style="
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: ${borderRadius};
            padding: ${padding};
            color: white;
            font-weight: bold;
            font-size: ${fontSize};
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            text-align: ${textAlign};
            max-width: ${maxWidth};
        ">${notification.message}</div>
    `;
    
    // Apply positioning and show - individual properties
setTimeout(() => {
    const container = this.notificationContainer;
    
    // Clear conflicting styles first
    container.style.left = '';
    container.style.right = '';
    container.style.transform = '';
    
    // Set new positioning
    container.style.position = 'fixed';
    container.style.zIndex = '9999';
    container.style.pointerEvents = 'none';
    container.style.display = 'block';
    
    if (isMobileScreen) {
        container.style.top = '60px';
        container.style.right = '15px';
        container.style.left = 'auto';
        container.style.transform = 'none';
    } else {
        container.style.top = '120px';
        container.style.left = '50%';
        container.style.right = 'auto';
        container.style.transform = 'translateX(-50%)';
    }
    
    console.log("Applied positioning - top:", container.style.top, "right:", container.style.right);
}, 10);
    
    // Faster fade for mobile, normal for desktop
    const displayDuration = isMobileScreen ? notification.duration * 0.6 : notification.duration;
    const queueDelay = isMobileScreen ? 200 : 300;
    
    // Hide after duration
    setTimeout(() => {
        if (this.notificationContainer) {
            this.notificationContainer.style.display = 'none';
        }
        setTimeout(() => this.processNotificationQueue(), queueDelay);
    }, displayDuration);
}
    
showNotification(message, backgroundColor) {
    const isMobileScreen = window.innerWidth <= 768;
    
    if (isMobileScreen) {
        this.showMobileNotification(message, backgroundColor);
    } else {
        this.queueNotification(message);
    }
}

showMobileNotification(message, backgroundColor = 'rgba(255, 255, 255, 0.08)') {
    const container = document.getElementById('mobileNotificationContainer');
    if (!container) {
        console.log('Mobile notification container not found');
        return;
    }
    
    console.log('Creating mobile notification:', message);
    
    const notification = document.createElement('div');
    notification.className = 'mobile-notification-item';
    notification.style.background = backgroundColor;
    
    // Handle multi-line text for specific stages
    if (message === 'Street Fundraiser') {
        notification.innerHTML = 'Street<br>Fundraiser';
    } else if (message === 'Wedding Celebration') {
        notification.innerHTML = 'Wedding<br>Celebration';
    } else {
        notification.textContent = message;
    }
    
    container.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
        notification.classList.add('show');
    }, 10);
    
    // Remove after duration
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
            if (notification.parentNode) {
                container.removeChild(notification);
            }
        }, 300);
    }, 1500);
}
    
    updatePowerBar() {
        const powerBar = document.getElementById('powerBar');
        if (powerBar) {
            powerBar.style.width = (this.fabPower / this.fabPowerMax * 100) + '%';
        }
        
        const superShieldIcon = document.getElementById('superShieldIcon');
        const slowMotionIcon = document.getElementById('slowMotionIcon');
        const fabBombIcon = document.getElementById('fabBombIcon');
        
        if (superShieldIcon) {
            superShieldIcon.style.opacity = this.fabPower >= 25 ? '1' : '0.3';
        }
        if (slowMotionIcon) {
            slowMotionIcon.style.opacity = this.fabPower >= 30 ? '1' : '0.3';
        }
        if (fabBombIcon) {
            fabBombIcon.style.opacity = this.fabPower >= 50 ? '1' : '0.3';
        }
    }
    
    checkStageTransition() {
        const stageThresholds = {
            'rally': { score: 50, next: 'street' },
            'street': { score: 120, next: 'wedding' },
            'wedding': { score: 200, next: 'cricket' },
            'cricket': { score: 300, next: 'debate' },
            'debate': { score: Infinity, next: null }
        };
        
        const threshold = stageThresholds[this.currentStage];
        if (this.score >= threshold.score && threshold.next) {
            this.transitionToStage(threshold.next);
        }
    }
    
transitionToStage(newStage) {
    this.currentStage = newStage;
    this.createStageBackground(newStage);
    this.createStageSpecificCrowd(newStage);
    this.createPodium(newStage);
    this.scene.add(this.podium);

    // Handle animated clouds for stage transitions
    if (this.currentStage === 'rally' && newStage !== 'rally') {
        this.removeAnimatedClouds();
    } else if (newStage === 'rally') {
        this.createAnimatedClouds();
    }
    
    const stageNames = {
        'rally': 'Political Rally',
        'street': 'Street Fundraiser',
        'wedding': 'Wedding Celebration',
        'cricket': 'Cricket Stadium',
        'debate': 'Debate Studio'
    };
    
    // Stage background colors
    const stageColors = {
        'rally': 'linear-gradient(135deg, rgba(70, 130, 180, 0.8), rgba(100, 149, 237, 0.8))', // Blue
        'street': 'linear-gradient(135deg, rgba(105, 105, 105, 0.8), rgba(128, 128, 128, 0.8))', // Gray
        'wedding': 'linear-gradient(135deg, rgba(255, 182, 193, 0.8), rgba(255, 105, 180, 0.8))', // Pink
        'cricket': 'linear-gradient(135deg, rgba(34, 139, 34, 0.8), rgba(50, 205, 50, 0.8))', // Green
        'debate': 'linear-gradient(135deg, rgba(25, 25, 112, 0.8), rgba(72, 61, 139, 0.8))' // Dark Blue
    };

    this.showNotification(stageNames[newStage], stageColors[newStage]);
    
    // Clear stains and obstacles on transition
    this.stains.forEach(stain => this.scene.remove(stain));
    this.stains = [];
    this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
    this.obstacles = [];
    
    // Reset stage-specific values
    this.crowdMood = 50;
    this.splatterMeter = 0;
    this.perceptionMeter = 50;
    this.greaseBlurActive = false;
    this.flashDazeActive = false;
    
    // Show appropriate stage mechanics UI
    this.showStageMechanics(newStage);
    
    // Change music to new stage
    this.startStageMusic();
    
    // Play transition sound
    this.playSound('powerup');
    
    // Increase difficulty
    this.projectileInterval = Math.max(500, this.projectileInterval - 120);
    // Check stage-related achievements immediately
    this.checkAchievements();
}
    createStageAnimations(stage) {
        // Clean up previous stage animations
        this.removeAnimatedClouds();
        
        // Create stage-specific animations
        switch(stage) {
            case 'rally':
                this.createAnimatedClouds();
                break;
        }
    }
    
    updateScore() {
        const scoreElement = document.getElementById('scoreValue');
        const mobileScoreElement = document.getElementById('mobileScoreValue');
        if (scoreElement) {
            scoreElement.textContent = this.score;
        }
        if (mobileScoreElement) {
            mobileScoreElement.textContent = this.score;
        }

       // Check achievements immediately when score updates
        this.checkAchievements();
    }
    updateMultiplierDisplay() {
        const multiplierDisplay = document.getElementById('multiplierDisplay');
        const multiplierValue = document.getElementById('multiplierValue');
        
        if (multiplierDisplay && multiplierValue) {
            multiplierValue.textContent = this.scoreMultiplier;
            if (this.scoreMultiplier > 1) {
                multiplierDisplay.classList.add('show');
            } else {
                multiplierDisplay.classList.remove('show');
            }
        }
    }
    
   updateHealth() {
    const healthBar = document.getElementById('healthBar');
    if (healthBar) {
        const healthPercent = (this.health / 200) * 100; // Convert to percentage
        healthBar.style.width = healthPercent + '%';
        
        // Update health bar color based on health level
        if (this.health > 120) { // 60% of 200
            healthBar.className = 'hud-bar-fill health-bar';
        } else if (this.health > 60) { // 30% of 200
            healthBar.className = 'hud-bar-fill health-bar warning';
        } else {
            healthBar.className = 'hud-bar-fill health-bar danger';
        }
    }
}
    
  startGame() {
    this.hideStartScreen();
    this.showGameHUD();
    
    // Reset game state
    this.score = 0;
    this.health = 200;
    this.blockedCount = 0;
    this.totalProjectiles = 0;
    this.gameStartTime = Date.now();
    this.currentStage = 'rally';
    this.projectileInterval = 3000;
    this.baseProjectileInterval = 3000;
    this.fabPower = 0;
    this.comboCount = 0;
    
    // Reset adaptive difficulty
    this.difficultyLevel = 1;
    this.performanceScore = 0;
    this.recentBlocks = [];
    
    // Reset score multiplier
    this.scoreMultiplier = 1;
    this.updateMultiplierDisplay();
    
    // Reset achievements for new game (optional - could persist)
    this.usedPowerUps = new Set();

    // Reset consecutive hit tracking
    console.log("🔄 START GAME: Resetting consecutive hits");
    this.consecutiveHits = 0;

    // Reset warning flags
    this.warningShown3 = false;
    this.warningShown4 = false;
    this.criticalWarningTime = 0;

    // Reset all achievement states and counters
    Object.values(this.achievements).forEach(achievement => {
        achievement.unlocked = false;
    });
    
    // Reset achievement-related counters
    this.fabBombCount = 0;
    this.dodgeCount = 0;
    this.lastAchievementCheck = 0;
    
    // Initialize achievement board
    this.initializeAchievementBoard();

     // Force visual refresh of achievement board
    this.refreshAchievementVisuals();
    
    // Reset stage-specific mechanics
    this.crowdMood = 50;
    this.splatterMeter = 0;
    this.perceptionMeter = 50;
    this.greaseBlurActive = false;
    this.flashDazeActive = false;
    this.powerHitWarning = false;
    this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
    this.obstacles = [];
    
    // Proper cleanup of all game objects
    this.cleanupProjectiles();
    this.cleanupStains();
    this.cleanupPowerUps();
    
    this.createStageBackground('rally');
    this.scene.add(this.player);
    this.scene.add(this.politician);
    this.createPodium('rally');
    this.scene.add(this.podium);
    // Handle stage-specific animations
    this.createAnimatedClouds();
    // Crowd will be created automatically when sheets finish loading
    // via onAllCrowdSheetsLoaded() callback
    
    // Show rally mechanics UI
    this.showStageMechanics('rally');
    
    this.updateScore();
    this.updateHealth();
    this.updatePowerBar();
    
    this.isRunning = true;
    this.gameLoop();

    // Start background music (handle autoplay restrictions)
    if (this.backgroundMusic && !this.globalMuted) {
        this.backgroundMusic.play().catch(error => {
            console.log('Autoplay prevented - music will start on first user interaction');
            // Music will start when user clicks mute button or interacts
        });
    }

    // Show initial stage notification
    this.showNotification('Political Rally', 'linear-gradient(135deg, rgba(70, 130, 180, 0.8), rgba(100, 149, 237, 0.8))');
}

cleanupProjectiles() {
    this.projectiles.forEach(projectile => {
        this.scene.remove(projectile);
        // Dispose of materials and geometries to free memory
        projectile.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (child.material.map) child.material.map.dispose();
                child.material.dispose();
            }
        });
    });
    this.projectiles = [];
}

cleanupStains() {
    this.stains.forEach(stain => {
        this.scene.remove(stain);
        if (stain.geometry) stain.geometry.dispose();
        if (stain.material) stain.material.dispose();
    });
    this.stains = [];
}

cleanupPowerUps() {
    this.powerUps.forEach(powerUp => {
        this.scene.remove(powerUp);
        powerUp.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (child.material.map) child.material.map.dispose();
                child.material.dispose();
            }
        });
    });
    this.powerUps = [];
}

    initializeAchievementBoard() {
        const achievementBoard = document.getElementById('achievementBoard');
        const achievementList = document.getElementById('achievementList');
        
        if (!this.isMobile && achievementBoard && achievementList) {
             // Clear existing content first
            achievementList.innerHTML = '';
            achievementBoard.classList.add('show');
            
            Object.values(this.achievements).forEach(achievement => {
                const item = document.createElement('div');
                item.className = 'achievement-item';
                item.setAttribute('data-achievement', achievement.id);
                if (achievement.unlocked) {
                    item.classList.add('unlocked');
                }
                item.innerHTML = `
                    <div class="achievement-icon">${achievement.icon}</div>
                    <div class="achievement-info">
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-desc">${achievement.desc}</div>
                    </div>
                `;
                achievementList.appendChild(item);
            });
        }
    }
    
    gameLoop() {
        if (!this.isRunning) return;
        
        requestAnimationFrame(() => this.gameLoop());
        const deltaTime = this.clock.getDelta();
        const effectiveDeltaTime = this.slowMotionActive ? deltaTime * 0.5 : deltaTime;
        
        // Spawn projectiles
        const dynamicInterval = this.projectileInterval - (this.difficultyLevel * 50); // Slower difficulty ramp
        if (Date.now() - this.lastProjectileTime > Math.max(400, dynamicInterval)) {
            this.spawnProjectile();
            this.lastProjectileTime = Date.now();
        }
        
        // Update game elements
        this.updatePlayer(effectiveDeltaTime);
        this.updateProjectiles(effectiveDeltaTime);
        this.updateCrowd(effectiveDeltaTime);
        this.updateIntegratedStageMeter();
        this.updateAnimatedClouds(effectiveDeltaTime);
        this.updatePowerBar();
        // Desktop-enhanced particle updates
        if (!this.isMobile) {
            this.updateDesktopParticleEffects(effectiveDeltaTime);
        }
        this.updateStageMechanics(effectiveDeltaTime);
        this.checkStageTransition();
        
        // Animate politician sprite
        if (this.politician) {
            this.animateSprite(this.politician, effectiveDeltaTime, 'idle');
        }
        
        // Desktop selective bloom rendering
        if (!this.isMobile && this.bloomEnabled) {
            this.renderWithBloom();
        } else {
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    updateDesktopParticleEffects(deltaTime) {
        // Enhanced shield glow animation for desktop
        if (this.player.shield.visible && this.player.shield.userData) {
            this.player.shield.userData.pulseTime += deltaTime * 2;
            const pulse = Math.sin(this.player.shield.userData.pulseTime) * 0.3 + 0.7;
            this.player.shield.userData.ring.material.emissiveIntensity = pulse * 0.6;
            this.player.shield.userData.glow.material.opacity = pulse * 0.4;
        }
    }
    
    renderWithBloom() {
        // Simple bloom implementation for desktop
        if (this.bloomObjects.size > 0) {
            // Render bloom objects with enhanced glow
            this.bloomObjects.forEach(obj => {
                if (obj.material) obj.material.emissiveIntensity *= 1.5;
            });
        }

        // Render
        this.renderer.render(this.scene, this.camera);
    }
    
 endGame() {
    this.isRunning = false;

    // COMPLETE AUDIO CLEANUP
    this.stopMusic();
    this.continuousMusicPlaying = false; // Stop continuous music flag

    // Stop background music
    if (this.backgroundMusic) {
        this.backgroundMusic.pause();
        this.backgroundMusic.currentTime = 0;
    }
    
    if (this.audioContext && this.audioContext.state === 'running') {
        this.audioContext.suspend();
    }
    
    // Clear any ongoing audio loops - FIXED to use clearInterval
    if (this.currentMusicLoop) {
        clearInterval(this.currentMusicLoop); // Changed from clearTimeout
        this.currentMusicLoop = null;
    }
    
    this.hideGameHUD();
    
    const sessionTime = Math.floor((Date.now() - this.gameStartTime) / 1000);
    const accuracy = this.totalProjectiles > 0 ? 
        Math.floor((this.blockedCount / this.totalProjectiles) * 100) : 0;
    
    document.getElementById('finalScore').textContent = this.score;
    document.getElementById('sessionTime').textContent = sessionTime;
    document.getElementById('accuracyPercent').textContent = accuracy;
    document.getElementById('hitStats').textContent = `${this.blockedCount}/${this.totalProjectiles}`;
    document.getElementById('blockedCount').textContent = this.blockedCount;
    
    const performanceRating = this.calculatePerformanceRating();
    const ratingElement = document.getElementById('performanceRating');
    if (ratingElement) {
        ratingElement.textContent = performanceRating.message;
        ratingElement.style.color = performanceRating.color;
    }
    
    generateQRCode();
    
    setTimeout(() => {
        if (!window.product3DViewer) {
            window.product3DViewer = new Product3DViewer('product3DCanvas', 'product3DContainer');
        }
    }, 500);
    
    this.showResultsScreen();
}

    calculatePerformanceRating() {
        const accuracy = this.totalProjectiles > 0 ? 
            Math.floor((this.blockedCount / this.totalProjectiles) * 100) : 0;
        
        if (this.score >= 500 && accuracy >= 80) {
            return { 
                message: 'Waah! Fab ka asli defender!', 
                color: '#FFD700' 
            };
        } else if (this.score >= 300 && accuracy >= 60) {
            return { 
                message: 'Great job! Politician is safe!', 
                color: '#00FF00' 
            };
        } else if (this.score >= 100 && accuracy >= 40) {
            return { 
                message: 'Good start! Keep protecting!', 
                color: '#87CEEB' 
            };
        } else {
            return { 
                message: 'Abhi practice karo yaar!', 
                color: '#FFA500' 
            };
        }
    }
    
   onResize() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height, false);
    
    // Maintain exact canvas positioning on resize
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
    this.canvas.style.bottom = '0px';
    this.canvas.style.right = '0px';
}
    
    // UI Management
    hideLoadingScreen() {
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) {
            loadingScreen.style.display = 'none';
        }
    }
    
   showStartScreen() {
    let startScreen = document.getElementById('startScreen');
    if (!startScreen) {
        // Element was removed, recreate it
        startScreen = document.createElement('div');
        startScreen.id = 'startScreen';
        startScreen.className = 'start-screen';
        startScreen.innerHTML = `
            <div class="start-card">
                <div class="fab-logo">
                    <img src="https://assets.codepen.io/t-24779/FAB-Liquid.png" alt="FAB Liquid" class="fab-logo-img">
                </div>
                <h1 class="game-main-title">Stain Slayer</h1>
                <div class="character-preview">
                    <img src="https://assets.codepen.io/t-24779/game-start-image.png" alt="Game Character" class="character-preview-img">
                </div>
                <p class="game-subtitle">
                    <strong>Block stains, score lasting freshness!</strong>
                </p>
                <button id="startButton" class="play-button">Play Game</button>
            </div>
        `;
        document.body.appendChild(startScreen);
        
        // Re-attach start button event listener
        const startBtn = document.getElementById('startButton');
        if (startBtn) {
            startBtn.addEventListener('click', () => {
                this.startGame();
            });
        }
    }
    
    startScreen.classList.remove('hidden');
}
    
hideStartScreen() {
    // Remove ALL elements with start screen classes/IDs
    const startScreens = document.querySelectorAll('#startScreen, .start-screen');
    startScreens.forEach(element => {
        element.remove();
    });
    
    // Double-check by forcing any remaining ones off-screen
    const anyRemaining = document.getElementById('startScreen');
    if (anyRemaining) {
        anyRemaining.style.display = 'none';
        anyRemaining.style.position = 'absolute';
        anyRemaining.style.top = '-9999px';
        anyRemaining.style.left = '-9999px';
        anyRemaining.style.zIndex = '-9999';
    }
}
    showGameHUD() {
        const gameHUD = document.getElementById('gameHUD');
        const mobileControls = document.getElementById('mobileControls');
        if (gameHUD) gameHUD.classList.add('show');
        if (mobileControls && window.innerWidth <= 768) {
            mobileControls.classList.add('show');
        }
    }
    
    hideGameHUD() {
        const gameHUD = document.getElementById('gameHUD');
        const mobileControls = document.getElementById('mobileControls');
        if (gameHUD) gameHUD.classList.remove('show');
        if (mobileControls) mobileControls.classList.remove('show');
    }
    
    showResultsScreen() {
        const resultsScreen = document.getElementById('resultsScreen');
        if (resultsScreen) {
            resultsScreen.classList.add('show');
        }
    }
}

// Global functions
window.generateQRCode = generateQRCode;
window.saveGameCode = saveGameCode;
window.buyFabProduct = buyFabProduct;
window.shareOnWhatsApp = shareOnWhatsApp;
window.Product3DViewer = Product3DViewer;

window.playAgain = function() {
    if (window.product3DViewer) {
        try {
            window.product3DViewer.destroy();
        } catch (error) {
            console.warn('Error destroying 3D viewer:', error);
        }
        window.product3DViewer = null;
    }
    
    const resultsScreen = document.getElementById('resultsScreen');
    if (resultsScreen) {
        resultsScreen.classList.remove('show');
    }

    // Reset all achievement states for new game
    if (window.game) {
        Object.values(window.game.achievements).forEach(achievement => {
            achievement.unlocked = false;
        });
        
        // Reset achievement counters
        window.game.fabBombCount = 0;
        window.game.dodgeCount = 0;
        window.game.usedPowerUps = new Set();
    }
    
    setTimeout(() => {
        if (window.game) {
            window.game.startGame();
        }
    }, 100);
};

// Initialize game
window.game = new StainSlayerGame();
</script>
</body>
</html>
        