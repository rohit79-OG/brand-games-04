<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#FF4500">
    <meta name="description" content="Stain Slayer - Defend white clothes with Godrej Fab!">
    <title>Stain Slayer - Godrej Fab Game</title>
    
    <style>

/* iOS Safari specific fix */
@supports (-webkit-touch-callout: none) {
    html, body {
        background: linear-gradient(135deg, #FFD400, #FFA500) !important;
        background-attachment: fixed !important;
    }
    
    body::before {
        content: '';
        position: fixed;
        top: -100px;
        left: 0;
        right: 0;
        height: 100px;
        background: linear-gradient(135deg, #FFD400, #FFA500);
        z-index: 10000;
    }
}

/* Force viewport background for all mobile browsers */
html {
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    min-height: 100vh;
}

/* ============================================
   GAME CSS 
   ============================================ */

/* Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* BACKGROUND SYSTEM - Yellow gradient */
body {
    font-family: 'sans-serif', Arial;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    background-image: linear-gradient(135deg, #FFD400, #FFA500) !important;
    overflow: hidden;
    touch-action: manipulation;
    user-select: none;
    -webkit-user-select: none;
    height: 100vh;
}

/* GAME CONTAINER - Transparent to show background */
#gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    background: transparent !important;
    background-color: transparent !important;
}

/* Prevent images from covering the game */
#gameContainer img {
    max-width: 200px !important;
    max-height: 200px !important;
    position: relative !important;
    z-index: 999 !important;
}

/* GAME CANVAS - Sky background during gameplay */
#gameCanvas {
    background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 100%) !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    height: 100dvh;
    display: block;
    touch-action: none;
    z-index: 1000 !important;
    pointer-events: auto;
    border: none !important; 
    outline: none !important;
    box-shadow: none !important;
    border-width: 0 !important;
    border-style: none !important;
    border-color: transparent !important;
}

/* Enhanced canvas border prevention */
canvas,
#gameCanvas,
#product3DCanvas {
    border: none !important;
    outline: none !important;
    box-shadow: none !important;
    border-width: 0 !important;
    border-style: none !important;
    border-color: transparent !important;
}

/* ============================================
   SCREEN SYSTEM - Loading, Start, Results
   ============================================ */

/* LOADING SCREEN */
.loading-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    padding: 0 !important;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10000 !important;
    color: white;
}

.loading-card {
    background: linear-gradient(135deg, rgba(255, 212, 0, 0.9), rgba(255, 165, 0, 0.9));
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 215, 0, 0.3);
    max-width: 400px;
    width: 90%;
}

.loading-title {
    font-size: 2.5em;
    font-weight: bold;
    color: #0097D7;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.loading-subtitle {
    font-size: 1.2em;
    color: #1A2F85;
    margin-bottom: 30px;
    font-weight: bold;
}

.loading-progress {
    width: 100%;
    height: 8px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 20px;
}

.loading-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #FFD700, #FFA500);
    border-radius: 4px;
    transition: width 0.3s ease;
    animation: pulse 1.5s infinite;
}

.loading-tip {
    font-size: 1.1em;
    color: #1A2F85;
    font-style: italic;
}

/* START SCREEN */
.start-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    padding: 0 !important;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9000 !important;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease;
    transform: translateY(-100vh);
}

.start-screen:not(.hidden) {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    transform: translateY(0) !important;
}

.start-screen.hidden {
    opacity: 0;
    pointer-events: none;
    display: none !important;
    visibility: hidden !important;
    transform: translateY(-100vh) !important;
}

.start-card {
    background: linear-gradient(135deg, rgba(255, 212, 0, 0.9), rgba(255, 165, 0, 0.9));
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 215, 0, 0.3);
    max-width: 400px;
    width: 90%;
    color: white;
}

.fab-logo-img {
    height: 100px;
    width: auto;
    margin-bottom: 10px;
}

.game-main-title {
    font-size: 3em;
    font-weight: bold;
    color: #0097D7;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.game-subtitle {
    font-size: 1.1em;
    margin-bottom: 30px;
    line-height: 1.4;
    color: rgba(255, 255, 255, 0.9);
}

.character-preview-img {
    width: 120px;
    height: 120px;
    object-fit: contain;
    animation: float 3s ease-in-out infinite;
}

.play-button {
    background: linear-gradient(45deg, #1A2F85, #2A3F95);
    border: none;
    padding: 15px 40px;
    font-size: 1.3em;
    font-weight: bold;
    color: #FFFFFF;
    border-radius: 25px;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s ease;
    pointer-events: all;
    margin-top: 10px;
}

.play-button:hover {
    transform: scale(1.05);
}

.play-button:active {
    transform: scale(0.95);
}

/* RESULTS SCREEN */
.results-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    margin: 0 !important;
    padding: 20px !important;
    background: linear-gradient(135deg, #FFD400, #FFA500) !important;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 8000 !important;
    color: white;
    visibility: hidden;
    opacity: 0;
    transform: translateY(-100vh);
    pointer-events: none;
}

.results-screen.show {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    z-index: 10000 !important;
    transform: translateY(0) !important;
    pointer-events: auto !important;
}

.results-card {
    background: linear-gradient(135deg, rgba(255, 212, 0, 0.9), rgba(255, 165, 0, 0.9)) !important;
    border-radius: 20px;
    padding: 30px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 215, 0, 0.3);
    max-width: 400px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.results-title {
    font-size: 2.2em;
    font-weight: bold;
    color: #1A2F85;
    margin-bottom: 20px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.results-score {
    font-size: 1.5em;
    color: #1A2F85;
    margin-bottom: 20px;
}

/* RESULTS STATS - Remove glassmorphic effects */
.results-stats {
    background: rgba(26, 47, 133, 0.3) !important;
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 25px;
    color: white;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border: none !important;
}

.results-stats p {
    margin: 5px 0;
    font-size: 1.1em;
}

.results-stats strong {
    color: #FFD700;
}

/* PERFORMANCE RATING - Remove glassmorphic effects */
.performance-rating-container {
    margin: 20px 0;
    text-align: center;
    background: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.performance-rating {
    font-size: 1.4em;
    font-weight: bold;
    padding: 15px;
    background: rgba(255, 255, 255, 0.1) !important;
    border-radius: 15px;
    margin: 15px 0;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* PRODUCT SECTION */
.product-section {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 25px 0;
    gap: 40px;
}

.qr-code {
    width: 90px;
    height: 90px;
    background: white;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7em;
    color: black;
    text-align: center;
    padding: 5px;
    overflow: hidden;
    transform: translateX(0);
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.qr-code canvas {
    width: 100%;
    height: 100%;
}

.fab-product {
    width: 90px;
    height: 90px;
    background: transparent;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.2s ease;
    margin-left: 5px;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* AR SECTION - Remove glassmorphic effects */
.ar-section {
    background: rgba(0, 151, 215, 0.1) !important;
    border-radius: 15px;
    padding: 20px;
    margin: 20px 0;
    border: 2px dashed rgba(0, 151, 215, 0.5) !important;
    min-height: 320px;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.ar-title {
    color: #0097D7;
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 10px;
}

.ar-description {
    font-size: 1.1em;
    color: #1A2F85;
    margin-bottom: 15px;
    text-align: center;
    line-height: 1.4;
}

.ar-description strong {
    color: #0097D7;
    font-weight: bold;
}

/* PRODUCT 3D CONTAINER - Remove glassmorphic effects */
.product-3d-container {
    width: 100%;
    max-width: 300px;
    height: 200px;
    margin: 0 auto 15px auto;
    position: relative;
    overflow: hidden;
    border-radius: 8px;
    background: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

#product3DCanvas {
    width: 100% !important;
    height: 100% !important;
    display: block;
}

/* ACTION BUTTONS - Remove glassmorphic effects */
.action-buttons {
    display: flex;
    gap: 15px;
    margin-top: 25px;
    flex-wrap: wrap;
    justify-content: center;
}

.action-button {
    padding: 12px 25px;
    border: none;
    border-radius: 25px;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.2s ease;
    font-size: 0.9em;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

.action-button:hover {
    transform: scale(1.05);
}

.save-code-btn {
    background: linear-gradient(45deg, #0097D7, #00B4E6);
    color: #000;
}

.buy-fab-btn {
    background: linear-gradient(45deg, #FFD400, #FFA500);
    color: #1A2F85;
}

.whatsapp-btn {
    background: linear-gradient(45deg, #25D366, #128C7E);
    color: white;
}

.play-again-btn {
    background: linear-gradient(45deg, #1A2F85, #2A3F95);
    color: white;
    width: 100%;
    margin-top: 15px;
}

/* ============================================
   GAMEPLAY HUD SYSTEM - With glassmorphism
   ============================================ */

/* Game HUD Elements */
.hud {
    position: absolute;
    top: 15px;
    left: 15px;
    display: none;
    flex-direction: column;
    gap: 10px;
    z-index: 9999;
    pointer-events: none;
}

.hud.show {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* HUD ITEMS - Apply glassmorphism during gameplay */
.hud-item {
    /* CHANGED: Enhanced glassmorphic background - was rgba(255, 255, 255, 0.2) */
    background: rgba(255, 255, 255, 0.15) !important;
    /* CHANGED: Increased blur intensity - was blur(10px) */
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    /* CHANGED: Softer border - was rgba(255, 255, 255, 0.3) */
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    /* CHANGED: Enhanced shadow - was 0 8px 32px rgba(0, 0, 0, 0.1) */
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
    padding: 8px 15px;
    border-radius: 15px;
    /* CHANGED: Increased font weight - was 700 */
    font-weight: 600;
    font-size: 14px;
    /* CHANGED: Modern font stack - was sans-serif, Arial */
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
    /* CHANGED: Pure white text - was #FFFFFF */
    color: #FFFFFF;
    /* CHANGED: Enhanced text shadow - was 1px 1px 2px rgba(0, 0, 0, 0.5) */
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
}

.hud-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s ease;
}

.hud-item:hover::before {
    left: 100%;
}

/* Score Display */
.score-display {
    font-size: 16px;
    color: #FFD700;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5) !important;
    font-family: sans-serif, Arial;
    font-weight: 800;
    position: relative;
}

.score-display::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, transparent 30%, rgba(255, 215, 0, 0.15) 50%, transparent 70%);
    animation: scoreShine 4s infinite;
    pointer-events: none;
}

/* HEALTH SYSTEM - Apply glassmorphism during gameplay */
.health-container {
    min-width: 200px;
    position: relative;
    /* CHANGED: Enhanced glassmorphic background - was rgba(255, 255, 255, 0.2) */
    background: rgba(255, 255, 255, 0.15) !important;
    /* CHANGED: Increased blur intensity - was blur(10px) */
    backdrop-filter: blur(20px) !important;
    -webkit-backdrop-filter: blur(20px) !important;
    /* CHANGED: Softer border - was rgba(255, 255, 255, 0.3) */
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    /* CHANGED: Enhanced shadow - was 0 8px 32px rgba(0, 0, 0, 0.1) */
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
}

.health-label {
    font-size: 12px;
    margin-bottom: 5px;
    font-weight: 600;
    opacity: 0.9;
    font-family: sans-serif, Arial;
    color: #FFFFFF;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5) !important;
}

.health-bar {
    width: 100%;
    height: 16px;
    background: linear-gradient(145deg, rgba(255, 0, 0, 0.2), rgba(139, 0, 0, 0.3));
    border-radius: 10px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.3);
    position: relative;
    backdrop-filter: blur(5px);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.1);
}

.health-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff4757, #ffa502, #2ed573);
    transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 8px;
    position: relative;
    overflow: hidden;
    box-shadow: 0 0 8px rgba(46, 213, 115, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.health-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
    animation: healthShimmer 3s infinite;
}

.health-fill.health-critical {
    background: linear-gradient(90deg, #ff4757, #ff3838) !important;
    box-shadow: 0 0 15px rgba(255, 71, 87, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
    animation: healthCritical 0.8s infinite alternate;
}

.health-fill.health-warning {
    background: linear-gradient(90deg, #ff6b35, #ffa502) !important;
    box-shadow: 0 0 10px rgba(255, 165, 2, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
}

.health-fill.health-good {
    background: linear-gradient(90deg, #ffa502, #2ed573) !important;
    box-shadow: 0 0 8px rgba(46, 213, 115, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
}

/* GAME MESSAGES - Apply glassmorphism during gameplay */
.game-message {
    position: absolute;
    top: 120px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    background: rgba(255, 255, 255, 0.15) !important;
    backdrop-filter: blur(15px) !important;
    -webkit-backdrop-filter: blur(15px) !important;
    border: 1px solid 1px solid rgba(255, 255, 255, 0.2) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
    padding: 12px 24px;
    border-radius: 15px;
    z-index: 9999;
    pointer-events: none;
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
    font-weight: 600;
    font-size: 16px;
    color: #FFFFFF;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    opacity: 0;
    transform: translateX(-50%) translateY(-10px) scale(0.9);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    max-width: 320px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.game-message.show {
    opacity: 1 !important;
    transform: translateX(-50%) translateY(0) scale(1) !important;
    visibility: visible !important;
}

.game-message.fade-out {
    opacity: 0;
    transform: translateX(-50%) translateY(10px) scale(0.9);
}

.game-message::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.2), transparent);
    animation: messageShine 3s infinite;
}

/* POWER INDICATOR - Keep original green glassmorphic */
.power-indicator {
    background: rgba(0, 255, 127, 0.2) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    border: 1px solid rgba(0, 255, 127, 0.4) !important;
    border-color: rgba(0, 255, 127, 0.4) !important;
    padding: 6px 12px;
    border-radius: 12px;
    opacity: 0;
    transform: translateX(100px) scale(0.9);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    font-weight: 700;
    font-size: 12px;
    box-shadow: 0 3px 15px rgba(0, 255, 127, 0.2);
    font-family: sans-serif, Arial;
    color: #FFFFFF;
    position: relative;
    overflow: hidden;
}

.power-indicator::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0, 255, 127, 0.3), transparent);
    transition: left 0.6s ease;
}

.power-indicator.active {
    opacity: 1;
    transform: translateX(0) scale(1);
    animation: powerPulse 2s ease-in-out infinite alternate;
    border-color: rgba(0, 255, 127, 0.4) !important;
    border: 1px solid rgba(0, 255, 127, 0.4) !important;
}

.power-indicator.active::before {
    left: 100%;
}

.power-indicator:hover,
.power-indicator:focus {
    border-color: rgba(0, 255, 127, 0.4) !important;
    border: 1px solid rgba(0, 255, 127, 0.4) !important;
}

/* ============================================
   ADDITIONAL GAME ELEMENTS
   ============================================ */

/* Blinkit Button */
.blinkit-button {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: #1A2F85;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    font-weight: bold;
    cursor: pointer;
    pointer-events: all;
    transition: transform 0.2s ease;
}

.blinkit-button:hover {
    transform: scale(1.1);
}

/* AUDIO TOGGLE - Apply glassmorphism during gameplay */
.audio-toggle {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 50px;
    height: 50px;
    background: rgba(255, 255, 255, 0.2) !important;
    backdrop-filter: blur(15px) !important;
    -webkit-backdrop-filter: blur(15px) !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;
    border-radius: 50%;
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 9999;
    transition: all 0.3s ease;
    touch-action: manipulation !important;
    -webkit-touch-callout: none !important;
    -webkit-user-select: none !important;
    user-select: none !important;
    pointer-events: none;
    -webkit-tap-highlight-color: transparent;
}

.audio-toggle.show {
    display: flex !important;
    pointer-events: auto !important;
    visibility: visible !important;
    opacity: 1 !important;
}

.audio-toggle:hover {
    background: rgba(255, 255, 255, 0.3) !important;
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
}

.audio-toggle.muted {
    opacity: 0.7;
    background: linear-gradient(145deg, rgba(255, 71, 87, 0.8), rgba(139, 0, 0, 0.6)) !important;
}

.audio-toggle.muted:hover {
    background: linear-gradient(145deg, rgba(255, 71, 87, 0.9), rgba(139, 0, 0, 0.8)) !important;
}

.audio-icon {
    font-size: 18px;
    color: #FFD700;
    transition: color 0.3s ease;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}

.audio-toggle.muted .audio-icon {
    color: #FFFFFF;
}

.audio-toggle.active {
    animation: rallyPulse 2s infinite;
}

.audio-menu {
    position: fixed;
    background: linear-gradient(145deg, rgba(26, 47, 133, 0.95), rgba(0, 151, 215, 0.9));
    border-radius: 10px;
    padding: 10px;
    z-index: 10000;
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 215, 0, 0.3);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    min-width: 150px;
}

.audio-menu-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.2s ease;
    color: #FFD700;
    font-size: 14px;
    font-weight: 500;
}

.audio-menu-item:hover {
    background: rgba(255, 215, 0, 0.2);
}

.audio-menu-icon {
    margin-right: 8px;
    font-size: 16px;
}

/* Achievement Feedback */
.score-boost {
    animation: scoreBoost 0.8s ease-out;
}

.accuracy-perfect {
    animation: accuracyPerfect 1.2s ease-out;
}

/* ============================================
   GAMEPLAY STATE ISOLATION
   ============================================ */

/* Ensure complete isolation during gameplay */
body.gameplay .results-screen,
body.gameplay .start-screen {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    transform: translateY(-200vh) !important;
    z-index: -999 !important;
}

body.gameplay .start-card,
body.gameplay .results-card,
body.gameplay .results-stats strong {
    visibility: hidden !important;
    opacity: 0 !important;
}

/* ============================================
   ANIMATIONS
   ============================================ */

@keyframes pulse {
    0%, 100% {
        opacity: 1;
        transform: scale(1);
    }
    50% {
        opacity: 0.7;
        transform: scale(1.05);
    }
}

@keyframes float {
    0%, 100% {
        transform: translateY(0px);
    }
    50% {
        transform: translateY(-10px);
    }
}

@keyframes scoreShine {
    0% {
        transform: translateX(-100%);
    }
    50% {
        transform: translateX(-100%);
    }
    100% {
        transform: translateX(100%);
    }
}

@keyframes healthShimmer {
    0% {
        left: -100%;
    }
    50% {
        left: -100%;
    }
    100% {
        left: 100%;
    }
}

@keyframes healthCritical {
    0% {
        filter: brightness(1);
    }
    100% {
        filter: brightness(1.2);
    }
}

@keyframes messageShine {
    0% {
        left: -100%;
    }
    50% {
        left: -100%;
    }
    100% {
        left: 100%;
    }
}

@keyframes powerPulse {
    0% {
        box-shadow: 0 3px 15px rgba(0, 255, 127, 0.2);
    }
    100% {
        box-shadow: 0 5px 25px rgba(0, 255, 127, 0.4);
    }
}

@keyframes rallyPulse {
    0% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), 0 0 0 0 rgba(255, 215, 0, 0.7);
    }
    50% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), 0 0 0 8px rgba(255, 215, 0, 0);
    }
    100% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), 0 0 0 0 rgba(255, 215, 0, 0);
    }
}

@keyframes scoreBoost {
    0% {
        transform: scale(1);
        color: #FFD700;
    }
    50% {
        transform: scale(1.15);
        color: #00FFFF;
        text-shadow: 0 0 10px #00FFFF;
    }
    100% {
        transform: scale(1);
        color: #FFD700;
    }
}

@keyframes accuracyPerfect {
    0% {
        transform: scale(1);
    }
    25% {
        transform: scale(1.1);
        color: #00FF00;
        text-shadow: 0 0 15px #00FF00;
    }
    50% {
        transform: scale(1.05);
    }
    75% {
        transform: scale(1.1);
        color: #00FF00;
        text-shadow: 0 0 15px #00FF00;
    }
    100% {
        transform: scale(1);
        color: inherit;
    }
}

/* ============================================
   MOBILE RESPONSIVE STYLES
   ============================================ */

@media (max-width: 768px) {
    .game-main-title {
        font-size: 2em;
    }

    .play-button {
        font-size: 1.1em;
        padding: 12px 30px;
    }

    .results-card {
        padding: 25px;
        margin: 10px;
    }

    .action-buttons {
        flex-direction: row;
        gap: 10px;
        flex-wrap: wrap;
    }

    .action-button {
        flex: 1;
        min-width: 120px;
        max-width: 150px;
        padding: 12px 15px;
        font-size: 0.9em;
        margin: 0;
    }

    .save-code-btn,
    .buy-fab-btn {
        flex: 1;
        max-width: 140px;
    }

    .whatsapp-btn {
        max-width: 200px;
        margin: 0 auto;
    }

    .play-again-btn {
        width: 90%;
        max-width: 300px;
        margin: 15px auto 0;
    }

    .product-section {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 20px 0;
        gap: 30px;
        width: 100%;
        padding: 0 20px;
    }

    .qr-code {
        margin: 0;
        transform: translateX(-2px);
        width: 85px;
        height: 85px;
    }

    .fab-product {
        margin: 0;
        margin-left: 25px;
        width: 85px;
        height: 85px;
    }

    .results-stats {
        padding: 15px;
        font-size: 0.9em;
    }

    .results-score {
        font-size: 1.3em;
    }

    .ar-section {
        min-height: 280px;
        padding: 15px;
        margin: 15px 0;
    }

    .product-3d-container {
        max-width: 250px;
        height: 180px;
    }

    .ar-description {
        font-size: 1.0em;
    }

    /* Mobile responsive glassmorphism */
    .hud-item,
    .health-container,
    .audio-toggle {
        background: rgba(255, 255, 255, 0.25) !important;
        backdrop-filter: blur(8px) !important;
        -webkit-backdrop-filter: blur(8px) !important;
    }
    
    .game-message {
        background: rgba(255, 255, 255, 0.3) !important;
        backdrop-filter: blur(12px) !important;
        -webkit-backdrop-filter: blur(12px) !important;
    }

    .hud-item,
    .level-info,
    .health-container {
        font-size: 12px;
        padding: 6px 12px;
        border: 1px solid rgba(255, 255, 255, 0.8) !important;
        border-color: rgba(255, 255, 255, 0.8) !important;
    }

    .power-indicator {
        font-size: 12px;
        padding: 6px 12px;
        background: rgba(0, 255, 127, 0.25) !important;
        backdrop-filter: blur(8px) !important;
        -webkit-backdrop-filter: blur(8px) !important;
        border: 1px solid rgba(0, 255, 127, 0.8) !important;
        border-color: rgba(0, 255, 127, 0.8) !important;
    }

    .health-bar {
        height: 14px;
        min-width: 150px;
    }

    #gameCanvas {
        border: none !important;
        outline: none !important;
        box-shadow: none !important;
        border-width: 0 !important;
        border-style: none !important;
        border-color: transparent !important;
    }

    .game-message {
        top: 140px;
        font-size: 14px;
        padding: 8px 16px;
        max-width: 250px;
    }

    .audio-toggle {
        width: 45px;
        height: 45px;
        bottom: 15px;
        left: 15px;
    }

    .audio-icon {
        font-size: 16px;
    }

    @keyframes scoreBoost {
        0% {
            transform: scale(1);
            color: #FFD700;
        }
        50% {
            transform: scale(1.1);
            color: #00FFFF;
            text-shadow: 0 0 8px #00FFFF;
        }
        100% {
            transform: scale(1);
            color: #FFD700;
        }
    }

    @keyframes accuracyPerfect {
        0% {
            transform: scale(1);
        }
        25% {
            transform: scale(1.08);
            color: #00FF00;
            text-shadow: 0 0 12px #00FF00;
        }
        50% {
            transform: scale(1.04);
        }
        75% {
            transform: scale(1.08);
            color: #00FF00;
            text-shadow: 0 0 12px #00FF00;
        }
        100% {
            transform: scale(1);
            color: inherit;
        }
    }
}

/* Final safety overrides */
.start-card,
.results-card {
    transform: translateZ(0);
}

/* Prevent any unwanted background inheritance */
.results-screen * {
    backdrop-filter: inherit;
    -webkit-backdrop-filter: inherit;
}
</style>

    <script src="https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
   <div id="gameContainer">
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-card">
            <div class="fab-logo">
                <img src="https://assets.codepen.io/t-24779/FAB-Liquid.png" alt="FAB Liquid" class="fab-logo-img">
            </div>
            <h1 class="loading-title">Stain Slayer</h1>
            <h2 class="loading-subtitle">Loading Game...</h2>
            <div class="loading-progress">
                <div class="loading-progress-fill" id="progressFill"></div>
            </div>
            <p class="loading-tip">Protect everything - in politics and in laundry!</p>
        </div>
    </div>
</div>

    <div id="startScreen" class="start-screen hidden">
        <div class="start-card">
            <div class="fab-logo">
                <img src="https://assets.codepen.io/t-24779/FAB-Liquid.png" alt="FAB Liquid" class="fab-logo-img">
            </div>
            <h1 class="game-main-title">Stain Slayer</h1>
            <div class="character-preview">
                <img src="https://assets.codepen.io/t-24779/game-start-image.png" alt="Game Character" class="character-preview-img">
            </div>
            <p class="game-subtitle">
                <strong>Block stains, score lasting freshness!</strong>
            </p>
            <button id="startButton" class="play-button">Play Game</button>
        </div>
    </div>

    <div id="resultsScreen" class="results-screen">
        <div class="results-card">
            <h2 class="results-title">Game Over</h2>
            <div class="results-score">Score: <span id="finalScore">0</span></div>
            
            <div class="results-stats">
                <p>Your defense lasted <strong><span id="sessionTime">0</span> seconds!</strong></p>
                <p>Accuracy: <strong><span id="accuracyPercent">0</span>% (<span id="hitStats">0/0</span>)</strong></p>
                <p>Projectiles Blocked: <strong><span id="blockedCount">0</span></strong></p>
            </div>
            <!-- Add performance rating display -->
            <div class="performance-rating-container">
            <div id="performanceRating" class="performance-rating"></div>
            </div>

            <div class="product-section">
                <div class="qr-code" id="qrCode">
                    <!-- QR code will be generated here -->
                </div>
                <div class="fab-product" onclick="buyFabProduct()">
                    <img src="https://assets.codepen.io/t-24779/fab-detergent-india.png" alt="FAB Detergent" style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;">
                </div>
            </div>

            <div class="action-buttons">
                <button class="action-button save-code-btn" onclick="saveGameCode()">Save Code</button>
                <button class="action-button buy-fab-btn" onclick="buyFabProduct()">Stay Fab</button>
            </div>

            <div class="ar-section">
               <div class="ar-title">Interactive Product Showcase</div>
               <p class="ar-description">
                  Dono side Fab ka swag!<br>
                  <strong>Drag to rotate & Scroll to zoom in/out</strong>
              </p>
           <div class="product-3d-container" id="product3DContainer">
                 <canvas id="product3DCanvas"></canvas>
           <div class="product-3d-controls">
        </div>
    </div>
</div>
            <div class="action-buttons">
    <button class="action-button whatsapp-btn" onclick="shareOnWhatsApp()">WhatsApp</button>
</div>

<button class="action-button play-again-btn" onclick="playAgain()">Play Again</button>
</div>
</div>

<canvas id="gameCanvas" width="1400" height="800"></canvas>

<!-- Game HUD Elements -->
<div class="hud" id="gameHUD">
    <div class="hud-item">
        <div class="score-display">Score: <span id="score">0</span></div>
    </div>
    
    <div class="hud-item health-container">
        <div class="health-label">Politician's Reputation</div>
        <div class="health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
    </div>
    
    <!-- Audio toggle integrated into HUD -->
    <div id="audioToggle" class="audio-toggle hud-item" title="Toggle Game Audio">
        <span class="audio-icon">ðŸ”Š</span>
    </div>
</div>

<div class="game-message" id="gameMessage">
    <span id="messageText"></span>
</div>

<div class="power-indicators" id="powerIndicators">
    <div class="power-indicator" id="shieldPower">Fab Shield Active</div>
    <div class="power-indicator" id="speedPower">Speed Boost</div>
    <div class="power-indicator" id="slowmoPower">Slow Motion</div>
</div>
    
    <button id="blinkitButton" class="blinkit-button">
        Buy Fab on Blinkit
    </button>
</div>

<!-- Eruda script from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/eruda/2.4.1/eruda.min.js"></script>

    <!-- Initialize Eruda -->
    <script>
      eruda.init();
    </script>
    
    <script>

class SimpleAudioManager {
    constructor() {
        this.enabled = true;
        this.volume = 0.7;
        this.sounds = {};
        this.isInitialized = false;
    }
    
    // Keep this method name consistent
    async init() {
        try {
            const soundFiles = {
    block: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj',
    hit: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj',
    click: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj',
    health_critical: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj'
    };
            
            for (const [name, data] of Object.entries(soundFiles)) {
                const audio = new Audio(data);
                audio.volume = 0.3;
                this.sounds[name] = audio;
            }
            this.isInitialized = true;
        } catch (e) {
            this.enabled = false;
        }
    }
    
    // Standardize to single play method
    play(soundName, options = {}) {
        if (!this.enabled || !this.sounds[soundName]) return;
        
        try {
            const sound = this.sounds[soundName].cloneNode();
            sound.volume = this.volume * (options.volume || 1.0);
            sound.play().catch(() => {});
        } catch (e) {
            // Silently fail
        }
    }
    
    toggleMute() {
        this.enabled = !this.enabled;
        return this.enabled;
    }
    
    stopAllSounds() {
        // Add this method for cleanup
        Object.values(this.sounds).forEach(sound => {
            try {
                sound.pause();
                sound.currentTime = 0;
            } catch (e) {}
        });
    }
}
class StainSlayerGame {
    constructor() {
        // Core game elements
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Game state management
        this.gameStates = {
            LOADING: 'loading',
            START_SCREEN: 'start_screen',
            GAMEPLAY: 'gameplay',
            GAME_OVER: 'game_over',
            PAUSED: 'paused'
        };
        
        // Game state variables
        this.currentState = this.gameStates.LOADING;
        this.score = 0;
        this.level = 1;
        this.wave = 1;
        this.politicianHealth = 100;
        this.maxHealth = 100;
        this.projectilesBlocked = 0;
        this.projectilesMissed = 0;
        this.survivedWaves = 0;
        this.isRunning = false;
        this.sessionStartTime = Date.now();
        this.lastFrameTime = 0;
        
        // Character definitions
        this.aide = {
            x: 600,
            y: 450,
            width: 80,
            height: 120,
            speed: 350,
            shield: false,
            shieldCooldown: 0,
            bounceY: 0,
            facingDirection: 1,
            armAnimation: 0,
            expression: 'determined'
        };
        
        this.politician = {
            x: 700,
            y: 340,
            width: 100,
            height: 150,
            hitbox: { x: 710, y: 400, width: 60, height: 80 },
            armAnimation: 0,
            expression: 'speaking',
            stains: [],
            reactionState: 'normal',
            reactionTimer: 0,
            animationSpeed: 1.0
            
        };

        this.aide = {
            x: 600,
            y: 450,
            width: 80,
            height: 120,
            speed: 350,
            shield: false,
            shieldCooldown: 0,
            bounceY: 0,
            facingDirection: 1,
            armAnimation: 0,
            expression: 'determined',
            spriteFlipped: false,
            shieldEnergy: 100,
            maxShieldEnergy: 100
        };

        this.hinglishMessages = [
            "Leader yaa anda plate?",
            "Vote maango, tamatar lo!",
            "Kurta hai ya dustbin?",
            "Shooter nahi, joota hai!",
            "Ande-tamatar ki aarti!",
            "Public ka washing powder!",
            "Free anda-tamatar makeup!",
            "Democracy ka asli fashion!"
        ];
        
        // Performance tracking
        this.politician.lastPosition = null;
        this.politician.lastAnimationFrame = null;
        this.politician.animationTimer = 0;
        this.aide.animationTimer = 0;
        
        // Game objects
        this.projectiles = [];
        this.particles = [];
        this.trailParticles = [];
        this.cameraShake = { x: 0, y: 0, intensity: 0 };

        // Crowd animation system
        this.crowdAnimation = {
            time: 0,
            waveSpeed: 0.003,
            waveAmplitude: 2,
            sectionOffsets: [0, 0.5, 1.0, 1.5, 2.0] // Different sections sway differently
        };
        
        // Input handling
        this.keys = {};
        this.mouse = { x: 0, y: 0 };
        this.touchControls = {
            up: false,
            down: false,
            left: false,
            right: false,
            shield: false,
            slowmo: false
        };
        
        // Timing system
        this.lastTime = 0;
        this.deltaTime = 0;
        this.projectileSpawnTimer = 0;
        this.projectileSpawnRate = 1200;
        this.waveTimer = 0;
        this.waveDuration = 25000;

        // Wave-based spawning system
        this.waveSpawning = {
            isActive: false,
            intensity: 1,
            burstCount: 0,
            maxBursts: 3,
            burstTimer: 0,
            burstInterval: 800,
            restTimer: 0,
            restDuration: 2000
        };
        
        // Power system
        this.activePowers = {
            shield: 0,
            speed: 0,
            slowmo: 0
        };
        
        // Debug system
        this.debug = {
            enabled: true,
            logLevel: 'info',
            trackFunctions: true,
            trackPerformance: true,
            showFlagOutlines: false
        };

        // Sprite system
        this.spriteSystem = {
            loaded: false,
            images: {},
            animations: {},
            currentFrames: {}
        };

        // Particle system
        this.particleTypes = {
            impact: { life: 1.5, gravity: 200, bounce: 0.4, sparkle: false },
            sparkle: { life: 2.0, gravity: 0, bounce: 0, sparkle: true },
            explosion: { life: 1.0, gravity: 150, bounce: 0.3, sparkle: false },
            trail: { life: 0.8, gravity: 50, bounce: 0, sparkle: false },
            atmospheric: { life: 10.0, gravity: 5, bounce: 0, sparkle: false }
        };

         // Message system
         this.messageSystem = {
            isActive: false,
            currentMessage: '',
            messageTimer: 0,
            messageDuration: 4000,
            messages: {
        powerUp: [
            "Fab Shield ON, boss!",
            "Ab stains ki vaat!",
            "Shine mode activated!"
        ],
        defense: [
            "Koi daag abhi nahi!",
            "Ande-tamatar? Fab bachayega!",
            "Fab guard = full tight!",
            "Lightning Reflexes!",
            "PERFECT ACCURACY!"
        ],
        victory: [
            "Stains down, tu shine karega!",
            "Freshness jeet gaya bhai!",
            "Daag gaye, Fab jeeta!"
        ],
        combo: [
            "Combo master hai tu!",
            "Block pe block, zabardast!",
            "Defense level pro!",
            "Great 5 Streak! Keep going!",
            "AMAZING 10 Streak! On fire!",
            "EPIC 15 Streak! Unstoppable!",
            "LEGENDARY 20 Streak! Master Defender!"
        ],
        close: [
            "Bachke rahna bhai!",
            "Close call tha yaar!",
            "Phew! Safe ho gaye!"
        ],
        wave: [
            "Nayi wave aa rahi hai!",
            "Ready raho defense ke liye!",
            "Agle level ki taiyaari!"
        ]
    },
    lastMessageType: '',
    comboCount: 0,
    lastComboTime: 0
};

       // Reaction system
            this.reactionSystem = {
            politician: {
            currentReaction: 'normal',
            reactionTimer: 0,
            sweatDrops: [],
            reactionCircles: [],
            lastHitTime: 0,
            stressLevel: 0 // 0-100 scale
        },
        aide: {
            currentReaction: 'alert',
            confidenceLevel: 100, // 0-100 scale
            lastSuccessTime: 0,
            victoryPose: false,
            victoryTimer: 0
        } 
        };

        // Projectile visual system
           this.projectileEffects = {
            warningIndicators: [],
            impactPredictions: [],
            trailSystem: {
            enabled: true,
            maxTrailLength: 8,
            fadeRate: 0.15
       },
           threatLevels: {
           low: { color: '#90EE90', threshold: 15 },
           medium: { color: '#FFD700', threshold: 25 },
           high: { color: '#FF6347', threshold: 35 },
          critical: { color: '#FF0000', threshold: 50 }
       }
       };

       // Screen effects and visual juice system
          this.screenEffects = {
          shake: {
          intensity: 0,
          duration: 0,
          type: 'impact', // impact, explosion, critical
          decayRate: 20
        },
          flash: {
          active: false,
          color: '#FFFFFF',
          intensity: 0,
          duration: 0,
         fadeRate: 5
        },
    colorOverlay: {
        active: false,
        color: '#FF0000',
        intensity: 0,
        duration: 0,
        fadeRate: 3
    },
    slowMotion: {
        active: false,
        distortionIntensity: 0,
        chromaShift: 0,
        vignette: 0
    },
    comboEffects: {
        multiplier: 1,
        streakCount: 0,
        lastHitTime: 0,
        glowIntensity: 0
    }
};
        // Performance optimization
        this.crowdCache = null;
        this.lastCrowdUpdate = 0;
        
        this.init();
        this.analytics = new StainSlayerAnalytics(this);
        this.audioManager = new SimpleAudioManager();
    }
    
    /**
     * Debug logging system
     * @param {string} level - Log level (error, warn, info, debug)
     * @param {string} message - Log message
     * @param {*} data - Optional data to log
     */
    debugLog(level, message, data = null) {
        if (!this.debug.enabled) return;
        
        const levels = { error: 0, warn: 1, info: 2, debug: 3 };
        if (levels[level] <= levels[this.debug.logLevel]) {
            const timestamp = new Date().toISOString().substr(11, 12);
            console.log(`[${timestamp}] [${level.toUpperCase()}] ${message}`, data || '');
        }
    }

    /**
     * Toggle flag debug visualization
     * @returns {boolean} Current debug state
     */
    toggleFlagDebug() {
        this.debug.showFlagOutlines = !this.debug.showFlagOutlines;
        console.log('Flag debug outlines:', this.debug.showFlagOutlines ? 'ENABLED' : 'DISABLED');
        return this.debug.showFlagOutlines;
    }

    // Add this method to your StainSlayerGame class after the constructor
debugPerformance() {
    console.log('Performance Check:', {
        particles: this.particles.length,
        trailParticles: this.trailParticles.length,
        projectiles: this.projectiles.length,
        canvasSize: `${this.canvas.width}x${this.canvas.height}`,
        isDesktop: this.gameWidth >= 768,
        optimizations: this.mobileOptimizations,
        gameState: this.currentState,
        isRunning: this.isRunning
    });
}

debugAideRendering() {
    console.log('Aide Rendering Debug:', {
        aidePosition: { x: this.aide.x, y: this.aide.y },
        spriteFlipped: this.aide.spriteFlipped,
        bounceY: this.aide.bounceY,
        renderMethod: 'Check render pipeline'
    });
    
    // Add render call tracking
    let originalDrawResponsiveAide = this.drawResponsiveAide;
    let callCount = 0;
    
    this.drawResponsiveAide = function() {
        callCount++;
        console.log(`drawResponsiveAide called ${callCount} times this frame`);
        console.trace('Call stack for aide rendering');
        return originalDrawResponsiveAide.call(this);
    };
    
    // Reset after next frame
    setTimeout(() => {
        this.drawResponsiveAide = originalDrawResponsiveAide;
        console.log(`Total aide render calls: ${callCount}`);
    }, 100);
}

// ADD THIS METHOD RIGHT HERE:
debugAudio() {
    console.log('Audio System Check:', {
        hasAudioManager: !!this.audioManager,
        isInitialized: this.audioManager?.isInitialized,
        isEnabled: this.audioManager?.enabled,
        soundsLoaded: this.audioManager?.sounds ? Object.keys(this.audioManager.sounds).length : 0,
        volume: this.audioManager?.volume
    });
}

    /**
     * Initialize game systems
     */
   init() {
    // Enhanced mobile detection
    const userAgentMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const screenSizeMobile = window.innerWidth < 768;
    const lowMemory = navigator.deviceMemory && navigator.deviceMemory < 4;

    // FIXED: Only use user agent and screen size - remove touch detection
    this.isMobile = userAgentMobile || screenSizeMobile;
    this.isLowEndDevice = lowMemory || this.isMobile;
    
    this.setupCanvas(); // MOVE THIS UP
    
    // NOW set mobileOptimizations after gameWidth is defined
    this.mobileOptimizations = {
        maxParticles: this.isLowEndDevice ? 3 : (this.gameWidth < 768 ? 10 : 25),
        maxTrailParticles: this.isLowEndDevice ? 2 : (this.gameWidth < 768 ? 5 : 15),
        maxProjectiles: this.isLowEndDevice ? 1 : (this.gameWidth < 768 ? 2 : 4),
        frameSkip: this.isLowEndDevice ? 3 : (this.gameWidth < 768 ? 2 : 1),
        
        desktopScale: this.gameWidth >= 768 ? 1.2 : 1.0,
        desktopParticles: this.gameWidth >= 768 ? 25 : 10,
        desktopProjectiles: this.gameWidth >= 768 ? 4 : 2,
        enableEnhancedEffects: this.gameWidth >= 1024,
        
        skipScreenEffects: true,
        skipAtmospheric: true,
        skipEnhancedTrails: this.gameWidth < 768,
        skipAnalytics: this.isLowEndDevice
    };
    
    if (this.isMobile) {
        console.log('Mobile device detected with aggressive optimizations');
        console.log('Optimizations:', this.mobileOptimizations);
    }
    
    this.setupEventListeners();
    this.initSpriteSystem();
    this.loadSprites();
    this.loadAssets();
    this.initBackgroundAssets();
}
    /**
     * Initialize background assets
     */
    initBackgroundAssets() {
        this.backgroundAssets = {
            buildings: 'https://assets.codepen.io/t-24779/indian-village.png',
            stage: 'https://assets.codepen.io/t-24779/political-stage-detailed.png',
            ground: 'https://assets.codepen.io/t-24779/village-ground-texture.png',
            crowdBg: 'https://assets.codepen.io/t-24779/crowd-back-ground.png',
            crowdFg: 'https://assets.codepen.io/t-24779/crowd-foreground-layer.png',
    
        };

        this.backgroundImages = {};
        this.backgroundsLoaded = false;
        this.loadBackgroundAssets();
    }


    /**
     * Load background assets
     */
    loadBackgroundAssets() {
        const assetKeys = Object.keys(this.backgroundAssets);
        let loadedCount = 0;
        
        assetKeys.forEach(key => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                this.backgroundImages[key] = img;
                loadedCount++;
                
                if (loadedCount === assetKeys.length) {
                    this.backgroundsLoaded = true;
                    console.log('All background assets loaded successfully');
                }
            };
            
            img.onerror = () => {
                console.warn(`Failed to load background asset: ${key}`);
                loadedCount++;
                
                if (loadedCount === assetKeys.length) {
                    this.backgroundsLoaded = false;
                    console.log('Background asset loading completed with some failures');
                }
            };
            
            img.src = this.backgroundAssets[key];
        });
    }

    /**
     * Draw background asset helper
     * @param {string} assetKey - Asset key
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width
     * @param {number} height - Height
     * @returns {boolean} Success status
     */
    drawBackgroundAsset(assetKey, x, y, width, height) {
        if (this.backgroundsLoaded && this.backgroundImages[assetKey]) {
            this.ctx.drawImage(this.backgroundImages[assetKey], x, y, width, height);
            return true;
        }
        return false;
    }

    /**
     * Setup canvas with responsive design
     */
   setupCanvas() {
    const resizeCanvas = () => {
        try {
            let containerWidth, containerHeight;
            
            if (this.isMobile) {
                containerWidth = Math.min(window.innerWidth, 800); // Cap mobile width
                containerHeight = Math.min(window.innerHeight, 600); // Cap mobile height
                
                // Handle mobile viewport issues more safely
                if (window.visualViewport && window.visualViewport.height) {
                    containerHeight = Math.min(window.visualViewport.height, 600);
                }
            } else {
                // FIXED: Better desktop dimensions with aspect ratio control
                containerWidth = window.innerWidth;
                containerHeight = window.innerHeight;
                
                // Maintain reasonable aspect ratio for desktop (16:10 to 16:9 range)
                const minAspect = 16 / 10; // 1.6
                const maxAspect = 16 / 9;  // 1.78
                const currentAspect = containerWidth / containerHeight;
                
                if (currentAspect > maxAspect) {
                    // Too wide, limit width to prevent excessive stretching
                    containerWidth = containerHeight * maxAspect;
                } else if (currentAspect < minAspect) {
                    // Too tall, limit height
                    containerHeight = containerWidth / minAspect;
                }
                
                // Cap maximum desktop size to prevent performance issues
                const maxDesktopWidth = 1920;
                const maxDesktopHeight = 1080;
                
                if (containerWidth > maxDesktopWidth) {
                    const scale = maxDesktopWidth / containerWidth;
                    containerWidth = maxDesktopWidth;
                    containerHeight = containerHeight * scale;
                }
                
                if (containerHeight > maxDesktopHeight) {
                    const scale = maxDesktopHeight / containerHeight;
                    containerHeight = maxDesktopHeight;
                    containerWidth = containerWidth * scale;
                }
            }
            
            this.canvas.width = containerWidth;
            this.canvas.height = containerHeight;
            this.canvas.style.width = containerWidth + 'px';
            this.canvas.style.height = containerHeight + 'px';
            
            this.gameWidth = containerWidth;
            this.gameHeight = containerHeight;
            
            this.canvasRect = this.canvas.getBoundingClientRect();
            
        } catch (error) {
            console.error('Canvas resize error:', error);
            // FIXED: Better fallback dimensions
            if (this.isMobile) {
                this.canvas.width = 800;
                this.canvas.height = 600;
                this.gameWidth = 800;
                this.gameHeight = 600;
            } else {
                this.canvas.width = 1200;  // Better desktop fallback
                this.canvas.height = 750;  // 16:10 aspect ratio
                this.gameWidth = 1200;
                this.gameHeight = 750;
            }
        }
    };
    
    resizeCanvas();
    
   
// Debounced resize for mobile with error handling
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        try {
            resizeCanvas();
            
            // FIXED: Always reposition characters during resize, regardless of game state
            if (this.currentState === this.gameStates.GAMEPLAY) {
                this.repositionCharacters();
                
                // Clear canvas to prevent visual artifacts
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Force immediate re-render with correct positions
                this.render();
            }
            
            // Update mobile detection after resize
            const wasMobile = this.isMobile;
            const userAgentMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const screenSizeMobile = window.innerWidth < 768;
            this.isMobile = userAgentMobile || screenSizeMobile;
            
            // If mobile state changed, update mobile optimizations
            if (wasMobile !== this.isMobile) {
                this.mobileOptimizations = {
                    maxParticles: this.isLowEndDevice ? 3 : (this.gameWidth < 768 ? 10 : 25),
                    maxTrailParticles: this.isLowEndDevice ? 2 : (this.gameWidth < 768 ? 5 : 15),
                    maxProjectiles: this.isLowEndDevice ? 1 : (this.gameWidth < 768 ? 2 : 4),
                    frameSkip: this.isLowEndDevice ? 3 : (this.gameWidth < 768 ? 2 : 1)
                };
            }
            
        } catch (error) {
            console.error('Resize handler error:', error);
        }
    }, this.isMobile ? 300 : 100);
});
   }

    /**
     * Setup event listeners for input handling
     */
setupEventListeners() {
    // Keyboard events (unchanged)
    window.addEventListener('keydown', (e) => {
        this.keys[e.code] = true;
        if (e.code === 'Space') {
            e.preventDefault();
            this.activateSlowMotion();
        }
    });
    
    window.addEventListener('keyup', (e) => {
        this.keys[e.code] = false;
    });
    
    // Mouse events (unchanged)
    this.canvas.addEventListener('mousedown', (e) => {
        this.activateShield();
    });
    
    this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
        this.mouse.y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
    });
    
    // SIMPLIFIED MOBILE TOUCH HANDLERS
    let touchActive = false;
    let lastTouchX = 0;
    let lastTouchY = 0;

    this.canvas.addEventListener('touchstart', (e) => {
        try {
            e.preventDefault();
            e.stopPropagation();
            
            if (e.touches.length !== 1 || touchActive) return;
            
            touchActive = true;
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            
            // Simple position update
            this.mouse.x = (touch.clientX - rect.left) * (this.canvas.width / rect.width);
            this.mouse.y = (touch.clientY - rect.top) * (this.canvas.height / rect.height);
            
            // Always activate shield on touch
            this.activateShield();
            
        } catch (error) {
            touchActive = false;
        }
    }, { passive: false });

    this.canvas.addEventListener('touchmove', (e) => {
        try {
            e.preventDefault();
            e.stopPropagation();
            
            if (e.touches.length !== 1 || !touchActive) return;
            
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            
            // Update mouse position for shield following
            this.mouse.x = (touch.clientX - rect.left) * (this.canvas.width / rect.width);
            this.mouse.y = (touch.clientY - rect.top) * (this.canvas.height / rect.height);
            
            // SIMPLE movement detection - no complex calculations
            const deltaX = touch.clientX - lastTouchX;
            const deltaY = touch.clientY - lastTouchY;
            
            // Clear all movement first
            this.keys['KeyW'] = this.keys['ArrowUp'] = false;
            this.keys['KeyS'] = this.keys['ArrowDown'] = false;
            this.keys['KeyA'] = this.keys['ArrowLeft'] = false;
            this.keys['KeyD'] = this.keys['ArrowRight'] = false;
            
            // Only set movement if significant change
            if (Math.abs(deltaX) > 20 || Math.abs(deltaY) > 20) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Horizontal movement
                    if (deltaX < 0) {
                        this.keys['KeyA'] = this.keys['ArrowLeft'] = true;
                    } else {
                        this.keys['KeyD'] = this.keys['ArrowRight'] = true;
                    }
                } else {
                    // Vertical movement
                    if (deltaY < 0) {
                        this.keys['KeyW'] = this.keys['ArrowUp'] = true;
                    } else {
                        this.keys['KeyS'] = this.keys['ArrowDown'] = true;
                    }
                }
            }
            
        } catch (error) {
            // Clear movement on any error
            this.keys['KeyW'] = this.keys['ArrowUp'] = false;
            this.keys['KeyS'] = this.keys['ArrowDown'] = false;
            this.keys['KeyA'] = this.keys['ArrowLeft'] = false;
            this.keys['KeyD'] = this.keys['ArrowRight'] = false;
        }
    }, { passive: false });

    this.canvas.addEventListener('touchend', (e) => {
        try {
            e.preventDefault();
            e.stopPropagation();
            
            touchActive = false;
            
            // Clear ALL movement keys immediately
            this.keys['KeyW'] = this.keys['ArrowUp'] = false;
            this.keys['KeyS'] = this.keys['ArrowDown'] = false;
            this.keys['KeyA'] = this.keys['ArrowLeft'] = false;
            this.keys['KeyD'] = this.keys['ArrowRight'] = false;
            
        } catch (error) {
            touchActive = false;
        }
    }, { passive: false });
    
    // Add touchcancel handler to reset state if touch is interrupted
    this.canvas.addEventListener('touchcancel', (e) => {
        try {
            touchActive = false;
            
            // Clear all movement keys
            this.keys['KeyW'] = this.keys['ArrowUp'] = false;
            this.keys['KeyS'] = this.keys['ArrowDown'] = false;
            this.keys['KeyA'] = this.keys['ArrowLeft'] = false;
            this.keys['KeyD'] = this.keys['ArrowRight'] = false;
            
        } catch (error) {
            console.warn('Touch cancel error:', error);
        }
    }, { passive: false });
    
    // UI button events (unchanged)
    const startButton = document.getElementById('startButton');
    const blinkitButton = document.getElementById('blinkitButton');
    
    if (startButton) {
        startButton.addEventListener('click', () => this.startGame());
    }
    
    if (blinkitButton) {
        blinkitButton.addEventListener('click', () => this.openBlinkit());
    }

    // SAFER Audio toggle click handler
    const audioToggle = document.getElementById('audioToggle');
    if (audioToggle) {
        audioToggle.addEventListener('click', (e) => {
            try {
                e.preventDefault();
                e.stopPropagation();
                
                if (this.audioManager) {
                    const isMuted = this.audioManager.toggleMute();
                    const audioIcon = audioToggle.querySelector('.audio-icon');
                    
                    if (audioIcon) {
                         audioIcon.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
                   }
                    
                    audioToggle.classList.toggle('muted', isMuted);
                    
                     //Play UI feedback sound when unmuting (with error handling)
                    if (!isMuted && this.audioManager.isEnabled) {
                        setTimeout(() => {
                           try {
                               this.audioManager.play('pop', { volume: 0.5 });
                            } catch (audioError) {
                                console.warn('Audio feedback failed:', audioError);
                            }
                       }, 100);
                    }
                }
            } catch (error) {
                console.warn('Audio toggle error:', error);
            }
       });
    }
        
    if (this.isMobile) {
        // Handle page visibility changes (when user switches tabs/apps)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Page hidden - stopping game loop');
                this.isRunning = false;
                this.stopGameLoop();
                
                // Clear all inputs when app loses focus
                this.keys = {};
                
            } else if (this.currentState === this.gameStates.GAMEPLAY) {
                console.log('Page visible - game was paused');
                // Don't auto-restart, let user tap to continue
            }
        });
        
        // Handle window focus/blur
        window.addEventListener('blur', () => {
            console.log('Window blur - clearing input states');
            this.keys = {};
        });
        
        window.addEventListener('focus', () => {
            console.log('Window focus - resetting input states');
            this.keys = {};
        });
        
        // Handle page hide (iOS Safari specific)
        window.addEventListener('pagehide', () => {
            console.log('Page hide - emergency stop');
            this.isRunning = false;
            this.stopGameLoop();
        });
        
        // Handle page show (when returning from background)
        window.addEventListener('pageshow', () => {
            console.log('Page show - clearing states');
            this.keys = {};
        });
    }
}
    /**
     * Load game assets with progress tracking
     */
    loadAssets() {
    let progress = 0;
    const progressFill = document.getElementById('progressFill');
    
    // Array of 10 
    const loadingTips = [
        "Daag vs Fab - epic battle shuru! #FabKaPower #StainSlayer",
        "Politician ka kurta bachao, democracy bachao! #CleanPolitics #FabDefender", 
        "Ande-tamatar ready hai, tu ready hai? #GameOn #FabProtection",
        "Safed kapde = politician ki izzat! #WhiteShirt #FabMagic",
        "Rally mein stains, ghar mein Fab! #DoubleProtection #FabLife",
        "Neta ji ka reputation tera haath mein! #DefendTheLeader #FabShield",
        "Public ka gussa vs Fab ka power! #StainWars #FabVictory",
        "Democracy dirty, lekin kapde clean! #PoliticsVsFab #CleanGame",
        "Tomato missile incoming - Fab shield ready? #StainAttack #FabReady",
        "Game khelo, Fab sikho, hero bano! #GamingLife #FabHero"
    ];
    
    // Select random tip and update the loading tip element
    const randomTip = loadingTips[Math.floor(Math.random() * loadingTips.length)];
    const loadingTipElement = document.querySelector('.loading-tip');
    if (loadingTipElement) {
        loadingTipElement.textContent = randomTip;
    }
    
    const updateProgress = () => {
        progress += 20;
        if (progressFill) {
            progressFill.style.width = progress + '%';
        }
        
        if (progress >= 100) {
            setTimeout(() => this.onAllAssetsLoaded(), 500);
        } else {
            setTimeout(updateProgress, 200);
        }
    };
    
    setTimeout(updateProgress, 300);
}
    
  /**
     * Handle completion of asset loading
     */
   onAllAssetsLoaded() {
    const loadingScreen = document.getElementById('loadingScreen');
    const startScreen = document.getElementById('startScreen');
    
    if (loadingScreen) {
        loadingScreen.style.display = 'none';
        loadingScreen.style.zIndex = '1'; 
    }
    
    if (startScreen) {
        startScreen.classList.remove('hidden');
        startScreen.style.zIndex = '5000'; // Above canvas
    }
    
    this.currentState = this.gameStates.START_SCREEN;
}

    /**
     * Start the game
     */
 startGame() {
    this.debugLog('info', 'startGame() called');
    
    try {
        const startScreen = document.getElementById('startScreen');
        if (startScreen) {
            startScreen.classList.add('hidden');
        }

        // FIXED: Single audio initialization (removed duplicate)
        if (this.audioManager && !this.audioManager.isInitialized) {
            this.audioManager.init().catch(error => {
                console.warn('Audio initialization failed:', error);
                this.audioManager.enabled = false;
            });
        }
        
        // CHANGE: Hide body background immediately to prevent yellow flash
        document.body.style.background = 'transparent';
        
        this.currentState = this.gameStates.GAMEPLAY;
        this.isRunning = true;
        this.sessionStartTime = Date.now();

        // REMOVED: Duplicate audio initialization code

        // FIXED: Removed non-existent audio methods
        setTimeout(() => {
            if (this.audioManager && this.audioManager.isInitialized) {
                console.log('Audio system ready for game sounds');
            }
        }, 1000);
        
        // CHANGE: More aggressive canvas hiding
        this.canvas.style.background = 'transparent';
        this.ctx.fillStyle = 'transparent';
        
        // Show HUD elements including audio toggle
        const elements = ['gameHUD', 'powerIndicators'];
        elements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.classList.add('show');
            }
        });
        
        // CORRECTED: Properly show audio toggle during gameplay
        const audioToggle = document.getElementById('audioToggle');
        if (audioToggle) {
            audioToggle.classList.add('show');
            audioToggle.style.display = 'flex';
            audioToggle.style.pointerEvents = 'auto';
            audioToggle.style.zIndex = '9999'; 
        }
        
        this.resetGameState();
        
        // FIXED: Show canvas immediately with game content - removes blue frame delay
this.canvas.style.display = 'block';
this.canvas.style.visibility = 'visible';
this.canvas.style.opacity = '1';

// Start game loop immediately without delay
this.startGameLoop();
        
        this.debugLog('info', 'startGame() completed successfully');
    } catch (error) {
        this.debugLog('error', 'startGame() failed', error);
        throw error;
    }
}
    /**
     * Reset game state to initial values
     */
   resetGameState() {
    // Reset score and stats
    this.score = 0;
    this.level = 1;
    this.wave = 1;
    this.politicianHealth = 100;
    this.projectilesBlocked = 0;
    this.projectilesMissed = 0;
    this.survivedWaves = 0;
    
    // Clear game objects
    this.projectiles = [];
    this.particles = [];
    this.trailParticles = [];
    this.projectileSpawnTimer = 1.2;
    this.waveTimer = 0;
    this.cameraShake = { x: 0, y: 0, intensity: 0 };
    
    // Position characters
    const centerX = this.gameWidth / 2;
    const groundY = this.gameHeight * 0.65;
    const isMobileScreen = this.gameWidth < 768;
    
    // Reset aide position
    this.aide.x = centerX - (isMobileScreen ? 85 : 120);
    const basePodiumScale = this.gameWidth / 1400;
    const podiumScale = isMobileScreen ? Math.max(0.8, basePodiumScale) : basePodiumScale;
    const stageY = groundY - 15;
    
    // FIXED: Proper stage positioning for desktop - aide should stand ON the stage
    const stageHeight = isMobileScreen ? 25 : 12;
    this.aide.y = stageY - stageHeight - this.aide.height + (isMobileScreen ? -40 : 75);

    this.aide.shield = false;
    this.aide.shieldCooldown = 0;
    this.aide.expression = 'determined';
    this.aide.shieldEnergy = 100;
    
    // Define politician offset variables
    const politicianOffsetX = isMobileScreen ? -34 : -30;
    const politicianOffsetY = isMobileScreen ? -160 : -175;
    
    // Reset politician position
    this.politician.x = centerX + politicianOffsetX;
    this.politician.y = groundY + politicianOffsetY;
    this.politician.hitbox = { 
        x: centerX + politicianOffsetX + (isMobileScreen ? 10 : 10), 
        y: groundY + politicianOffsetY + (isMobileScreen ? 40 : 60),
        width: isMobileScreen ? 40 : 60, 
        height: isMobileScreen ? 60 : 80 
    };
    this.politician.expression = 'speaking';

    // Clear all stains from politician
    this.politician.stains = [];
    this.politician.reactionState = 'normal';
    this.politician.reactionTimer = 0;

    // Add message bubble system
    this.politician.messageBubble = {
        text: '',
        timer: 0,
        isVisible: false,
        fadeIn: 0
    };
    
    // Reset powers
    this.activePowers = { shield: 0, speed: 0, slowmo: 0 };
    // Hide audio toggle when game resets
    const audioToggle = document.getElementById('audioToggle');
    if (audioToggle) {
        audioToggle.classList.remove('show');
    }
}
    /**
     * Reposition characters on screen resize
     */
    repositionCharacters() {
    const centerX = this.gameWidth / 2;
    const groundY = this.gameHeight * 0.65;
    const isDesktop = this.gameWidth >= 768; // Changed from isMobileScreen for consistency
    
    // FIXED: Better desktop positioning with proportional scaling
    const aideOffsetX = isDesktop ? -120 : -90; // More separation on desktop
    const politicianOffsetX = isDesktop ? -25 : -33; // Adjusted for better desktop positioning
    const politicianOffsetY = isDesktop ? -140 : -160; // Less aggressive desktop offset
    
    // Reposition aide with improved desktop scaling
    this.aide.x = centerX + aideOffsetX; // Changed to use aideOffsetX
    const basePodiumScale = this.gameWidth / 1400;
    const podiumScale = !isDesktop ? Math.max(0.8, basePodiumScale) : Math.min(basePodiumScale, 1.2); // Cap desktop scale
    const stageY = groundY - 40;
    
    this.aide.y = stageY - this.aide.height + 35;
    
    // Reposition politician with better desktop handling
    this.politician.x = centerX + politicianOffsetX;
    this.politician.y = groundY + politicianOffsetY - 5; // Additional offset for stage height
    
    // FIXED: Proportional hitbox scaling for desktop
    const hitboxScale = isDesktop ? Math.min(this.gameWidth / 1400, 1.2) : 1.0; // Cap desktop hitbox scale
    
    this.politician.hitbox = { 
        x: centerX + politicianOffsetX + (isDesktop ? 15 : 10), // Better desktop hitbox positioning
        y: groundY + politicianOffsetY + (isDesktop ? 70 : 40), // Adjusted for better desktop alignment
        width: (isDesktop ? 60 : 40) * hitboxScale, // Apply proportional scaling
        height: (isDesktop ? 80 : 60) * hitboxScale  // Apply proportional scaling
    };
}

debugDesktopScaling() {
    console.log('Desktop Scaling Debug:', {
        gameWidth: this.gameWidth,
        gameHeight: this.gameHeight,
        isDesktop: this.gameWidth >= 768,
        aspectRatio: (this.gameWidth / this.gameHeight).toFixed(2),
        canvasSize: `${this.canvas.width}x${this.canvas.height}`,
        characterPositions: {
            aide: { x: this.aide.x, y: this.aide.y },
            politician: { x: this.politician.x, y: this.politician.y }
        }
    });
}
    /**
     * Activate shield power
     */
    activateShield() {
    if (this.currentState !== this.gameStates.GAMEPLAY) return;
    
    if (this.aide.shieldCooldown <= 0) {
        this.aide.shield = true;
        // Play shield activation sound
    if (this.audioManager) {
    this.audioManager.play('shield_activate', {
       // volume: 0.7
    });
    
    // Add power-up collection sound for feedback
    setTimeout(() => {
       this.audioManager.play('power_up_collect', {
            volume: 0.5
        });
    }, 200);
}
        this.aide.shieldCooldown = 5000; // Longer cooldown
        this.activePowers.shield = 1000;  // Shorter duration
        this.aide.shieldEnergy -= 30;    
        this.showPowerIndicator('shield');
        this.aide.expression = 'focused';
        this.showGameMessage('powerUp');

        // Track shield usage for analytics
        this.analytics.trackPowerUpUsage('shield');
    }
}

activateSlowMotion() {
    if (this.currentState !== this.gameStates.GAMEPLAY) return;
    
    // Toggle functionality - if already active, cancel it
    if (this.activePowers.slowmo > 0) {
        this.activePowers.slowmo = 0;
        console.log('Slow motion cancelled by player');
        return;
    }
    
    // Activate slow motion for 2 seconds
    this.activePowers.slowmo = 2000;
    this.showPowerIndicator('slowmo');
    console.log('Slow motion activated (2 seconds)');

    // Track slowmo usage for analytics
    this.analytics.trackPowerUpUsage('slowmo');
    
     AUDIO
    if (this.audioManager) {
        this.audioManager.play('slowmo_activate', {
            volume: 0.6
        });
    }
}

    /**
     * Show power indicator UI
     * @param {string} type - Power type
     */
    showPowerIndicator(type) {
        const indicator = document.getElementById(type + 'Power');
        if (indicator) {
            indicator.classList.add('active');
            setTimeout(() => {
                indicator.classList.remove('active');
            }, type === 'slowmo' ? 2000 : 1500);
        }
    }

  /**
 * Calculate threat level based on damage
 * @param {number} damage - Projectile damage
 * @returns {string} Threat level
 */
calculateThreatLevel(damage) {
    const threats = this.projectileEffects.threatLevels;
    
    if (damage >= threats.critical.threshold) return 'critical';
    if (damage >= threats.high.threshold) return 'high';
    if (damage >= threats.medium.threshold) return 'medium';
    return 'low';
}

spawnProjectile() {
    // MOBILE: Ultra-conservative spawning
    if (this.isMobile) {
        if (this.projectiles.length >= 1) {
            console.log('Mobile: Skipping spawn, max projectiles reached');
            return; // Only allow 1 projectile at a time on mobile
        }
        
        // Spawn much less frequently on mobile
        if (Math.random() < 0.7) { // 30% chance to skip spawn
            return;
        }
    }
     console.log('ðŸŽª spawnProjectile() called');
    // Mobile projectile limit
    if (this.isMobile && this.projectiles.length >= this.mobileOptimizations.maxProjectiles) {
        console.log('Mobile: Skipping spawn, max projectiles reached:', this.projectiles.length);
        return; // Exit early if mobile has too many projectiles
    }
    console.log('Current projectiles count:', this.projectiles.length);
    
    // Level-based projectile weighting for progressive difficulty
    const levelDangerBonus = Math.min((this.level - 1) * 0.1, 0.4); // Cap at 40% bonus
    
    const types = [
        { name: 'tomato', color: '#FF4757', damage: 15, size: 38, glassTint: '#FF6B6B', weight: Math.max(0.1, 0.3 - levelDangerBonus) },
        { name: 'egg', color: '#FFF8DC', damage: 20, size: 36, glassTint: '#FFFACD', weight: Math.max(0.1, 0.25 - levelDangerBonus) },
        { name: 'shoe', color: '#8B4513', damage: 25, size: 42, glassTint: '#A0522D', weight: 0.2 + levelDangerBonus * 0.5 },
        { name: 'bottle', color: '#228B22', damage: 30, size: 44, glassTint: '#32CD32', weight: 0.15 + levelDangerBonus * 0.3 },
        { name: 'stone', color: '#696969', damage: 35, size: 39, glassTint: '#808080', weight: 0.1 + levelDangerBonus * 0.2 },
        { name: 'banana', color: '#FFD700', damage: 12, size: 40, glassTint: '#FFED4E', weight: Math.max(0.05, 0.15 - levelDangerBonus) },
        { name: 'apple', color: '#DC143C', damage: 18, size: 38, glassTint: '#FF6347', weight: Math.max(0.1, 0.2 - levelDangerBonus * 0.5) }
    ];
    
    console.log('Available projectile types:', types.length);
    
    // Weighted random selection for projectile type
    const totalWeight = types.reduce((sum, t) => sum + t.weight, 0);
    let random = Math.random() * totalWeight;
    let type = types[0];
    
    for (const typeOption of types) {
        random -= typeOption.weight;
        if (random <= 0) {
            type = typeOption;
            break;
        }
    }
    
    console.log('Selected type:', type.name);
    
    // Multi-directional spawn positions
    const crowdPositions = [
        // Left side positions
        { x: 50 + Math.random() * 150, y: 520 + Math.random() * 80 },
        { x: 80 + Math.random() * 120, y: 580 + Math.random() * 60 },
        { x: 30 + Math.random() * 100, y: 550 + Math.random() * 70 },
        
        // Right side positions  
        { x: this.gameWidth - 200 + Math.random() * 150, y: 520 + Math.random() * 80 },
        { x: this.gameWidth - 150 + Math.random() * 120, y: 580 + Math.random() * 60 },
        { x: this.gameWidth - 130 + Math.random() * 100, y: 550 + Math.random() * 70 },
        
        // Center crowd positions
        { x: this.gameWidth * 0.3 + Math.random() * (this.gameWidth * 0.4), y: 540 + Math.random() * 90 },
        { x: this.gameWidth * 0.25 + Math.random() * (this.gameWidth * 0.5), y: 570 + Math.random() * 80 }
    ];

    // Aerial positions (top-down attacks)
    const aerialPositions = [
        { x: this.gameWidth * 0.2 + Math.random() * (this.gameWidth * 0.6), y: -50 },
        { x: this.gameWidth * 0.3 + Math.random() * (this.gameWidth * 0.4), y: -30 },
        { x: this.gameWidth * 0.1 + Math.random() * (this.gameWidth * 0.8), y: -70 }
    ];

    // Side positions (side attacks)
    const sidePositions = [
        { x: -50, y: this.gameHeight * 0.3 + Math.random() * (this.gameHeight * 0.2) },
        { x: this.gameWidth + 50, y: this.gameHeight * 0.3 + Math.random() * (this.gameHeight * 0.2) },
        { x: -30, y: this.gameHeight * 0.4 + Math.random() * (this.gameHeight * 0.15) },
        { x: this.gameWidth + 30, y: this.gameHeight * 0.4 + Math.random() * (this.gameHeight * 0.15) }
    ];

    // Progressive spawn position selection based on level
    const levelProgression = Math.min(this.level, 10) / 10; // 0 to 1 scale
    const aerialChance = 0.1 + (levelProgression * 0.15); // 10% to 25%
    const sideChance = 0.05 + (levelProgression * 0.1);   // 5% to 15%

    let spawnPos;
    const rand = Math.random();

    if (rand < aerialChance) {
        spawnPos = aerialPositions[Math.floor(Math.random() * aerialPositions.length)];
        console.log('Aerial spawn selected');
    } else if (rand < aerialChance + sideChance) {
        spawnPos = sidePositions[Math.floor(Math.random() * sidePositions.length)];
        console.log('Side spawn selected');
    } else {
        spawnPos = crowdPositions[Math.floor(Math.random() * crowdPositions.length)];
        console.log('Crowd spawn selected');
    }
    
    // Target politician
    const targetX = this.politician.x + 40;
    const targetY = this.politician.y + 80;
    const dx = targetX - spawnPos.x;
    const dy = targetY - spawnPos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const speed = 600 + this.level * 50;
    
    const projectile = {
        x: spawnPos.x,
        y: spawnPos.y,
        vx: (dx / distance) * speed,
        vy: (dy / distance) * speed,
        type: type.name,
        color: type.color,
        glassTint: type.glassTint,
        damage: type.damage,
        size: type.size + Math.random() * 6,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.3,
        trail: [],
        launchTrailLife: 800, 
        spawnTime: Date.now(),
        
        // Enhanced projectile properties
        threatLevel: this.calculateThreatLevel(type.damage),
        distanceToPolitician: distance,
        warningShown: false,
        enhancedTrail: [],
        glowIntensity: 1.0 + (type.damage / 50),
        impactPredicted: false
    };

    // Track projectile spawn for analytics
    const projectileId = this.analytics.trackProjectileSpawn(projectile);
    projectile.analyticsId = projectileId;

   // Play projectile whoosh sound
if (this.audioManager) {
    // Play block sound for projectile launch
    this.audioManager.play('block', {
        volume: 0.4
    });
}
    this.projectiles.push(projectile);
    console.log('Projectile added. New count:', this.projectiles.length);
    this.debugLog('info', `Enhanced projectile spawned: ${type.name} (threat: ${projectile.threatLevel}) from (${spawnPos.x.toFixed(0)}, ${spawnPos.y.toFixed(0)}) targeting (${targetX}, ${targetY})`);
    this.debugLog('debug', `Total projectiles: ${this.projectiles.length}`);
}

   /**
 * Show game results screen
 */
showResults() {
    // FIXED: Immediately hide canvas and set transparent background to prevent yellow flash
    this.canvas.style.display = 'none';
    this.canvas.style.visibility = 'hidden';
    this.canvas.style.background = 'transparent';
    this.ctx.fillStyle = 'transparent';
    
    // Set background to transparent to prevent yellow gradient bleed
    document.body.style.background = 'transparent';
    
    // Set state and stop game immediately to prevent stuck screen
    this.currentState = this.gameStates.GAME_OVER;
    this.isRunning = false;
   
    // IMMEDIATE MESSAGE CLEANUP 
    this.hideGameMessage();
    this.messageSystem.isActive = false;
    this.messageSystem.messageTimer = 0;
    
    // Clear the canvas immediately to remove any lingering gameplay graphics
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Stop all game audio except UI sounds
    if (this.audioManager) {
       this.audioManager.stopAllSounds();
    }
    
    //Hide audio toggle on results screen
    const audioToggle = document.getElementById('audioToggle');
    if (audioToggle) {
        audioToggle.classList.remove('show');
        audioToggle.style.display = 'none';
    }
    
    // Hide HUD elements
    const hudElements = ['gameHUD', 'levelInfo', 'powerIndicators'];
    hudElements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.classList.remove('show');
        }
    });
    
    // Calculate statistics
    const sessionDuration = Math.floor((Date.now() - this.sessionStartTime) / 1000);
    const accuracy = this.projectilesBlocked + this.projectilesMissed > 0 ? 
        Math.round((this.projectilesBlocked / (this.projectilesBlocked + this.projectilesMissed)) * 100) : 0;
    
    const performanceRating = this.calculatePerformanceRating(accuracy, this.survivedWaves, sessionDuration);

    // Generate comprehensive session analytics
    const sessionAnalytics = this.analytics.calculateSessionAnalytics();
    console.log("Session Analytics:", sessionAnalytics);

    // Store analytics for potential display or export
    this.lastSessionAnalytics = sessionAnalytics;

    setTimeout(() => {
        this.displayPerformanceRating(performanceRating);
    }, 1800);

    // QR code generation
    setTimeout(() => {
        generateQRCode();
    }, 2000);
    
    // Update UI with delays
    setTimeout(() => {
        this.animateCounterUp('finalScore', this.score, 1500);
        
        setTimeout(() => {
            const sessionTimeEl = document.getElementById('sessionTime');
            if (sessionTimeEl) {
                sessionTimeEl.textContent = this.formatTime(sessionDuration);
            }
        }, 300);
        
        setTimeout(() => {
            this.animateCounterUp('accuracyPercent', accuracy, 1000, '%');
        }, 600);
        
        setTimeout(() => {
            const hitStatsEl = document.getElementById('hitStats');
            if (hitStatsEl) {
                hitStatsEl.textContent = `${this.projectilesBlocked}/${this.projectilesBlocked + this.projectilesMissed}`;
            }
        }, 900);
        
        setTimeout(() => {
            this.animateCounterUp('blockedCount', this.projectilesBlocked, 800);
        }, 1200);
        
        setTimeout(() => {
            this.displayPerformanceRating(performanceRating);
        }, 1800);
        
    }, 200);
    
    this.playResultsSound(performanceRating);
    this.checkAchievements(accuracy, this.survivedWaves, sessionDuration);
    
    // FIXED: Show results screen immediately without setTimeout delay
    const resultsScreen = document.getElementById('resultsScreen');
    if (resultsScreen) {
        resultsScreen.classList.add('show');
    }
        
    // Ensure 3D canvas exists before attempting initialization
    setTimeout(() => {
        const container = document.getElementById('product3DContainer');
        if (container) {
            let canvas = document.getElementById('product3DCanvas');
            if (!canvas) {
                debug3DViewer('ENSURING_CANVAS', 'Creating missing canvas element');
                canvas = document.createElement('canvas');
                canvas.id = 'product3DCanvas';
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.display = 'block';
                container.appendChild(canvas);
            }
        }
    }, 100); // Run this before the 3D viewer initialization
    
    // Initialize 3D Product Viewer with enhanced error handling and debugging
    setTimeout(() => {
    if (!window.pending3DViewerTimeouts) {
        window.pending3DViewerTimeouts = [];
    }

    debug3DViewer('TIMEOUT_SCHEDULED', '1200ms delay');

    const timeoutId = setTimeout(() => {
        debug3DViewer('TIMEOUT_EXECUTING', 'Starting 3D viewer initialization');
        
        // Remove this timeout from tracking array once it executes
        const index = window.pending3DViewerTimeouts.indexOf(timeoutId);
        if (index > -1) {
            window.pending3DViewerTimeouts.splice(index, 1);
            debug3DViewer('TIMEOUT_CLEANUP', 'Removed from tracking array');
        }
        
        // DEFENSIVE CHECK: Skip if game is restarting or not in game over state
        if (!window.game || window.game.currentState !== window.game.gameStates.GAME_OVER) {
            debug3DViewer('SKIP', `Game state check failed. State: ${window.game ? window.game.currentState : 'no game'}`);
            console.log('Skipping 3D viewer init - game not in results state');
            return;
        }

        // Additional check: ensure results screen is still visible
        const resultsScreen = document.getElementById('resultsScreen');
        if (!resultsScreen || !resultsScreen.classList.contains('show')) {
            debug3DViewer('SKIP', `Results screen check failed. Element: ${!!resultsScreen}, hasShow: ${resultsScreen ? resultsScreen.classList.contains('show') : 'N/A'}`);
            console.log('Skipping 3D viewer init - results screen no longer visible');
            return;
        }

        debug3DViewer('CHECKS_PASSED', 'All defensive checks passed');

        try {
            if (typeof Product3DViewer !== 'undefined' && typeof THREE !== 'undefined') {
                const canvas = document.getElementById('product3DCanvas');
                const container = document.getElementById('product3DContainer');
                
                debug3DViewer('DOM_CHECK', `canvas: ${!!canvas}, container: ${!!container}`);
                
                // If canvas is missing but container exists, recreate the canvas
                if (!canvas && container) {
                    debug3DViewer('RECREATING_CANVAS', 'Canvas missing, recreating it');
                    const newCanvas = document.createElement('canvas');
                    newCanvas.id = 'product3DCanvas';
                    newCanvas.style.width = '100%';
                    newCanvas.style.height = '100%';
                    newCanvas.style.display = 'block';
                    container.appendChild(newCanvas);
                    debug3DViewer('CANVAS_RECREATED', 'New canvas element created and added');
                }
                
                // Re-query elements after potential recreation
                const finalCanvas = document.getElementById('product3DCanvas');
                const finalContainer = document.getElementById('product3DContainer');
                
                if (finalCanvas && finalContainer) {
                    // Clean up any existing viewer first
                    if (window.product3DViewer) {
                        debug3DViewer('CLEANUP', 'Destroying existing viewer');
                        try {
                            window.product3DViewer.destroy();
                        } catch (error) {
                            debug3DViewer('CLEANUP_ERROR', error.message);
                            console.warn('Error cleaning up existing 3D viewer:', error);
                        }
                        window.product3DViewer = null;
                    }
                    
                    debug3DViewer('INITIALIZING', 'Creating new Product3DViewer');
                    window.product3DViewer = new Product3DViewer('product3DCanvas', 'product3DContainer');
                    debug3DViewer('SUCCESS', '3D Product Viewer initialized successfully');
                    console.log('3D Product Viewer initialized successfully');
                } else {
                    debug3DViewer('ERROR', 'Canvas or container elements still not available after recreation attempt');
                    console.warn('3D viewer canvas or container not found');
                }
            } else {
                debug3DViewer('ERROR', `Product3DViewer: ${typeof Product3DViewer}, THREE: ${typeof THREE}`);
                console.warn('Product3DViewer or THREE.js not available');
            }
        } catch (error) {
            debug3DViewer('EXCEPTION', error.message);
            console.error('Failed to initialize 3D Product Viewer:', error);
        }
    }, 1200);

    // Track this timeout for potential cancellation
    window.pending3DViewerTimeouts.push(timeoutId);
    debug3DViewer('TIMEOUT_TRACKED', `Timeout ID: ${timeoutId}, Total tracked: ${window.pending3DViewerTimeouts.length}`);
    }, 100); // Changed from 500 to 100
}

 /**
 * Calculate performance rating based on comprehensive metrics (no waves)
 * @param {number} accuracy - Accuracy percentage
 * @param {number} waves - Waves survived (not used)
 * @param {number} duration - Session duration in seconds
 * @returns {string} Performance rating
 */
calculatePerformanceRating(accuracy, waves, duration) {
    let totalScore = 0;
    const maxScore = 100; // This is the internal rating scale (0-100)
    
    // Score contribution (40% weight) - Based on realistic game score benchmarks
    let scoreContribution = 0;
    if (this.score >= 5000) scoreContribution = 40;        // Legendary: 5000+ points
    else if (this.score >= 3000) scoreContribution = 32;   // Excellent: 3000+ points  
    else if (this.score >= 1500) scoreContribution = 24;   // Good: 1500+ points
    else if (this.score >= 750) scoreContribution = 16;    // Fair: 750+ points
    else if (this.score >= 300) scoreContribution = 8;     // Basic: 300+ points
    else scoreContribution = (this.score / 300) * 8;       // Proportional below 300
    
    totalScore += scoreContribution;
    
    // Accuracy contribution (30% weight) - More realistic thresholds
    let accuracyContribution = 0;
    if (accuracy >= 85) accuracyContribution = 30;
    else if (accuracy >= 70) accuracyContribution = 24;
    else if (accuracy >= 55) accuracyContribution = 18;
    else if (accuracy >= 40) accuracyContribution = 12;
    else if (accuracy >= 25) accuracyContribution = 6;
    else accuracyContribution = (accuracy / 25) * 6;       // Proportional below 25%
    
    totalScore += accuracyContribution;
    
    // Duration bonus (15% weight) - Reasonable time expectations
    let durationContribution = 0;
    if (duration >= 180) durationContribution = 15;        // 3+ minutes
    else if (duration >= 120) durationContribution = 12;   // 2+ minutes  
    else if (duration >= 90) durationContribution = 9;     // 1.5+ minutes
    else if (duration >= 60) durationContribution = 6;     // 1+ minute
    else if (duration >= 30) durationContribution = 3;     // 30+ seconds
    else durationContribution = (duration / 30) * 3;       // Proportional below 30s
    
    totalScore += durationContribution;
    
    // Projectiles blocked bonus (15% weight) - Combat performance
    let blockedBonus = 0;
    if (this.projectilesBlocked >= 30) blockedBonus = 15;
    else if (this.projectilesBlocked >= 20) blockedBonus = 12;
    else if (this.projectilesBlocked >= 15) blockedBonus = 9;
    else if (this.projectilesBlocked >= 10) blockedBonus = 6;
    else if (this.projectilesBlocked >= 5) blockedBonus = 3;
    else blockedBonus = (this.projectilesBlocked / 5) * 3; // Proportional below 5
    
    totalScore += blockedBonus;
    
    // Debug logging for transparency
    console.log(`Performance Rating Debug:
        Game Score: ${this.score} (rating points: ${scoreContribution.toFixed(1)}/40)
        Accuracy: ${accuracy}% (rating points: ${accuracyContribution}/30)
        Duration: ${duration}s (rating points: ${durationContribution}/15)
        Blocked: ${this.projectilesBlocked} (rating points: ${blockedBonus.toFixed(1)}/15)
        Total Rating Score: ${totalScore.toFixed(1)}/${maxScore}`);
    
    // Determine rating based on total score
    if (totalScore >= 85) return 'legendary';        // 85-100: Exceptional performance
    else if (totalScore >= 70) return 'excellent';   // 70-84: Very good performance
    else if (totalScore >= 50) return 'good';        // 50-69: Good performance
    else if (totalScore >= 30) return 'fair';        // 30-49: Fair performance  
    else return 'needs_improvement';                  // 0-29: Needs improvement
}


/**
 * Get detailed performance breakdown for debugging
 * @returns {Object} Performance metrics breakdown
 */
getPerformanceBreakdown() {
    const sessionDuration = Math.floor((Date.now() - this.sessionStartTime) / 1000);
    const accuracy = this.projectilesBlocked + this.projectilesMissed > 0 ? 
        Math.round((this.projectilesBlocked / (this.projectilesBlocked + this.projectilesMissed)) * 100) : 0;
    
    return {
        score: this.score,
        accuracy: accuracy,
        projectilesBlocked: this.projectilesBlocked,
        projectilesMissed: this.projectilesMissed,
        survivedWaves: this.survivedWaves,
        sessionDuration: sessionDuration,
        politicianHealthRemaining: this.politicianHealth,
        level: this.level,
        currentWave: this.wave
    };
}
    /**
     * Animate counter numbers
     * @param {string} elementId - Element ID
     * @param {number} targetValue - Target value
     * @param {number} duration - Animation duration
     * @param {string} suffix - Text suffix
     */
    animateCounterUp(elementId, targetValue, duration, suffix = '') {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        const startValue = 0;
        const increment = targetValue / (duration / 16);
        let currentValue = startValue;
        
        const timer = setInterval(() => {
            currentValue += increment;
            if (currentValue >= targetValue) {
                currentValue = targetValue;
                clearInterval(timer);
            }
            
            if (elementId === 'finalScore') {
                element.textContent = Math.floor(currentValue).toLocaleString() + suffix;
            } else {
                element.textContent = Math.floor(currentValue) + suffix;
            }
        }, 16);
    }

    /**
     * Format time display
     * @param {number} seconds - Seconds
     * @returns {string} Formatted time
     */
    formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

 /**
 * Display performance rating 
 * @param {string} rating - Performance rating
 */
displayPerformanceRating(rating) {
    const ratingElement = document.getElementById('performanceRating');
    if (!ratingElement) return;
    
    const ratings = {
        'legendary': { 
            text: 'LEGENDARY! Daag ki band bajaa di!', 
            class: 'rating-legendary', 
            color: '#1A2F85'
        },
        'excellent': { 
            text: 'Wah bhai! Fab-tastic Defense!', 
            class: 'rating-excellent', 
            color: '#0097D7'
        },
        'good': { 
            text: 'Solid hai! Daag bhaag gaye.', 
            class: 'rating-good', 
            color: '#EF3E42'
        },
        'fair': { 
            text: 'Theek thaak, aur koshish kar!', 
            class: 'rating-fair', 
            color: '#00A859'
        },
        'needs_improvement': { 
            text: 'Abhi practice karo yaar!', 
            class: 'rating-poor', 
            color: '#000000'
        }
    };
    
    const ratingData = ratings[rating];
    ratingElement.textContent = ratingData.text;
    ratingElement.className = `performance-rating ${ratingData.class}`;
    ratingElement.style.color = ratingData.color;
    ratingElement.style.animation = 'pulse 0.6s ease-in-out';
    
    // Debug logging with actual performance data
    const breakdown = this.getPerformanceBreakdown();
    console.log(`Performance Rating: ${rating} - ${ratingData.text}`);
    console.log('Performance breakdown:', breakdown);
    
    if (rating === 'legendary') {
        this.addScreenFlashEffect();
    }
}

    /**
     * Add screen flash effect
     */
    addScreenFlashEffect() {
        const flashOverlay = document.createElement('div');
        flashOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%);
            pointer-events: none;
            z-index: 9999;
            animation: flashEffect 0.8s ease-out;
        `;
        
        document.body.appendChild(flashOverlay);
        
        setTimeout(() => {
            document.body.removeChild(flashOverlay);
        }, 800);
    }

/**
 * Play results sound
 * @param {string} rating - Performance rating
 */
playResultsSound(rating) {
    if (!this.audioManager) return;
    
    // Map performance ratings to available sounds using playSound method
    const soundMap = {
        'legendary': 'victory_sound',
        'excellent': 'victory_sound', 
        'good': 'combo_achievement',
        'fair': 'ui_click',
        'needs_improvement': 'health_critical'
    };
    
    const soundToPlay = soundMap[rating] || 'ui_click';
    
    // Use playSound method instead of checking soundLibrary
    this.audioManager.play(soundToPlay, {
        volume: 0.8
    });
}
    /**
     * Check for achievements
     * @param {number} accuracy - Accuracy percentage
     * @param {number} waves - Waves survived
     * @param {number} duration - Session duration
     */
    checkAchievements(accuracy, waves, duration) {
        const achievements = [];
        
        // Accuracy achievements
        if (accuracy === 100) {
            achievements.push({ name: 'Perfect Aim', description: '100% Accuracy!' });
        } else if (accuracy >= 95) {
            achievements.push({ name: 'Sharp Shooter', description: '95%+ Accuracy!' });
        }
        
        // Wave survival achievements
        if (waves >= 20) {
            achievements.push({ name: 'Wave Master', description: 'Survived 20+ waves!' });
        } else if (waves >= 15) {
            achievements.push({ name: 'Seasoned Defender', description: 'Survived 15+ waves!' });
        } else if (waves >= 10) {
            achievements.push({ name: 'Steady Guardian', description: 'Survived 10+ waves!' });
        }
        
        // Duration achievements
        if (duration >= 600) {
            achievements.push({ name: 'Marathon Defender', description: 'Defended for 10+ minutes!' });
        } else if (duration >= 300) {
            achievements.push({ name: 'Persistent Protector', description: 'Defended for 5+ minutes!' });
        }
        
        // Score achievements
        if (this.score >= 100000) {
            achievements.push({ name: 'Score Champion', description: '100,000+ points!' });
        } else if (this.score >= 50000) {
            achievements.push({ name: 'High Scorer', description: '50,000+ points!' });
        }
        
        if (achievements.length > 0) {
            this.displayAchievements(achievements);
        }
    }

    /**
     * Display earned achievements
     * @param {Array} achievements - Achievement array
     */
    displayAchievements(achievements) {
        const achievementContainer = document.getElementById('achievements');
        if (!achievementContainer) return;
        
        achievementContainer.innerHTML = '';
        achievements.forEach((achievement, index) => {
            setTimeout(() => {
                const achievementElement = document.createElement('div');
                achievementElement.className = 'achievement-item';
                achievementElement.innerHTML = `
                     <div class="achievement-icon">ðŸ†</div>
                    <div class="achievement-text">
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-desc">${achievement.description}</div>
                    </div>
                `;
                achievementContainer.appendChild(achievementElement);
                
                setTimeout(() => {
                    achievementElement.style.animation = 'slideInRight 0.5s ease-out';
                }, 50);
            }, index * 500);
        });
    }

    /**
     * Start the main game loop
     */
  // 3. SAFER GAME LOOP WITH MOBILE SAFEGUARDS
startGameLoop() {
    let frameCount = 0;
    let lastFPSTime = performance.now();
    let frameSkipCounter = 0;
    let errorCount = 0;
    let lastUpdateTime = 0;
    const maxErrors = 5; // Reduced from 10
    
    this.gameLoopId = null;
    
    const gameLoop = (currentTime) => {
        this.gameLoopId = null;
        
        try {
            // CRITICAL: More aggressive exit conditions
            if (!this.isRunning || 
                this.currentState !== this.gameStates.GAMEPLAY ||
                this.politicianHealth <= 0 ||
                errorCount >= maxErrors ||
                !document.hasFocus()) { // Stop when page loses focus
                
                console.log("Game loop stopped - condition failed");
                this.stopGameLoop();
                return;
            }
            
            // NEW TIME-BASED THROTTLING (replace with this):
if (this.isMobile) {
    const now = performance.now();
    if (!this.lastMobileFrame) this.lastMobileFrame = 0;
    
    // Throttle to max 20 FPS (50ms intervals)
    if (now - this.lastMobileFrame < 50) {
        this.gameLoopId = requestAnimationFrame(gameLoop);
        return;
    }
    this.lastMobileFrame = now;
}
            
            // CRITICAL: Throttle update frequency on mobile
            const now = performance.now();
            if (this.isMobile && (now - lastUpdateTime) < 66) { // Limit to 15fps max
                this.gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }
            lastUpdateTime = now;
            
            const frameStart = performance.now();
            
            // Cap deltaTime more aggressively for mobile stability
            this.deltaTime = Math.min((currentTime - this.lastTime) / 1000, this.isMobile ? 0.05 : 0.033);
            this.lastTime = currentTime;
            
            // CRITICAL: Wrap update and render in separate try-catch
            try {
                this.update(this.deltaTime);
            } catch (updateError) {
                console.error('Update error:', updateError);
                errorCount++;
            }
            
            try {
                this.render();
            } catch (renderError) {
                console.error('Render error:', renderError);
                errorCount++;
            }
            
            // Mobile performance monitoring
            const frameTime = performance.now() - frameStart;
            if (this.isMobile && frameTime > 50) { // Frame took longer than 50ms
                console.warn(`Mobile frame overrun: ${frameTime.toFixed(2)}ms`);
                errorCount++; // Count slow frames as errors
            }
            
            // Continue only if everything is still OK
            if (this.isRunning && 
                this.currentState === this.gameStates.GAMEPLAY && 
                this.politicianHealth > 0 &&
                errorCount < maxErrors) {
                this.gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                console.log('Game loop natural end');
                this.stopGameLoop();
            }
            
        } catch (error) {
            errorCount++;
            console.error(`Critical game loop error ${errorCount}/${maxErrors}:`, error);
            
            if (errorCount >= maxErrors) {
                console.error('Too many errors, emergency stop');
                this.stopGameLoop();
                // Show user-friendly error
                setTimeout(() => {
                    alert('Game encountered errors. Refreshing page...');
                    window.location.reload();
                }, 100);
            } else {
                this.gameLoopId = requestAnimationFrame(gameLoop);
            }
        }
    };
    
    console.log('Starting mobile-optimized game loop');
    this.gameLoopId = requestAnimationFrame(gameLoop);
}

stopGameLoop() {
    console.log('ðŸ›‘ stopGameLoop() - Comprehensive cleanup initiated');
    
    // CRITICAL: Immediately set running flag to false
    this.isRunning = false;
    
    // CRITICAL: Cancel any pending animation frames
    if (this.gameLoopId) {
        cancelAnimationFrame(this.gameLoopId);
        this.gameLoopId = null;
        console.log('Animation frame cancelled');
    }
    
    // IMMEDIATE CANVAS CLEANUP - Prevents brown overlay completely
    if (this.canvas && this.ctx) {
        // Clear all canvas content immediately
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Reset canvas transform to prevent stuck transformations
        this.ctx.resetTransform();
        
        // Clear any lingering canvas styles that might cause overlay
        this.ctx.globalAlpha = 1.0;
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.filter = 'none';
        
        // Hide canvas immediately
        this.canvas.style.display = 'none';
        this.canvas.style.visibility = 'hidden';
        this.canvas.style.opacity = '0';
        
        console.log('Canvas cleared and hidden');
    }
    
    // CLEAR ALL GAME OBJECTS - Prevents lingering renders
    this.projectiles = [];
    this.particles = [];
    this.trailParticles = [];
    
    // Clear atmospheric particles that contribute to brown overlay
    if (this.atmosphericSystem && this.atmosphericSystem.particles) {
        this.atmosphericSystem.particles = [];
    }
    
    // Reset camera effects
    this.cameraShake = { x: 0, y: 0, intensity: 0 };
    
    // Clear screen effects that might cause overlay
    if (this.screenEffects) {
        this.screenEffects.flash.active = false;
        this.screenEffects.colorOverlay.active = false;
        this.screenEffects.slowMotion.active = false;
    }
    
    // STOP MESSAGE SYSTEM - Prevents UI conflicts
    if (this.messageSystem) {
        this.hideGameMessage();
        this.messageSystem.isActive = false;
        this.messageSystem.messageTimer = 0;
        this.messageSystem.currentMessage = '';
    }
    
    // AUDIO CLEANUP - Stop all game audio
    if (this.audioManager) {
        this.audioManager.stopAllSounds();
        console.log('All audio stopped');
    }
    
    // CLEAR CACHED CROWD - Prevents brown crowd overlay
    this.crowdCache = null;
    
    // RESET ANIMATION TIMERS - Prevents stuck animations
    if (this.characterAnimTimers) {
        this.characterAnimTimers.politician = 0;
        this.characterAnimTimers.aide = 0;
    }
    
    if (this.crowdAnimation) {
        this.crowdAnimation.time = 0;
    }
    
    // FORCE GARBAGE COLLECTION HINTS (where supported)
    if (window.gc && typeof window.gc === 'function') {
        try {
            window.gc();
        } catch (e) {
            // Garbage collection not available, continue
        }
    }
    
    console.log('ðŸ”’ Game loop forcibly stopped - Brown overlay prevented');
}

    /**
     * Update game logic
     * @param {number} deltaTime - Time delta
     */
  update(deltaTime) {
    if (this.currentState !== this.gameStates.GAMEPLAY) return;
    
    // MOBILE: Run memory optimization every 30 frames instead of 60
    if (this.isMobile) {
        if (!this.mobileFrameCount) this.mobileFrameCount = 0;
        this.mobileFrameCount++;
        
        // CHANGE THIS: More frequent cleanup - every 30 frames instead of 60
        if (this.mobileFrameCount % 30 === 0) {
            this.optimizeMemoryForMobile();
        }
        
        // Cap deltaTime more aggressively
        deltaTime = Math.min(deltaTime, 0.05); // Changed from 0.033 to 0.05
    }
    
    const timeMultiplier = this.activePowers.slowmo > 0 ? 0.5 : 1.0; // Less dramatic slowmo
    const adjustedDelta = deltaTime * timeMultiplier;

    // Update politician reaction timer
    if (this.politician.reactionTimer > 0) {
        this.politician.reactionTimer -= deltaTime * 1000;
        if (this.politician.reactionTimer <= 0) {
            this.politician.reactionState = 'normal';
            console.log('Politician returned to normal state');
        }
    }

    // Update message bubble
    if (this.politician.messageBubble.isVisible) {
        this.politician.messageBubble.timer -= deltaTime * 1000;
        this.politician.messageBubble.fadeIn = Math.min(1, this.politician.messageBubble.fadeIn + deltaTime * 4);
        
        if (this.politician.messageBubble.timer <= 0) {
            this.politician.messageBubble.isVisible = false;
        }
    }
        
    this.updatePowerUps(deltaTime);
    this.updateCharacterAnimations(deltaTime);
    this.updateCrowdAnimations(deltaTime);
    this.updateAide(adjustedDelta);
    this.updateProjectiles(adjustedDelta);
    this.updateProjectileEffects(deltaTime);
    this.updateParticles(adjustedDelta);
    this.updateTimers(deltaTime);
    this.updateCameraShake(deltaTime);
    this.updateScreenEffects(deltaTime);
    this.updateMessageSystem(deltaTime);
    this.updateReactionSystem(deltaTime);
    this.checkCollisions();
    this.updateUI();

    // ADD THIS BLOCK - Mobile memory management
    if (this.isMobile) {
        // Increment frame counter
        if (!this.renderFrameId) this.renderFrameId = 0;
        this.renderFrameId++;
        
        // Run optimization every 3 seconds (180 frames at 60fps, 90 frames at 30fps)
        if (this.renderFrameId % 180 === 0) {
            this.optimizeMemoryForMobile();
        }
    }
}
  
//AGGRESSIVE MOBILE MEMORY MANAGEMENT
optimizeMemoryForMobile() {
    if (!this.isMobile) return;
    
    // NUCLEAR memory cleanup - more aggressive than current
    
    // 1. Eliminate ALL particles immediately
    this.particles = [];
    this.trailParticles = [];
    
    // 2. Limit projectiles to absolute minimum
    if (this.projectiles.length > 1) {
        this.projectiles = [this.projectiles[this.projectiles.length - 1]]; // Keep only newest
    }
    
    // 3. Clear atmospheric particles completely
    if (this.atmosphericSystem && this.atmosphericSystem.particles) {
        this.atmosphericSystem.particles = [];
    }
    
    // 4. Clear all analytics on mobile to free memory
    if (this.analytics) {
        this.analytics.projectileAnalytics = this.analytics.projectileAnalytics.slice(-5); // Keep only last 5
        this.analytics.reactionTimeData = this.analytics.reactionTimeData.slice(-10); // Keep only last 10
        this.analytics.defensePatterns = this.analytics.defensePatterns.slice(-10); // Keep only last 10
    }
    
    // 5. Clear message system immediately
    if (this.messageSystem) {
        this.messageSystem.isActive = false;
        this.messageSystem.currentMessage = '';
        this.messageSystem.messageTimer = 0;
    }
    
    // 6. Limit politician stains
    if (this.politician && this.politician.stains && this.politician.stains.length > 3) {
        this.politician.stains = this.politician.stains.slice(-3); // Keep only last 3
    }
    
    // 7. Clear any cached data
    this.crowdCache = null;
    
    // 8. Force garbage collection if available
    if (window.gc && typeof window.gc === 'function') {
        try {
            window.gc();
        } catch (e) {}
    }
    
    console.log('MOBILE: Nuclear memory cleanup performed');
}

    /**
     * Update power-ups
     * @param {number} deltaTime - Time delta
     */
    updatePowerUps(deltaTime) {
        Object.keys(this.activePowers).forEach(power => {
            if (this.activePowers[power] > 0) {
                this.activePowers[power] -= deltaTime;
            }
        });
        
        if (this.aide.shieldCooldown > 0) {
            this.aide.shieldCooldown -= deltaTime;
        }
        
        if (this.activePowers.shield <= 0) {
            this.aide.shield = false;
        }
    }

    /**
 * Update health bar visual state
 */
updateHealthBarStyling() {
    const healthFillEl = document.getElementById('healthFill');
    if (!healthFillEl) return;
    
    const healthPercent = Math.max(0, (this.politicianHealth / this.maxHealth) * 100);
    
    // Remove existing health state classes
    healthFillEl.classList.remove('health-critical', 'health-warning', 'health-good');
    
    // Add appropriate class based on health level
    if (healthPercent <= 25) {
        healthFillEl.classList.add('health-critical');
    } else if (healthPercent <= 50) {
        healthFillEl.classList.add('health-warning');
    } else {
        healthFillEl.classList.add('health-good');
    }
}

    /**
     * Update aide character
     * @param {number} deltaTime - Time delta
     */
   updateAide(deltaTime) {
    let moveSpeed = this.aide.speed;
    if (this.activePowers.speed > 0) moveSpeed *= 1.8;
    if (this.isMobile) moveSpeed *= 1.2;
    
    let moved = false;
    
    // Input handling
    const moveUp = this.keys['KeyW'] || this.keys['ArrowUp'] || this.touchControls.up;
    const moveDown = this.keys['KeyS'] || this.keys['ArrowDown'] || this.touchControls.down;
    const moveLeft = this.keys['KeyA'] || this.keys['ArrowLeft'] || this.touchControls.left;
    const moveRight = this.keys['KeyD'] || this.keys['ArrowRight'] || this.touchControls.right;
    
    if (moveUp) {
        this.aide.y -= moveSpeed * deltaTime;
        moved = true;
    }
    if (moveDown) {
        this.aide.y += moveSpeed * deltaTime;
        moved = true;
    }
    if (moveLeft) {
    this.aide.x -= moveSpeed * deltaTime;
    this.aide.facingDirection = -1;
    // FIXED: No text mirroring
    this.aide.spriteFlipped = false; 
    moved = true;
}
if (moveRight) {
    this.aide.x += moveSpeed * deltaTime;
    this.aide.facingDirection = 1;
    this.aide.spriteFlipped = false; 
    moved = true;
}
    
    // Animation and effects
    if (moved) {
        this.aide.bounceY = Math.sin(Date.now() * 0.02) * 2 - 5;
        
        if (Math.random() < 0.7) {
            this.createTrailParticle(
                this.aide.x + this.aide.width/2 + (Math.random() - 0.5) * 20,
                this.aide.y + this.aide.height/2 + (Math.random() - 0.5) * 20,
                -moveSpeed * deltaTime * (Math.random() * 0.5 + 0.5),
                (Math.random() - 0.5) * 100
            );
        }
    } else {
        this.aide.bounceY = Math.sin(Date.now() * 0.01) * 1 - 5;
    }

      // Slowly regenerate shield energy
      if (this.aide.shieldEnergy < this.aide.maxShieldEnergy) {
          this.aide.shieldEnergy += 8 * deltaTime; // Regen rate
          this.aide.shieldEnergy = Math.min(this.aide.maxShieldEnergy, this.aide.shieldEnergy);
    }
    
// Enhanced boundary constraints for aerial defense
const marginX = this.gameWidth * 0.05;
const marginY = this.gameHeight * 0.05;
const groundY = this.gameHeight * 0.65;
const maxX = this.gameWidth - this.aide.width - marginX;
const maxY = this.gameHeight - this.aide.height - marginY;

// Expanded movement area for aerial defense
const expandedMinY = this.gameHeight * 0.2; // move higher
const stageMinY = groundY - this.aide.height; // stage constraint

// Check for aerial threats that require expanded movement
const hasAerialThreats = this.projectiles.some(proj => 
    proj.y < this.gameHeight * 0.4 && 
    Math.abs(proj.x - (this.aide.x + this.aide.width/2)) < 200
);

// Use expanded area during aerial threats, stage area otherwise
const activeMinY = hasAerialThreats ? expandedMinY : stageMinY;

// Apply movement speed bonus when moving toward aerial threats
if (hasAerialThreats && (this.keys['KeyW'] || this.keys['ArrowUp'] || this.touchControls.up)) {
    moveSpeed *= 1.3; // 30% speed boost when moving up toward aerial threats
    this.aide.expression = 'focused'; // Visual feedback
}

this.aide.x = Math.max(marginX, Math.min(maxX, this.aide.x));
this.aide.y = Math.max(activeMinY, Math.min(maxY, this.aide.y));
}
    /**
     * Update projectiles
     * @param {number} deltaTime - Time delta
     */
    updateProjectiles(deltaTime) {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];

             // ADD SAFETY CHECK - Initialize trail if missing
            if (!proj.trail) {
            proj.trail = [];
           }
            
              // Add to trail
            proj.trail.push({ x: proj.x, y: proj.y });
            if (proj.trail.length > 5) proj.trail.shift();
            
            proj.x += proj.vx * deltaTime;
            proj.y += proj.vy * deltaTime;
            proj.rotation += proj.rotationSpeed;
            
            // Apply gravity
            proj.vy += 50 * deltaTime;
            
            // Remove if out of bounds
            if (proj.x < -200 || proj.x > this.gameWidth + 200 || 
                proj.y > this.gameHeight + 200 || proj.y < -200) {
            if (this.audioManager && proj.y > this.gameHeight + 100) {
            // Only play miss sound if projectile went past the politician
                this.audioManager.play('miss', {
                volume: 0.3,
                pan: (proj.x / this.gameWidth - 0.5) * 2
            });
            }    
                this.projectiles.splice(i, 1);
                continue;
            }
            
            // Check politician collision
            if (this.isColliding(proj, this.politician.hitbox)) {
                this.hitPolitician(proj);
                this.projectiles.splice(i, 1);
                this.projectilesMissed++;
                this.debugLog('warn', `Politician hit! Health: ${this.politicianHealth} (-${proj.damage})`);
            }
        }
    }

 /**
 * Update projectile trails and effects
 * @param {number} deltaTime - Time delta
 */
updateProjectileEffects(deltaTime) {
    // Simplified projectile effects for mobile
    if (this.isMobile) {
        // Only basic distance tracking on mobile
        this.projectiles.forEach(proj => {
            const dx = proj.x - (this.politician.x + this.politician.width/2);
            const dy = proj.y - (this.politician.y + this.politician.height/2);
            proj.distanceToPolitician = Math.sqrt(dx * dx + dy * dy);
        });
        return; // Skip all enhanced effects
    }
    
    // Full desktop effects 
    this.projectiles.forEach(proj => {
        // Update enhanced trail system
        this.updateEnhancedTrail(proj, deltaTime);
        
        // Check for impact prediction
        this.updateImpactPrediction(proj);
        
        // Update threat warnings
        this.updateThreatWarnings(proj);
        
        // Update distance to politician
        const dx = proj.x - (this.politician.x + this.politician.width/2);
        const dy = proj.y - (this.politician.y + this.politician.height/2);
        proj.distanceToPolitician = Math.sqrt(dx * dx + dy * dy);
    });
    
    // Clean up old warning indicators
    this.projectileEffects.warningIndicators = this.projectileEffects.warningIndicators.filter(
        indicator => indicator.life > 0
    );
    
    // Update warning indicators
    this.projectileEffects.warningIndicators.forEach(indicator => {
        indicator.life -= deltaTime;
        indicator.alpha = Math.max(0, indicator.life / indicator.maxLife);
        indicator.radius += indicator.expandSpeed * deltaTime;
    });
}

/**
 * Update enhanced trail for projectile
 * @param {Object} proj - Projectile object
 * @param {number} deltaTime - Time delta
 */
updateEnhancedTrail(proj, deltaTime) {
    const trail = this.projectileEffects.trailSystem;
    
    // Add current position to enhanced trail
    proj.enhancedTrail.push({
        x: proj.x,
        y: proj.y,
        time: Date.now(),
        alpha: 1.0,
        size: proj.size * 0.8
    });
    
    // Maintain trail length
    if (proj.enhancedTrail.length > trail.maxTrailLength) {
        proj.enhancedTrail.shift();
    }
    
    // Update trail alpha
    proj.enhancedTrail.forEach((point, index) => {
        const age = (Date.now() - point.time) / 1000;
        point.alpha = Math.max(0, 1.0 - (age * trail.fadeRate * 2));
        point.size *= 0.98; // Gradually shrink
    });
    
    // Remove old trail points
    proj.enhancedTrail = proj.enhancedTrail.filter(point => point.alpha > 0.05);
}

/**
 * Create impact prediction visual
 * @param {Object} proj - Projectile object
 */
createImpactPrediction(proj) {
    // Calculate predicted impact point
    const timeToImpact = proj.distanceToPolitician / Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
    const impactX = proj.x + proj.vx * timeToImpact;
    const impactY = proj.y + proj.vy * timeToImpact;
    
    // Impact predictions array
    this.projectileEffects.impactPredictions.push({
        x: impactX,
        y: impactY,
        radius: 5,
        maxRadius: 40,
        life: 1.5,
        maxLife: 1.5,
        color: this.projectileEffects.threatLevels[proj.threatLevel].color,
        threatLevel: proj.threatLevel,
        pulseSpeed: proj.threatLevel === 'critical' ? 3 : 2
    });
}

/**
 * Create threat warning indicator
 * @param {Object} proj - Projectile object
 */
createThreatWarning(proj) {
    const threatColor = this.projectileEffects.threatLevels[proj.threatLevel].color;
    
    this.projectileEffects.warningIndicators.push({
        x: proj.x,
        y: proj.y,
        radius: 30,
        maxRadius: 80,
        expandSpeed: 50,
        life: 2.0,
        maxLife: 2.0,
        alpha: 1.0,
        color: threatColor,
        threatLevel: proj.threatLevel,
        pulseIntensity: proj.threatLevel === 'critical' ? 1.5 : 1.0
    });
    
    // Screen flash for critical threats
    if (proj.threatLevel === 'critical') {
        this.cameraShake.intensity = Math.max(this.cameraShake.intensity, 8);
    }
}

/**
 * Update impact prediction system
 * @param {Object} proj - Projectile object
 */
updateImpactPrediction(proj) {
    const predictionDistance = 120;
    
    if (proj.distanceToPolitician <= predictionDistance && !proj.impactPredicted) {
        proj.impactPredicted = true;
        
        // Create impact prediction indicator
        this.createImpactPrediction(proj);
    }
}

/**
 * Update threat warning system
 * @param {Object} proj - Projectile object
 */
updateThreatWarnings(proj) {
    const warningDistance = 200;
    
    if (proj.distanceToPolitician <= warningDistance && !proj.warningShown && 
        (proj.threatLevel === 'high' || proj.threatLevel === 'critical')) {
        
        proj.warningShown = true;
        this.createThreatWarning(proj);
    }
}   

    /**
 * Update particles
 * @param {number} deltaTime - Time delta
 */
updateParticles(deltaTime) {
    this.updateTrailParticles(deltaTime);
    
    for (let i = this.particles.length - 1; i >= 0; i--) {
        const particle = this.particles[i];
        
        particle.x += particle.vx * deltaTime;
        particle.y += particle.vy * deltaTime;
        particle.life -= deltaTime;
        particle.vy += 200 * deltaTime; // Your existing gravity
        
        // Handle rotation for spinning particles
        if (particle.spin) {
            particle.rotation = (particle.rotation || 0) + particle.spin;
        }
        
        // Handle twinkling effect
        if (particle.twinkle) {
            particle.alpha = 0.5 + 0.5 * Math.sin(Date.now() * 0.01 + i);
        } else if (particle.sparkle) {
            particle.alpha = 0.7 + 0.3 * Math.sin(Date.now() * 0.02 + i * 0.5);
        } else {
            particle.alpha = particle.life / particle.maxLife;
        }
        
        // Handle bouncing for debris
        if (particle.type === 'debris' && particle.y > this.gameHeight - 50 && particle.vy > 0) {
            particle.vy *= -0.4;
            particle.vx *= 0.7;
            particle.spin *= 0.8;
        }
        
        // Existing cleanup
        if (particle.life <= 0) {
            this.particles.splice(i, 1);
        }
    }
}

    /**
     * Update trail particles
     * @param {number} deltaTime - Time delta
     */
    updateTrailParticles(deltaTime) {
        for (let i = this.trailParticles.length - 1; i >= 0; i--) {
            const particle = this.trailParticles[i];
            
            particle.x += particle.vx * deltaTime;
            particle.y += particle.vy * deltaTime;
            particle.life -= deltaTime;
            particle.alpha = particle.life / particle.maxLife;
            particle.size += deltaTime * 2;
            
            particle.vx *= 0.95;
            particle.vy *= 0.95;
            
            if (particle.life <= 0) {
                this.trailParticles.splice(i, 1);
            }
        }
    }

    /**
     * Update game timers
     * @param {number} deltaTime - Time delta
     */
   updateTimers(deltaTime) {
    // Update spawn rate (more aggressive with level/wave progression)
    this.projectileSpawnRate = Math.max(800, 2000 - (this.level * 200) - (this.wave * 150));
    
    this.projectileSpawnTimer += deltaTime;
    this.waveTimer += deltaTime;
    
    // Wave-based spawning system
    if (!this.waveSpawning || !this.waveSpawning.isActive) {
        if (this.projectileSpawnTimer >= (this.projectileSpawnRate / 1000)) {
            console.log('ðŸš€ Starting projectile wave!');
            this.startProjectileWave();
            this.projectileSpawnTimer = 0;
        }
    } else {
        this.updateProjectileWave(deltaTime);
    }
    
    // Game wave progression (separate from projectile waves)
    if (this.waveTimer >= this.waveDuration) {
        this.nextWave();
    }
}

// Required supporting methods for wave system
startProjectileWave() {
    // Initialize waveSpawning if needed
    if (!this.waveSpawning) {
        this.waveSpawning = {};
    }
    
    this.waveSpawning.isActive = true;
    this.waveSpawning.timer = 0;
    this.waveSpawning.projectilesSpawned = 0;
    this.waveSpawning.projectilesInWave = Math.min(3 + Math.floor(this.level / 2), 8); // 3-8 projectiles per wave
    this.waveSpawning.spawnInterval = Math.max(200, 600 - (this.level * 50)); // 200-600ms between projectiles in wave
    
    console.log(`ðŸŒŠ Wave started: ${this.waveSpawning.projectilesInWave} projectiles, ${this.waveSpawning.spawnInterval}ms interval`);
}

updateProjectileWave(deltaTime) {
    if (!this.waveSpawning || !this.waveSpawning.isActive) return;
    
    this.waveSpawning.timer += deltaTime;
    
    // Time to spawn next projectile in wave?
    if (this.waveSpawning.timer >= (this.waveSpawning.spawnInterval / 1000)) {
        if (this.waveSpawning.projectilesSpawned < this.waveSpawning.projectilesInWave) {
            console.log(`ðŸŽ¯ Wave projectile ${this.waveSpawning.projectilesSpawned + 1}/${this.waveSpawning.projectilesInWave}`);
            this.spawnProjectile();
            this.waveSpawning.projectilesSpawned++;
            this.waveSpawning.timer = 0;
        } else {
            // Wave complete
            console.log('ðŸ ÂÂ Projectile wave completed!');
            this.waveSpawning.isActive = false;
        }
    }
}

spawnProjectileBurst() {
    const projectilesInBurst = Math.floor(1 + this.waveSpawning.intensity);
    console.log('ðŸŽ¯ Spawning burst with', projectilesInBurst, 'projectiles');
    
    for (let i = 0; i < projectilesInBurst; i++) {
        setTimeout(() => {
            console.log('ðŸŽ¯ Attempting to spawn projectile', i + 1);
            this.spawnProjectile();
        }, i * 200);
    }
}

/**
 * End current wave and start rest period
 */
endProjectileWave() {
    this.waveSpawning.isActive = false;
    this.waveSpawning.restTimer = 0;
}


    /**
 * Update enhanced camera shake system
 * @param {number} deltaTime - Time delta
 */
updateCameraShake(deltaTime) {
    const shake = this.screenEffects.shake;
    
    if (shake.intensity > 0) {
        // Different shake patterns based on type
        switch (shake.type) {
            case 'impact':
                this.cameraShake.x = (Math.random() - 0.5) * shake.intensity;
                this.cameraShake.y = (Math.random() - 0.5) * shake.intensity;
                break;
                
            case 'explosion':
                const time = Date.now() * 0.05;
                this.cameraShake.x = Math.sin(time) * shake.intensity;
                this.cameraShake.y = Math.cos(time * 1.3) * shake.intensity;
                break;
                
            case 'critical':
                const criticalTime = Date.now() * 0.02;
                this.cameraShake.x = Math.sin(criticalTime) * shake.intensity * 1.5;
                this.cameraShake.y = Math.sin(criticalTime * 2.1) * shake.intensity;
                break;
        }
        
        // Decay shake intensity
        shake.intensity -= shake.decayRate * deltaTime;
        shake.duration -= deltaTime;
        
        if (shake.intensity <= 0 || shake.duration <= 0) {
            shake.intensity = 0;
            shake.duration = 0;
            this.cameraShake.x = 0;
            this.cameraShake.y = 0;
        }
    }
}

/**
 * Trigger enhanced screen shake
 * @param {number} intensity - Shake intensity
 * @param {number} duration - Shake duration
 * @param {string} type - Shake type (impact, explosion, critical)
 */
triggerScreenShake(intensity, duration = 0.5, type = 'impact') {
    const shake = this.screenEffects.shake;
    
    // Only override if new shake is stronger
    if (intensity > shake.intensity) {
        shake.intensity = intensity;
        shake.duration = duration;
        shake.type = type;
    }
}

/**
 * Trigger screen flash effect
 * @param {string} color - Flash color
 * @param {number} intensity - Flash intensity (0-1)
 * @param {number} duration - Flash duration
 */
triggerScreenFlash(color = '#FFFFFF', intensity = 0.3, duration = 0.2) {
    const flash = this.screenEffects.flash;
    
    flash.active = true;
    flash.color = color;
    flash.intensity = Math.max(flash.intensity, intensity);
    flash.duration = Math.max(flash.duration, duration);
}

/**
 * Trigger color overlay effect
 * @param {string} color - Overlay color
 * @param {number} intensity - Overlay intensity (0-1)
 * @param {number} duration - Overlay duration
 */
triggerColorOverlay(color = '#FF0000', intensity = 0.2, duration = 1.0) {
    const overlay = this.screenEffects.colorOverlay;
    
    overlay.active = true;
    overlay.color = color;
    overlay.intensity = Math.max(overlay.intensity, intensity);
    overlay.duration = Math.max(overlay.duration, duration);
}

/**
 * Update screen effects system
 * @param {number} deltaTime - Time delta
 */
updateScreenEffects(deltaTime) {
    // Skip all screen effects on mobile for performance
    if (this.isMobile) return;
    
    // Existing desktop screen effects code continues unchanged...
    const effects = this.screenEffects;
    
    // Update flash effect
    if (effects.flash.active) {
        effects.flash.duration -= deltaTime;
        effects.flash.intensity = Math.max(0, 
            effects.flash.intensity - effects.flash.fadeRate * deltaTime
        );
        
        if (effects.flash.duration <= 0 || effects.flash.intensity <= 0) {
            effects.flash.active = false;
        }
    }

    // Update color overlay
    if (effects.colorOverlay.active) {
        effects.colorOverlay.duration -= deltaTime;
        effects.colorOverlay.intensity = Math.max(0, 
            effects.colorOverlay.intensity - effects.colorOverlay.fadeRate * deltaTime
        );
        
        if (effects.colorOverlay.duration <= 0 || effects.colorOverlay.intensity <= 0) {
            effects.colorOverlay.active = false;
        }
    }
    
    // Update slow motion distortion
    if (this.activePowers.slowmo > 0) {
        effects.slowMotion.active = true;
        effects.slowMotion.distortionIntensity = Math.min(1.0, 
            effects.slowMotion.distortionIntensity + deltaTime * 3
        );
        effects.slowMotion.chromaShift = Math.sin(Date.now() * 0.01) * 2;
        effects.slowMotion.vignette = 0.3;
    } else {
        effects.slowMotion.distortionIntensity = Math.max(0, 
            effects.slowMotion.distortionIntensity - deltaTime * 4
        );
        
        if (effects.slowMotion.distortionIntensity <= 0) {
            effects.slowMotion.active = false;
            effects.slowMotion.chromaShift = 0;
            effects.slowMotion.vignette = 0;
        }
    }
    
    // Update combo effects
    this.updateComboEffects(deltaTime);
}

/**
 * Update combo visual effects
 * @param {number} deltaTime - Time delta
 */
updateComboEffects(deltaTime) {
    const combo = this.screenEffects.comboEffects;
    
    // Check for combo streak
    if (Date.now() - combo.lastHitTime > 3000) {
        combo.streakCount = 0;
        combo.multiplier = 1;
    }
    
    // Update glow intensity
    if (combo.streakCount >= 3) {
        combo.glowIntensity = Math.min(1.0, combo.glowIntensity + deltaTime * 2);
    } else {
        combo.glowIntensity = Math.max(0, combo.glowIntensity - deltaTime * 1.5);
    }
}

    /**
     * Check for collisions
     */
   checkCollisions() {
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
        const proj = this.projectiles[i];
        
        if (this.isColliding(proj, this.aide)) {
            this.blockProjectile(proj);
            this.projectiles.splice(i, 1);
            this.projectilesBlocked++;
            
            const baseScore = 15 * this.level;
            const bonusScore = this.aide.shield ? baseScore * 2 : baseScore;
            this.score += bonusScore;
            this.debugLog('info', `Projectile blocked! Score +${bonusScore}`);
            continue;
        }
        
        // NEAR MISS DETECTION:
        const distToAide = Math.sqrt(
            Math.pow(proj.x - (this.aide.x + this.aide.width/2), 2) + 
            Math.pow(proj.y - (this.aide.y + this.aide.height/2), 2)
        );
        
        if (distToAide < 80 && !proj.nearMissTriggered) {
            proj.nearMissTriggered = true;
            if (Math.random() < 0.3) { // 30% chance for close call message
                this.showGameMessage('close');
            }
        }
    }
}

    /**
     * Check collision between two objects
     * @param {Object} obj1 - First object
     * @param {Object} obj2 - Second object
     * @returns {boolean} Collision detected
     */
    isColliding(obj1, obj2) {
        return obj1.x < obj2.x + obj2.width &&
               obj1.x + obj1.size > obj2.x &&
               obj1.y < obj2.y + obj2.height &&
               obj1.y + obj1.size > obj2.y;
    }

    /**
 * Handle projectile blocking
 * @param {Object} projectile - Projectile object
 */
blockProjectile(projectile) {
  if (this.audioManager) {
    // Immediate block sound with higher volume
    this.audioManager.play('block', { volume: 0.8 });
    
    // Delayed elimination sound with spatial audio (panning based on projectile position)
    setTimeout(() => {
        this.audioManager.play('block', {
            volume: 0.6,
            pan: (projectile.x / this.gameWidth - 0.5) * 2
        });
    }, 50);
}
    
    // Message system integration
    this.messageSystem.comboCount++;
    this.messageSystem.lastComboTime = Date.now();
    
    // Update aide confidence
    this.reactionSystem.aide.confidenceLevel = Math.min(100, this.reactionSystem.aide.confidenceLevel + 5);
    this.reactionSystem.aide.lastSuccessTime = Date.now();
    
    // Screen effects combo system
    const combo = this.screenEffects.comboEffects;
    combo.streakCount++;
    combo.lastHitTime = Date.now();
    
    if (combo.streakCount >= 3) {
        combo.multiplier = Math.min(5, 1 + (combo.streakCount - 2) * 0.5);
    }
    
    // Get properties for this projectile type
    const intensity = this.getProjectileIntensity(projectile.type);
    const colors = this.getProjectileEffectColors(projectile.type);
    
    // Screen effects based on projectile type and combo
    const isCombo = combo.streakCount >= 3;
    const isCritical = projectile.threatLevel === 'critical';
    
    // Screen shake
    if (isCritical) {
        this.triggerScreenShake(12, 0.4, 'critical');
    } else if (isCombo) {
        this.triggerScreenShake(8, 0.3, 'explosion');
    } else {
        this.triggerScreenShake(4 + intensity, 0.2, 'impact');
    }
    
    // Screen flash
    if (isCritical) {
        this.triggerScreenFlash('#FFD700', 0.4, 0.3);
    } else if (isCombo) {
        this.triggerScreenFlash('#00FFFF', 0.3, 0.2);
    } else if (intensity > 1.5) {
        this.triggerScreenFlash('#FFFFFF', 0.2, 0.15);
    }
    
    // Color overlay for special effects
    if (isCombo && combo.streakCount >= 5) {
        this.triggerColorOverlay('#FFD700', 0.15, 0.5);
    }
    
    // Show appropriate message
    if (this.messageSystem.comboCount >= 3) {
        this.showGameMessage('combo');
        this.messageSystem.comboCount = 0;

         //AUDIO Integration
        if (this.audioManager) {
            this.audioManager.play('combo', {
                volume: 0.8
            });
        }
        
        // Trigger victory pose for impressive blocks
        this.reactionSystem.aide.victoryPose = true;
        this.reactionSystem.aide.victoryTimer = 1500;
    } else if (Math.random() < 0.4) { // 40% chance for defense message
        this.showGameMessage('defense');
    }

    // Track successful block for analytics
    if (projectile.analyticsId) {
       const defenseMethod = this.aide.shield ? 'shield' : 'positioning';
       this.analytics.trackProjectileResolution(projectile.analyticsId, 'blocked', defenseMethod);
    }
    
    // MOBILE OPTIMIZED PARTICLE CREATION - Zero particles on mobile for maximum performance
    const particleCount = this.isMobile ? 0 : Math.floor((15 + Math.random() * 8) * intensity);
    
    console.log(`Creating ${particleCount} impact particles (mobile: ${this.isMobile})`);
    
    // Only create particles on desktop
    for (let i = 0; i < particleCount; i++) {
        const angle = (Math.PI * 2 / particleCount) * i + Math.random() * 0.5;
        const speed = 200 + Math.random() * 150;
        
        this.particles.push({
            x: projectile.x + (Math.random() - 0.5) * 5,
            y: projectile.y + (Math.random() - 0.5) * 5,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 50,
            life: 1.5 + Math.random() * 0.8,
            maxLife: 2.0,
            size: 4 + Math.random() * 8,
            color: colors.primary,
            type: 'impact',
            projectileType: projectile.type,
            alpha: 1.0,
            sparkle: Math.random() < 0.3,
            spin: projectile.type === 'stone' || projectile.type === 'bottle' ? (Math.random() - 0.5) * 0.4 : 0,
            rotation: 0
        });
    }
    
    // MOBILE: Skip sparkle particles entirely for performance
    if (!this.isMobile) {
        const sparkleCount = intensity > 1.5 ? 10 : 6;
        console.log(`Creating ${sparkleCount} sparkle particles (desktop only)`);
        for (let i = 0; i < sparkleCount; i++) {
            this.particles.push({
                x: projectile.x + (Math.random() - 0.5) * 20,
                y: projectile.y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 200,
                vy: -Math.random() * 150 - 50,
                life: 2.0,
                maxLife: 2.0,
                size: 2 + Math.random() * 4,
                color: colors.secondary,
                type: 'sparkle',
                alpha: 1.0,
                sparkle: true,
                twinkle: Math.random() < 0.7
            });
        }
    }
    
    // MOBILE: Skip debris particles for heavy projectiles
    if (!this.isMobile && (projectile.type === 'stone' || projectile.type === 'bottle' || projectile.type === 'shoe')) {
        console.log('Creating 4 debris particles (desktop only)');
        for (let i = 0; i < 4; i++) {
            this.particles.push({
                x: projectile.x,
                y: projectile.y,
                vx: (Math.random() - 0.5) * 180,
                vy: -Math.random() * 100 - 30,
                life: 2.5,
                maxLife: 2.5,
                size: 3 + Math.random() * 3,
                color: colors.debris,
                type: 'debris',
                alpha: 1.0,
                sparkle: false,
                spin: (Math.random() - 0.5) * 0.3,
                rotation: 0
            });
        }
    }

    // Check for achievements after successful block
    this.checkMinimalAchievements();
}

/**
 * Get projectile effect intensity
 * @param {string} type - Projectile type
 * @returns {number} Intensity multiplier
 */
getProjectileIntensity(type) {
    const intensityMap = {
        tomato: 1.5,
        egg: 1.2,
        shoe: 1.8,
        bottle: 2.0,
        stone: 2.2,
        banana: 0.8,
        apple: 1.3
    };
    return intensityMap[type] || 1.0;
}

/**
 * Get projectile effect colors
 * @param {string} type - Projectile type
 * @returns {Object} Color scheme
 */
getProjectileEffectColors(type) {
    const colorSchemes = {
        tomato: { primary: '#FF4757', secondary: '#FFD700', debris: '#8B0000' },
        egg: { primary: '#FFF8DC', secondary: '#FFD700', debris: '#F5DEB3' },
        shoe: { primary: '#8B4513', secondary: '#CD853F', debris: '#2F1B14' },
        bottle: { primary: '#228B22', secondary: '#90EE90', debris: '#006400' },
        stone: { primary: '#696969', secondary: '#A9A9A9', debris: '#2F2F2F' },
        banana: { primary: '#FFD700', secondary: '#FFED4E', debris: '#DAA520' },
        apple: { primary: '#DC143C', secondary: '#FFB6C1', debris: '#8B0000' }
    };
    return colorSchemes[type] || { primary: '#FF6B6B', secondary: '#FFD700', debris: '#666' };
}

/**
 * Create enhanced impact burst effect
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {Object} projectile - Projectile object
 */
createEnhancedImpactBurst(x, y, projectile) {
    const intensity = this.getProjectileIntensity(projectile.type);
    const colors = this.getProjectileEffectColors(projectile.type);
    
    // Main explosion particles
    for (let i = 0; i < 15 * intensity; i++) {
        const angle = (Math.PI * 2 / 15) * i + Math.random() * 0.5;
        const speed = 150 + Math.random() * 200;
        
        this.particles.push({
            x: x + (Math.random() - 0.5) * 10,
            y: y + (Math.random() - 0.5) * 10,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 30,
            life: 1.5 + Math.random() * 0.8,
            maxLife: 2.0,
            size: 4 + Math.random() * 6,
            color: colors.primary,
            type: 'explosion',
            projectileType: projectile.type,
            alpha: 1.0,
            sparkle: false,
            spin: (Math.random() - 0.5) * 0.4,
            rotation: 0
        });
    }
    
    // Secondary sparkle burst for high-impact projectiles
    if (intensity > 1.2) {
        for (let i = 0; i < 8; i++) {
            this.particles.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 300,
                vy: -Math.random() * 200 - 50,
                life: 2.0,
                maxLife: 2.0,
                size: 2 + Math.random() * 4,
                color: colors.secondary,
                type: 'sparkle',
                alpha: 1.0,
                sparkle: true,
                twinkle: Math.random() < 0.7
            });
        }
    }
    
    // Debris particles for solid projectiles
    if (projectile.type === 'stone' || projectile.type === 'bottle') {
        for (let i = 0; i < 5; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 200,
                vy: -Math.random() * 100 - 50,
                life: 3.0,
                maxLife: 3.0,
                size: 3 + Math.random() * 4,
                color: colors.debris,
                type: 'debris',
                alpha: 1.0,
                sparkle: false
            });
        }
    }
}

/**
 * Get projectile effect intensity
 * @param {string} type - Projectile type
 * @returns {number} Intensity multiplier
 */
getProjectileIntensity(type) {
    const intensityMap = {
        tomato: 1.5,
        egg: 1.2,
        shoe: 1.8,
        bottle: 2.0,
        stone: 2.2,
        banana: 0.8,
        apple: 1.3
    };
    return intensityMap[type] || 1.0;
}

/**
 * Get projectile effect colors
 * @param {string} type - Projectile type
 * @returns {Object} Color scheme
 */
getProjectileEffectColors(type) {
    const colorSchemes = {
        tomato: { primary: '#FF4757', secondary: '#FFD700', debris: '#8B0000' },
        egg: { primary: '#FFF8DC', secondary: '#FFD700', debris: '#DDD' },
        shoe: { primary: '#8B4513', secondary: '#654321', debris: '#2F1B14' },
        bottle: { primary: '#228B22', secondary: '#90EE90', debris: '#006400' },
        stone: { primary: '#696969', secondary: '#A9A9A9', debris: '#2F2F2F' },
        banana: { primary: '#FFD700', secondary: '#FFED4E', debris: '#DAA520' },
        apple: { primary: '#DC143C', secondary: '#FFB6C1', debris: '#8B0000' }
    };
    return colorSchemes[type] || { primary: '#FF6B6B', secondary: '#FFD700', debris: '#666' };
}

  /**
 * Handle politician hit
 * @param {Object} projectile - Projectile object
 */
hitPolitician(projectile) {
    this.politicianHealth -= projectile.damage;
    
     //Play politician hit sound
    if (this.audioManager) {
        // FIND the commented audio calls and replace with:
        if (this.audioManager) {
        this.audioManager.play('hit', { volume: 0.9 });
        }
        
         //Danger sound for high damage hits
        if (projectile.damage >= 25) {
            setTimeout(() => {
                this.audioManager.play('danger', {
                    volume: 0.7
                });
        }, 100);
        }
    }
    
    // Play critical health warning
if (this.politicianHealth <= 25 && this.politicianHealth > 0) {
    if (this.audioManager) {
        this.audioManager.play('hit', {
            volume: 0.8
        });
    }
}
    
    // Track politician hit for analytics
    if (projectile.analyticsId) {
        this.analytics.trackProjectileResolution(projectile.analyticsId, 'hit_politician');
        this.analytics.trackHealthEvent('damage_taken', projectile.damage, projectile.type);
    }
    
    // Screen effects based on damage and health
    const damageIntensity = projectile.damage / 50; // Normalize damage
    const healthCritical = this.politicianHealth < 30;
    
    // Screen shake based on projectile type with damage multiplier
    const shakeIntensity = this.getShakeIntensity(projectile.type) * (1 + damageIntensity);
    this.triggerScreenShake(shakeIntensity, 0.6, 'impact');
    
    // Color overlay based on damage and health
    // if (healthCritical) {
      //  this.triggerColorOverlay('#FF0000', 0.3, 1.5);
    // } else if (projectile.damage >= 25) {
      //  this.triggerColorOverlay('#FF6B6B', 0.2, 1.0);
    // }
    
    // Screen flash for high damage hits
    // if (projectile.damage >= 20) {
     //   this.triggerScreenFlash('#FF4757', 0.25, 0.3);
    // }
    
    // Screen shake (legacy support)
    this.cameraShake.intensity = this.getShakeIntensity(projectile.type);
    
    // Set projectile-specific reaction
    this.setReactionForProjectile(projectile.type);

    // Message bubble
    const randomMessage = this.hinglishMessages[Math.floor(Math.random() * this.hinglishMessages.length)];
    this.politician.messageBubble.text = randomMessage;
    this.politician.messageBubble.timer = 3000; // 3 seconds
    this.politician.messageBubble.isVisible = true;
    this.politician.messageBubble.fadeIn = 0;

    this.addStainToPolitician(projectile);
    
    // Create enhanced splatter particles
    for (let i = 0; i < 15; i++) {
        this.particles.push({
            x: this.politician.hitbox.x + this.politician.hitbox.width/2,
            y: this.politician.hitbox.y + this.politician.hitbox.height/2,
            vx: (Math.random() - 0.5) * 200,
            vy: -Math.random() * 150,
            life: 3.0,
            size: 6 + Math.random() * 10,
            color: projectile.color
        });
    }
    
    console.log(`Politician hit by ${projectile.type}, health: ${this.politicianHealth}`);
    
   // CRITICAL FIX: Game Over Handling - Prevent Brown Overlay
if (this.politicianHealth <= 0) {
    console.log('ðŸŽ¯ GAME OVER - Implementing immediate results approach');
    
    // IMMEDIATE STATE CHANGE - This is crucial
    this.currentState = this.gameStates.GAME_OVER;
    
    // STOP GAME LOOP IMMEDIATELY to prevent further rendering
    this.stopGameLoop();
    
    // AGGRESSIVE CANVAS CLEANUP - Fill with sky blue to block brown
    this.ctx.fillStyle = '#87CEEB'; // Sky blue background
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // HIDE CANVAS IMMEDIATELY 
    this.canvas.style.display = 'none';
    this.canvas.style.visibility = 'hidden';
    this.canvas.style.background = '#87CEEB'; // Force sky blue
    
    // CLEAR ALL GAME OBJECTS immediately
    this.projectiles = [];
    this.particles = [];
    this.trailParticles = [];
    
    // CLEAR SCREEN EFFECTS that might cause overlay
    if (this.screenEffects) {
        this.screenEffects.flash.active = false;
        this.screenEffects.flash.intensity = 0;
        this.screenEffects.colorOverlay.active = false;
        this.screenEffects.colorOverlay.intensity = 0;
        this.screenEffects.slowMotion.active = false;
        this.screenEffects.slowMotion.vignette = 0;
    }
    
    // CLEAR MESSAGE SYSTEM
    this.hideGameMessage();
    this.messageSystem.isActive = false;
    this.messageSystem.messageTimer = 0;
    
    // STOP ALL AUDIO
    if (this.audioManager) {
        this.audioManager.stopAllSounds();
    }
    
    // IMMEDIATE RESULTS - No delay at all
    console.log('ðŸŽ¯ Showing results immediately - bypassing cleanup delay');
    this.showResults();
}
}
    /**
     * Advance to next wave
     */
    nextWave() {
        this.wave++;
        this.waveTimer = 0;
        this.survivedWaves++;
        
        if (this.wave > 4) {
            this.level++;
            this.wave = 1;
            this.politicianHealth = Math.min(this.maxHealth, this.politicianHealth + 25);
        }
        
        this.score += 200 * this.level;
        this.showGameMessage('wave');
    }

   /**
 * Update UI elements
 */
updateUI() {
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const waveEl = document.getElementById('wave');
    const healthFillEl = document.getElementById('healthFill');
    
    if (scoreEl) scoreEl.textContent = this.score.toLocaleString();
    if (levelEl) levelEl.textContent = this.level;
    if (waveEl) waveEl.textContent = this.wave;
    
    if (healthFillEl) {
        const healthPercent = Math.max(0, (this.politicianHealth / this.maxHealth) * 100);
        healthFillEl.style.width = healthPercent + '%';
    }
    
    // Health styling update
    this.updateHealthBarStyling();
}

/**
 * Check and display achievements
 */
checkMinimalAchievements() {
    if (!this.analytics) return;
    
    const streak = this.analytics.streakAnalytics.currentStreak;
    const total = this.projectilesBlocked + this.projectilesMissed;
    const accuracy = total > 0 ? Math.round((this.projectilesBlocked / total) * 100) : 100;
    
    // Streak achievements - show every 5th streak
    if (streak > 0 && streak % 5 === 0) {
        if (streak >= 20) {
            this.showGameMessage('combo', `LEGENDARY ${streak} Streak! Master Defender!`);
        } else if (streak >= 15) {
            this.showGameMessage('combo', `EPIC ${streak} Streak! Unstoppable!`);
        } else if (streak >= 10) {
            this.showGameMessage('combo', `AMAZING ${streak} Streak! On fire!`);
        } else if (streak >= 5) {
            this.showGameMessage('combo', `Great ${streak} Streak! Keep going!`);
        }
        this.triggerScoreBoost();
    }
    
    // Perfect accuracy achievement
    if (accuracy === 100 && this.projectilesBlocked >= 10) {
        this.showGameMessage('defense', 'PERFECT ACCURACY! Hot defense!');
        this.triggerAccuracyPerfect();
    }
    
    // Quick reaction achievement
    const lastReaction = this.analytics.reactionTimeData[this.analytics.reactionTimeData.length - 1];
    if (lastReaction && lastReaction.time < 400) {
        this.showGameMessage('defense', 'Lightning Reflexes! Ultra-fast!');
        this.triggerScoreBoost();
    }
}

/**
 * Trigger score boost animation
 */
triggerScoreBoost() {
    const scoreEl = document.getElementById('score');
    if (scoreEl) {
        scoreEl.classList.remove('score-boost'); // Reset if already active
        setTimeout(() => {
            scoreEl.classList.add('score-boost');
        }, 10);
        
        setTimeout(() => {
            scoreEl.classList.remove('score-boost');
        }, 800);
    }
}

/**
 * Trigger accuracy perfect animation
 */
triggerAccuracyPerfect() {
    const scoreEl = document.getElementById('score');
    if (scoreEl) {
        scoreEl.classList.remove('accuracy-perfect');
        setTimeout(() => {
            scoreEl.classList.add('accuracy-perfect');
        }, 10);
        
        setTimeout(() => {
            scoreEl.classList.remove('accuracy-perfect');
        }, 1200);
    }
}

/**
 * Show contextual message
 * @param {string} type - Message type
 * @param {string} customMessage - Custom message (optional)
 */
showGameMessage(type, customMessage = null) {
    const messageEl = document.getElementById('messageText');
    const messageBox = document.getElementById('gameMessage');

    // ADD ONLY THIS LINE:
    if (this.currentState !== this.gameStates.GAMEPLAY || !messageEl || !messageBox) return;
    
    if (!messageEl || !messageBox) return;
    
    // Don't show same message type consecutively
    if (type === this.messageSystem.lastMessageType && !customMessage) {
        return;
    }
    
    let message;
    if (customMessage) {
        message = customMessage;
    } else {
        const messages = this.messageSystem.messages[type] || this.messageSystem.messages.defense;
        message = messages[Math.floor(Math.random() * messages.length)];
    }
    
    // ADD DYNAMIC POSITIONING:
    const isMobile = window.innerWidth < 768;
    const topPosition = isMobile ? '140px' : '120px';
    messageBox.style.top = topPosition;
    
    // Clear any existing message
    this.hideGameMessage();
    
    // Set new message
    messageEl.textContent = message;
    this.messageSystem.currentMessage = message;
    this.messageSystem.isActive = true;
    this.messageSystem.messageTimer = this.messageSystem.messageDuration;
    this.messageSystem.lastMessageType = type;
    
    // Show with animation
    setTimeout(() => {
        messageBox.classList.add('show');
    }, 50);
    
    // Auto-hide after duration
    setTimeout(() => {
        this.hideGameMessage();
    }, this.messageSystem.messageDuration);
    
    console.log(`Message shown: "${message}" (${type})`);
}

/**
 * Hide current message
 */
hideGameMessage() {
    const messageBox = document.getElementById('gameMessage');
    if (!messageBox) return;
    
    messageBox.classList.remove('show');
    messageBox.classList.add('fade-out');
    
    setTimeout(() => {
        messageBox.classList.remove('fade-out');
        this.messageSystem.isActive = false;
        this.messageSystem.currentMessage = '';
    }, 500);
}

/**
 * Update message system
 * @param {number} deltaTime - Time delta
 */
updateMessageSystem(deltaTime) {
    if (this.messageSystem.isActive && this.messageSystem.messageTimer > 0) {
        this.messageSystem.messageTimer -= deltaTime * 1000;
    }
    
    // Update combo tracking
    if (Date.now() - this.messageSystem.lastComboTime > 3000) {
        this.messageSystem.comboCount = 0;
    }
}

/**
 * Update reaction system
 * @param {number} deltaTime - Time delta
 */
updateReactionSystem(deltaTime) {
    const reactions = this.reactionSystem;
    
    // Update aide victory timer
    if (reactions.aide.victoryTimer > 0) {
        reactions.aide.victoryTimer -= deltaTime * 1000;
        if (reactions.aide.victoryTimer <= 0) {
            reactions.aide.victoryPose = false;
        }
    }
    
    // Update politician stress over time
    if (this.politicianHealth > 50) {
        reactions.politician.stressLevel = Math.max(0, 
            reactions.politician.stressLevel - deltaTime * 10
        );
    }
}


/**
 * Main render function
 */
render() {
    if (this.currentState !== this.gameStates.GAMEPLAY) {
        this.canvas.style.display = 'none';
        return;
    }
    
    const isDesktop = this.gameWidth >= 768;
    const now = performance.now();
    if (this.lastMobileRender && now - this.lastMobileRender < 50) return;
    this.lastMobileRender = now;
    
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    let useFullFallback = false;
    
    try {
        this.drawEnhancedSky();
        this.drawSimpleBuildings();
        this.drawEnhancedGround();
        this.drawResponsivePolitician();
        this.drawEnhancedStage();
        this.drawSimpleCrowd();
        this.drawResponsiveAide();
        this.drawResponsiveProjectiles();
        this.drawSimpleParticles();
        
    } catch (error) {
        console.warn('Render error:', error);
        useFullFallback = true;
    }
    
    // Only use fallback if sprites completely failed
    if (useFullFallback) {
        console.log('Complete rendering failure - using full fallback');
        this.drawFallbackGameElements();
    }
}
drawResponsiveAide() {
    const a = this.aide;
    const isDesktop = this.gameWidth >= 768;
    
    // FIXED: Better desktop scaling with aspect ratio control
    const baseScale = Math.min(this.gameWidth / 1400, 1.2); // Cap max scale
    const scale = isDesktop ? baseScale : 1.0;
    
    // Mobile positioning as baseline
    const mobileOffsetX = 0;
    const mobileOffsetY = 100;
    
    // FIXED: Account for sprite scale in positioning
    const aideConfig = this.spriteConfigs.aide;
    const spriteScale = isDesktop ? (aideConfig.scale || 1.0) : (aideConfig.scale || 0.9);
    const scaleAdjustment = isDesktop ? (spriteScale - 1.0) * 80 : 0; // Adjust upward for larger sprites
    
    const offsetX = isDesktop ? mobileOffsetX : mobileOffsetX;
    const offsetY = isDesktop ? mobileOffsetY - 20 - scaleAdjustment : mobileOffsetY;
    
    const spriteDrawn = this.drawCharacterSprite(
        'aide',
        a.x + offsetX,
        a.y + (a.bounceY || 0) + offsetY,
        100 * scale,
        100 * scale, // Maintains aspect ratio
        'idle'
    );
    
    if (!spriteDrawn) {
        this.drawDetailedAideFallback();
    }
    
    if (a.shield) {
        this.drawShieldEffect(a);
    }
}

drawResponsivePolitician() {
    const p = this.politician;
    const isDesktop = this.gameWidth >= 768;
    
    // FIXED: Better desktop scaling with aspect ratio control
    const baseScale = Math.min(this.gameWidth / 1400, 1.2);
    const scale = isDesktop ? baseScale : 1.0;
    
    // FIXED: Different offsets for mobile vs desktop
    const offsetX = isDesktop ? -22 : -3;  // Move politician further left on desktop
    const mobileOffsetY = 125;
    
    // FIXED: Proportional desktop positioning
    const offsetY = isDesktop ? mobileOffsetY - 25 : mobileOffsetY;
    
    const spriteDrawn = this.drawCharacterSprite(
        'politician',
        p.x + offsetX,  // Use the dynamic offsetX instead of mobileOffsetX
        p.y + offsetY,
        133 * scale,
        164 * scale,
        'idle'
    );
    
    if (!spriteDrawn) {
        this.drawDetailedPoliticianFallback();
    }
    
    if (p.stains && p.stains.length > 0) {
        this.drawPoliticianStains(p);
    }
    
    if (p.messageBubble && p.messageBubble.isVisible) {
        this.drawMessageBubble(p);
    }
}

drawResponsiveProjectiles() {
    if (!this.projectiles || this.projectiles.length === 0) return;
    
    const isDesktop = this.gameWidth >= 768;
    const scale = isDesktop ? 1.1 : 1.0;
    
    this.projectiles.forEach(proj => {
        this.ctx.save();
        
        // FIXED: Draw glassmorphic background first
        this.ctx.shadowColor = proj.color;
        this.ctx.shadowBlur = 15 * scale;
        
        const gradient = this.ctx.createRadialGradient(
            proj.x - proj.size/4, proj.y - proj.size/4, 0,
            proj.x, proj.y, proj.size/2 * scale
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.7)');
        gradient.addColorStop(0.7, proj.glassTint + '40');
        gradient.addColorStop(1, proj.color + '20');
        
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(proj.x, proj.y, Math.max(proj.size/2 * scale, 8), 0, Math.PI * 2);
        this.ctx.fill();
        
        // Glass border effect
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        
        // FIXED: Reset shadow and draw emoji ON TOP
        this.ctx.shadowBlur = 0;
        this.ctx.translate(proj.x, proj.y);
        this.drawEmojiProjectile(proj, proj.size);
        this.ctx.translate(-proj.x, -proj.y);
        
        // Draw priority rings for all projectiles
        this.drawProjectilePriorityRings(proj);

       // Threat indicator for desktop
        if (isDesktop) {
        this.drawThreatIndicator(proj);
}
        
        this.ctx.restore();
    });
}

/**
 * Mobile politician using original sprite system
 */
drawMobilePolitician() {
    const p = this.politician;
    
    // MOBILE-SPECIFIC POSITIONING ADJUSTMENTS
    const mobileOffsetX = -3;  // Move center behind podium
    const mobileOffsetY = 125;  // Move DOWN to stage level
    
    // Try to use sprite system first with mobile positioning and sizing
    const spriteDrawn = this.drawCharacterSprite(
        'politician',
        p.x + mobileOffsetX,        // ADD mobile X offset for proper positioning
        p.y + mobileOffsetY,        // ADD mobile Y offset for stage level
        135,                        // INCREASED width for bigger size on mobile
        160,                        // INCREASED height for bigger size on mobile
        'idle'                      // Use simple animation for mobile performance
    );
    
    // If sprite system fails, use detailed fallback with mobile positioning
    if (!spriteDrawn) {
        // Apply mobile offsets to fallback as well
        const originalX = p.x;
        const originalY = p.y;
        
        // Temporarily adjust position for fallback
        p.x += mobileOffsetX;
        p.y += mobileOffsetY;
        
        this.drawDetailedPoliticianFallback();
        
        // Restore original position
        p.x = originalX;
        p.y = originalY;
    }
    
    // Always draw stains with mobile positioning adjustments
    if (p.stains && p.stains.length > 0) {
        // Apply mobile offsets to stains as well
        const originalX = p.x;
        const originalY = p.y;
        
        // Temporarily adjust position for stains
        p.x += mobileOffsetX;
        p.y += mobileOffsetY;
        
        this.drawPoliticianStains(p);
        
        // Restore original position
        p.x = originalX;
        p.y = originalY;
    }
}

/**
 * Mobile aide using original sprite system  
 */
drawMobileAide() {
    const a = this.aide;
    
    // MOBILE-SPECIFIC POSITIONING ADJUSTMENTS  
    const mobileOffsetX = 0;   // No horizontal adjustment needed
    const mobileOffsetY = 107;  // Move DOWN to stage level
    
    // Try to use sprite system first with mobile positioning
    const spriteDrawn = this.drawCharacterSprite(
        'aide',
        a.x + mobileOffsetX,                    // ADD mobile X offset (0 in this case)
        a.y + (a.bounceY || 0) + mobileOffsetY, // ADD mobile Y offset with bounce animation
        90,                                    // Keep existing width for aide
        120,                                    // Keep existing height for aide
        'idle'                                  // Use simple animation for mobile performance
    );
    
    // If sprite system fails, use detailed fallback with mobile positioning
    if (!spriteDrawn) {
        // Apply mobile offsets to fallback as well
        const originalX = a.x;
        const originalY = a.y;
        
        // Temporarily adjust position for fallback (including bounce)
        a.x += mobileOffsetX;
        a.y += mobileOffsetY; // Note: bounceY is handled in the fallback method itself
        
        this.drawDetailedAideFallback();
        
        // Restore original position
        a.x = originalX;
        a.y = originalY;
    }
    
    // Always draw shield with mobile positioning adjustments
    if (a.shield) {
        // Apply mobile offsets to shield effect as well
        const originalX = a.x;
        const originalY = a.y;
        
        // Temporarily adjust position for shield (including bounce)
        a.x += mobileOffsetX;
        a.y += mobileOffsetY; // Note: bounceY should be handled in drawShieldEffect
        
        this.drawShieldEffect(a);
        
        // Restore original position
        a.x = originalX;
        a.y = originalY;
    }
}

/**
 * Enhanced mobile projectiles with type indicators
 */
//drawMobileProjectiles() {
   // if (!this.projectiles || this.projectiles.length === 0) return;
   // 
    //this.projectiles.forEach(proj => {
       // this.ctx.save();
        
        // Enhanced projectile with subtle glow
       // this.ctx.shadowColor = proj.color;
        //this.ctx.shadowBlur = 6;
        
        // Main projectile body with gradient
        //const gradient = this.ctx.createRadialGradient(
        //    proj.x - proj.size/4, proj.y - proj.size/4, 0,
          //  proj.x, proj.y, proj.size/2
       // );
        //gradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
      //  gradient.addColorStop(0.7, proj.color);
       // gradient.addColorStop(1, proj.color + '80');
        
       // this.ctx.fillStyle = gradient;
       // this.ctx.beginPath();
       // this.ctx.arc(proj.x, proj.y, Math.max(proj.size/2, 8), 0, Math.PI * 2);
       // this.ctx.fill();
        
        // Enhanced type-specific details for better recognition
       // this.drawEmojiProjectile(proj, Math.max(proj.size/2, 8));
        
        // Simple threat level indicator
       // this.drawThreatIndicator(proj);
        
       // this.ctx.restore();
   // });
// }

/**
 * Draw threat indicator - adds to your existing threat system
 */
drawThreatIndicator(proj) {
    if (proj.threatLevel === 'critical' || proj.threatLevel === 'high') {
        const time = Date.now() * 0.01;
        const pulse = Math.sin(time) * 0.3 + 0.7;
        
        this.ctx.strokeStyle = proj.threatLevel === 'critical' ? '#FF0000' : '#FF6347';
        this.ctx.lineWidth = 2;
        this.ctx.globalAlpha = pulse * 0.6;
        
        this.ctx.beginPath();
        this.ctx.arc(proj.x, proj.y, proj.size/2 + 8, 0, Math.PI * 2);
        this.ctx.stroke();
        
        this.ctx.globalAlpha = 1;
    }
}
/**
 * Update your existing mobileRender() method - just add the simple particle call
 */
drawSimpleParticles() {
    // Only draw a few particles for impact effects
    const maxMobileParticles = 5;
    const recentParticles = this.particles.slice(-maxMobileParticles);
    
    recentParticles.forEach(particle => {
        if (particle.life <= 0) return;
        
        this.ctx.save();
        this.ctx.globalAlpha = particle.alpha || (particle.life / 2.0);
        this.ctx.fillStyle = particle.color;
        
        this.ctx.beginPath();
        this.ctx.arc(particle.x, particle.y, Math.max(particle.size * 0.5, 1), 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.restore();
    });
}
/**
 * Enhanced mobile render with simple background elements
 */
mobileRender() {
    console.log("ðŸ“± mobileRender() called");
    if (this.currentState !== this.gameStates.GAMEPLAY) {
        this.canvas.style.display = 'none';
        return;
    }
    
    const now = performance.now();
    if (this.lastMobileRender && now - this.lastMobileRender < 50) return;
    this.lastMobileRender = now;
    
    // Clear canvas
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    try {
        // ENHANCED BACKGROUND ELEMENTS
        this.drawEnhancedSky();
        this.drawSimpleBuildings();
        this.drawEnhancedGround();
        
        // DRAW POLITICIAN FIRST (so he appears behind podium)
        this.drawMobilePolitician();
        
        // THEN DRAW STAGE (podium will render in front of politician)
        this.drawEnhancedStage();
        
        // THEN OTHER FOREGROUND ELEMENTS
        this.drawSimpleCrowd();
        this.drawMobileAide();
        this.drawResponsiveProjectiles();
        this.drawSimpleParticles();
        
    } catch (error) {
        console.warn('Enhanced mobile render error:', error);
        this.drawFallbackGameElements();
    }
}
/**
 * Better politician fallback (looks more like original)
 */
drawDetailedPoliticianFallback() {
    const p = this.politician;
    
    // Body (suit jacket)
    this.ctx.fillStyle = '#1A1A1A'; // Dark suit
    this.ctx.fillRect(p.x, p.y + 30, 75, 70);
    
    // White shirt area (important for stain visibility)
    this.ctx.fillStyle = '#FFFFFF';
    this.ctx.fillRect(p.x + 20, p.y + 35, 35, 50);
    
    // Tie
    this.ctx.fillStyle = '#CC0000';
    this.ctx.fillRect(p.x + 35, p.y + 40, 5, 30);
    
    // Head (skin tone)
    this.ctx.fillStyle = '#DEB887';
    this.ctx.beginPath();
    this.ctx.arc(p.x + 37, p.y + 20, 18, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Hair
    this.ctx.fillStyle = '#8B4513';
    this.ctx.beginPath();
    this.ctx.arc(p.x + 37, p.y + 8, 20, 0, Math.PI);
    this.ctx.fill();
    
    // Eyes
    this.ctx.fillStyle = '#000';
    this.ctx.beginPath();
    this.ctx.arc(p.x + 32, p.y + 18, 2, 0, Math.PI * 2);
    this.ctx.arc(p.x + 42, p.y + 18, 2, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Mouth
    this.ctx.strokeStyle = '#000';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.arc(p.x + 37, p.y + 25, 5, 0, Math.PI);
    this.ctx.stroke();
    
    // Arms
    this.ctx.fillStyle = '#1A1A1A';
    this.ctx.fillRect(p.x - 8, p.y + 35, 12, 40);
    this.ctx.fillRect(p.x + 71, p.y + 35, 12, 40);
    
    // Hands
    this.ctx.fillStyle = '#DEB887';
    this.ctx.beginPath();
    this.ctx.arc(p.x - 2, p.y + 75, 6, 0, Math.PI * 2);
    this.ctx.arc(p.x + 77, p.y + 75, 6, 0, Math.PI * 2);
    this.ctx.fill();
}

/**
 * Better aide fallback (looks more like original)
 */
drawDetailedAideFallback() {
    const a = this.aide;
    const y = a.y + (a.bounceY || 0);
    
    // Body (uniform/shirt) - color changes based on shield state
    this.ctx.fillStyle = a.shield ? '#87CEEB' : '#4169E1';
    this.ctx.fillRect(a.x, y + 25, 60, 55);
    
    // Head (skin tone)
    this.ctx.fillStyle = '#DEB887';
    this.ctx.beginPath();
    this.ctx.arc(a.x + 30, y + 15, 15, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Hair
    this.ctx.fillStyle = '#2F4F4F';
    this.ctx.beginPath();
    this.ctx.arc(a.x + 30, y + 5, 17, 0, Math.PI);
    this.ctx.fill();
    
    // Eyes (alert expression)
    this.ctx.fillStyle = '#000';
    this.ctx.beginPath();
    this.ctx.arc(a.x + 25, y + 13, 2, 0, Math.PI * 2);
    this.ctx.arc(a.x + 35, y + 13, 2, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Mouth (determined expression)
    this.ctx.strokeStyle = '#000';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.moveTo(a.x + 27, y + 20);
    this.ctx.lineTo(a.x + 33, y + 20);
    this.ctx.stroke();
    
    // Arms (positioned for defense)
    this.ctx.fillStyle = '#DEB887';
    this.ctx.fillRect(a.x - 5, y + 30, 10, 30);
    this.ctx.fillRect(a.x + 55, y + 30, 10, 30);
    
    // Hands (fists ready for action)
    this.ctx.fillStyle = '#DEB887';
    this.ctx.beginPath();
    this.ctx.arc(a.x + 0, y + 60, 5, 0, Math.PI * 2);
    this.ctx.arc(a.x + 60, y + 60, 5, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Special shield-state indicator
    if (a.shield) {
        // Add energy lines around the aide
        this.ctx.strokeStyle = '#00FFFF';
        this.ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const startX = a.x + 30 + Math.cos(angle) * 25;
            const startY = y + 40 + Math.sin(angle) * 25;
            const endX = a.x + 30 + Math.cos(angle) * 35;
            const endY = y + 40 + Math.sin(angle) * 35;
            
            this.ctx.beginPath();
            this.ctx.moveTo(startX, startY);
            this.ctx.lineTo(endX, endY);
            this.ctx.stroke();
        }
    }
}

/**
 * Fallback drawing method if other methods fail
 */
drawFallbackGameElements() {
    // Ultra-simple fallback - just colored rectangles
    
    // Politician
    this.ctx.fillStyle = '#9370DB';
    this.ctx.fillRect(this.politician.x, this.politician.y, 75, 100);
    
    // Aide
    //this.ctx.fillStyle = '#4169E1';
    //this.ctx.fillRect(this.aide.x, this.aide.y, 60, 80);
    
    // Projectiles
    this.ctx.fillStyle = '#FF0000';
    this.projectiles.forEach(proj => {
        this.ctx.fillRect(proj.x - 10, proj.y - 10, 20, 20);
    });
}

/**
 * Draw enhanced sky with subtle cloud animations
 */
drawEnhancedSky() {
    const groundY = this.gameHeight * 0.80;
    
    // Dynamic sky gradient based on game intensity
    const intensity = Math.min(this.projectiles.length / 5, 0.3);
    const skyGradient = this.ctx.createLinearGradient(0, 0, 0, groundY);
    
    // Sky color shifts slightly based on danger level
    const hue1 = 200 + intensity * 20; // Blue to more intense
    const hue2 = 210 + intensity * 15;
    
    skyGradient.addColorStop(0, `hsl(${hue1}, 60%, 80%)`);
    skyGradient.addColorStop(0.7, `hsl(${hue2}, 50%, 75%)`);
    skyGradient.addColorStop(1, '#DEB887');
    
    this.ctx.fillStyle = skyGradient;
    this.ctx.fillRect(0, 0, this.gameWidth, groundY);
    
    // Add simple moving clouds
    this.drawSimpleClouds();
}


/**
 * Draw simple animated clouds for mobile and desktop
 */
drawSimpleClouds() {
    const isDesktop = this.gameWidth >= 768;
    
    // Desktop gets more clouds, mobile gets fewer for performance
    const clouds = isDesktop ? [
        { baseX: this.gameWidth * 0.15, y: this.gameHeight * 0.12, size: 60 },
        { baseX: this.gameWidth * 0.4, y: this.gameHeight * 0.08, size: 70 },
        { baseX: this.gameWidth * 0.65, y: this.gameHeight * 0.15, size: 55 },
        { baseX: this.gameWidth * 0.85, y: this.gameHeight * 0.1, size: 65 }
    ] : [
        { baseX: this.gameWidth * 0.2, y: this.gameHeight * 0.15, size: 40 },
        { baseX: this.gameWidth * 0.7, y: this.gameHeight * 0.12, size: 50 }
    ];
    
    const time = Date.now() * 0.0005;
    
    clouds.forEach((cloud, index) => {
        const moveX = (cloud.baseX + time * 150 + index * 100) % (this.gameWidth + 100) - 50;
        this.drawSimpleCloud(moveX, cloud.y, cloud.size);
    });
}

/**
 * Draw a simple cloud shape
 */
drawSimpleCloud(x, y, size) {
    this.ctx.save();
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.05)';
    this.ctx.shadowBlur = 5;
    
    // Simple 3-circle cloud
    this.ctx.beginPath();
    this.ctx.arc(x - size * 0.3, y, size * 0.4, 0, Math.PI * 2);
    this.ctx.arc(x, y - size * 0.2, size * 0.5, 0, Math.PI * 2);
    this.ctx.arc(x + size * 0.3, y, size * 0.4, 0, Math.PI * 2);
    this.ctx.fill();
    
    this.ctx.restore();
}

/**
 * Draw simple background buildings with Indian village huts
 */
/**
 * Draw simple background buildings with Indian village huts
 */
drawSimpleBuildings() {
    const buildingGroundY = this.gameHeight * 0.77; // Higher ground line just for buildings
    const isDesktop = this.gameWidth >= 768;

    // Base structures (always rendered)
    let structures = [
        // Traditional huts
        { x: this.gameWidth * 0.05, width: 50, height: 60, type: 'hut', color: '#8B4513' },
        { x: this.gameWidth * 0.15, width: 55, height: 55, type: 'hut', color: '#A0522D' },
        
        // Modern buildings  
        { x: this.gameWidth * 0.25, width: 70, height: 80, type: 'building', color: '#CD853F' },
        { x: this.gameWidth * 0.75, width: 65, height: 95, type: 'building', color: '#F4A460' },
        
        // More traditional huts
        { x: this.gameWidth * 0.85, width: 48, height: 58, type: 'hut', color: '#8B4513' }
    ];

    // Desktop enhancement: Add more structures for density
    if (isDesktop) {
        const additionalStructures = [
            // Background layer - smaller, distant buildings
            { x: this.gameWidth * 0.02, width: 35, height: 45, type: 'hut', color: '#8B7355' },
            { x: this.gameWidth * 0.12, width: 40, height: 50, type: 'building', color: '#DEB887' },
            { x: this.gameWidth * 0.32, width: 45, height: 65, type: 'hut', color: '#A0522D' },
            { x: this.gameWidth * 0.45, width: 60, height: 85, type: 'building', color: '#D2B48C' },
            { x: this.gameWidth * 0.58, width: 42, height: 52, type: 'hut', color: '#8B4513' },
            { x: this.gameWidth * 0.68, width: 55, height: 75, type: 'building', color: '#CD853F' },
            { x: this.gameWidth * 0.82, width: 38, height: 48, type: 'hut', color: '#A0522D' },
            { x: this.gameWidth * 0.92, width: 50, height: 70, type: 'building', color: '#F4A460' }
        ];
        structures = structures.concat(additionalStructures);
    }
    
    structures.forEach((structure, index) => {
        if (structure.type === 'hut') {
            this.drawTraditionalHut(structure, buildingGroundY, index);
        } else {
            this.drawModernBuilding(structure, buildingGroundY);
        }
    });
}

/**
 * Draw traditional Indian village hut with thatched roof
 */
drawTraditionalHut(hut, groundY, index) {
    // Hut walls (mud/clay color)
    this.ctx.fillStyle = hut.color;
    this.ctx.fillRect(hut.x, groundY - hut.height, hut.width, hut.height);
    
    // Thatched roof (curved)
    const roofHeight = 25;
    this.ctx.fillStyle = '#DAA520'; // Golden straw color
    this.ctx.beginPath();
    this.ctx.moveTo(hut.x - 8, groundY - hut.height);
    // Create curved thatched roof
    this.ctx.quadraticCurveTo(
        hut.x + hut.width/2, 
        groundY - hut.height - roofHeight, 
        hut.x + hut.width + 8, 
        groundY - hut.height
    );
    this.ctx.lineTo(hut.x + hut.width, groundY - hut.height + 5);
    this.ctx.lineTo(hut.x, groundY - hut.height + 5);
    this.ctx.closePath();
    this.ctx.fill();
    
    // Roof texture lines (thatch pattern)
    this.ctx.strokeStyle = '#B8860B';
    this.ctx.lineWidth = 1;
    for (let i = 0; i < 4; i++) {
        this.ctx.beginPath();
        this.ctx.moveTo(hut.x - 5 + i * 15, groundY - hut.height - 2);
        this.ctx.quadraticCurveTo(
            hut.x + hut.width/2, 
            groundY - hut.height - roofHeight + 5, 
            hut.x + hut.width + 5 - i * 15, 
            groundY - hut.height - 2
        );
        this.ctx.stroke();
    }
    
    // Simple door
    this.ctx.fillStyle = '#654321';
    this.ctx.fillRect(hut.x + hut.width/2 - 8, groundY - 25, 16, 25);
    
    // Small window
    this.ctx.fillStyle = 'rgba(255, 255, 100, 0.4)';
    this.ctx.fillRect(hut.x + 12, groundY - hut.height + 15, 10, 8);
    
    // Chimney smoke (animated)
    this.drawChimneySmoke(hut.x + hut.width - 10, groundY - hut.height - 15, index);
}

/**
 * Draw modern building (existing style)
 */
drawModernBuilding(building, groundY) {
    // Building body
    this.ctx.fillStyle = building.color;
    this.ctx.fillRect(building.x, groundY - building.height, building.width, building.height);
    
    // Simple roof
    this.ctx.fillStyle = this.darkenColor(building.color, 0.2);
    this.ctx.beginPath();
    this.ctx.moveTo(building.x - 5, groundY - building.height);
    this.ctx.lineTo(building.x + building.width/2, groundY - building.height - 15);
    this.ctx.lineTo(building.x + building.width + 5, groundY - building.height);
    this.ctx.fill();
    
    // Simple windows
    this.ctx.fillStyle = 'rgba(255, 255, 100, 0.3)';
    for (let i = 0; i < 2; i++) {
        this.ctx.fillRect(
            building.x + 15 + i * 25, 
            groundY - building.height + 20, 
            12, 12
        );
    }
}

/**
 * Draw animated chimney smoke
 */
drawChimneySmoke(x, y, hutIndex) {
    const time = Date.now() * 0.003; // Keep original speed
    const smokeParticles = 4; // Keep original count
    
    this.ctx.save();
    this.ctx.fillStyle = 'rgba(180, 180, 180, 0.9)'; // FIXED: Darker smoke (was 0.8)
    
    for (let i = 0; i < smokeParticles; i++) {
        const offsetTime = time + hutIndex + i * 0.6; // Keep original timing
        const smokeX = x + Math.sin(offsetTime) * 12; // Keep original sway
        const smokeY = y - (i * 15) + Math.sin(offsetTime * 1.5) * 4; // Keep original movement
        const smokeSize = 5 + Math.sin(offsetTime) * 3; // Keep original size
        
        this.ctx.globalAlpha = 0.9 - (i * 0.15); // FIXED: Increased base opacity (was 0.8)
        this.ctx.beginPath();
        this.ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Keep original extra smoke wisp
        if (i < 2) {
            this.ctx.globalAlpha = 0.5 - (i * 0.1); // FIXED: Increased opacity (was 0.4)
            this.ctx.beginPath();
            this.ctx.arc(smokeX + 3, smokeY - 2, smokeSize * 0.6, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
    
    this.ctx.restore();
}
/**
 * Draw simplified crowd silhouettes
 */
drawSimpleCrowd() {
    const groundY = this.gameHeight * 0.72;
    const crowdY = groundY + 120;
    
    // Crowd is always visible - gets more animated during action
    const baseExcitement = 0.1; // Always some base animation
    const actionExcitement = this.projectiles.length > 0 ? 0.7 : 0;
    const totalExcitement = Math.min(baseExcitement + actionExcitement, 1.0);
    
    const crowdDepth = [
        // FAR BACK rows - expand beyond screen edges
        { startX: -20, endX: this.gameWidth + 20, density: 25, depth: 0.3, baseHeight: 28, yOffset: -5 },
        
        // BACK rows - expand beyond screen edges
        { startX: -15, endX: this.gameWidth + 15, density: 22, depth: 0.45, baseHeight: 35, yOffset: 0 },
        
        // MIDDLE-BACK rows - slightly expand
        { startX: -10, endX: this.gameWidth + 10, density: 20, depth: 0.6, baseHeight: 42, yOffset: 3 },
        
        // MIDDLE rows - keep full width (stage clearing will be handled in drawCrowdSection)
        { startX: 0, endX: this.gameWidth, density: 18, depth: 0.75, baseHeight: 48, yOffset: 6 },
        
        // FRONT-MIDDLE rows - keep full width
        { startX: 0, endX: this.gameWidth, density: 16, depth: 0.9, baseHeight: 55, yOffset: 10 },
        
        // FRONT rows - keep full width
        { startX: 0, endX: this.gameWidth, density: 14, depth: 1.1, baseHeight: 62, yOffset: 15 },
        
        // VERY FRONT rows - keep full width
        { startX: 0, endX: this.gameWidth, density: 12, depth: 1.3, baseHeight: 70, yOffset: 20 }
    ];
    
    this.ctx.save();
    
    crowdDepth.forEach((section, sectionIndex) => {
        this.drawCrowdSection(section, crowdY + section.yOffset, sectionIndex, totalExcitement);
    });
    
    this.ctx.restore();
}

/**
 * Draw a realistic crowd section with proper perspective density
 */
drawCrowdSection(section, crowdY, sectionIndex, excitement) {
    const sectionWidth = section.endX - section.startX;
    const spacing = sectionWidth / section.density;
    
    for (let i = 0; i < section.density; i++) {
        // Reduce randomness for denser, more uniform coverage
        const x = section.startX + (i * spacing) + Math.random() * 8 - 4;
        const personHeight = section.baseHeight + Math.random() * 4 - 2;
        const personWidth = Math.max(6, (section.baseHeight * 0.35) + Math.random() * 4); // increased multiplier and base
        
        // Skip drawing if too close to stage area (leave space for characters)
        const stageLeft = this.gameWidth * 0.35; // Expand left boundary
        const stageRight = this.gameWidth * 0.65; // Expand right boundary  
        const stageBuffer = 60; // Increase buffer from 40 to 60
        
        if (x > stageLeft - stageBuffer && x < stageRight + stageBuffer && section.depth > 0.8) {
            continue; // Skip this person if they're too close to stage in front rows
        }
        
        // Different person types for variety
        const personType = Math.floor(Math.random() * 4);
        this.drawRealisticPerson(x, crowdY, personWidth, personHeight, personType, section.depth, excitement);
    }
}

/**
 * Draw a realistic person silhouette with proper size scaling
 */
drawRealisticPerson(x, y, width, height, type, depth, excitement) {
    // Enhanced opacity for better visibility at all depths
    const opacity = 0.65 + (depth * 0.25); // More visible overall
    
    // Dynamic animation speed based on game state
    const baseAnimSpeed = 0.000001; // Much slower base (was 0.00003)
    const projectileBoost = this.projectiles.length > 0 ? (this.projectiles.length * 0.000005) : 0; // Minimal boost
    const politicianHitBoost = (this.politician.reactionTimer > 0) ? 0.000015 : 0; // Very small boost
    const slowTime = Date.now() * (baseAnimSpeed + projectileBoost + politicianHitBoost);
    const animOffset = x * 0.005; // Reduced offset variation
    
    // Much slower, subtler animation - scales with depth (front people move more)
    const sway = Math.sin(slowTime + animOffset) * 1.5 * excitement * depth;
    const handRaise = Math.sin(slowTime * 0.8 + animOffset) * 0.15 + 0.85;
    
    this.ctx.save();
    this.ctx.translate(x + sway, y);
    this.ctx.globalAlpha = Math.min(opacity, 0.9); // Cap max opacity
    
    switch(type) {
        case 0:
            this.drawPersonWithRaisedHands(0, 0, width, height, handRaise);
            break;
        case 1:
            this.drawPersonWithFlag(0, 0, width, height, handRaise);
            break;
        case 2:
            this.drawPersonClapping(0, 0, width, height, slowTime + animOffset);
            break;
        case 3:
            this.drawPersonPointing(0, 0, width, height, handRaise);
            break;
    }
    
    this.ctx.restore();
}

/**
 * Draw person with raised hands (celebrating)
 */
drawPersonWithRaisedHands(x, y, width, height, handRaise) {
    const headSize = width * 0.8;
    const bodyHeight = height * 0.6;
    const armLength = height * 0.4;
    
    this.ctx.fillStyle = 'rgba(80, 50, 25, 0.85)';
    
    // Head
    this.ctx.beginPath();
    this.ctx.arc(x, y - height, headSize/2, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Body (torso)
    this.ctx.fillRect(x - width/2, y - height + headSize/2, width, bodyHeight);
    
    // Arms raised up
    const armAngle = Math.PI/3 * handRaise;
    this.drawArm(x - width/2, y - height + headSize, armLength, -Math.PI/2 - armAngle, width/4);
    this.drawArm(x + width/2, y - height + headSize, armLength, -Math.PI/2 + armAngle, width/4);
    
    // Legs
    this.ctx.fillRect(x - width/3, y - height/3, width/4, height/3);
    this.ctx.fillRect(x + width/12, y - height/3, width/4, height/3);
}

/**
 * Draw person holding a flag
 */
drawPersonWithFlag(x, y, width, height, handRaise) {
    const headSize = width * 0.8;
    const bodyHeight = height * 0.6;
    const flagPoleHeight = height * 0.8;
    
    this.ctx.fillStyle = 'rgba(80, 50, 25, 0.85)';
    
    // Head
    this.ctx.beginPath();
    this.ctx.arc(x, y - height, headSize/2, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Body
    this.ctx.fillRect(x - width/2, y - height + headSize/2, width, bodyHeight);
    
    // One arm holding flag pole
    this.drawArm(x + width/2, y - height + headSize, height * 0.4, -Math.PI/4, width/4);
    
    // Flag pole
    this.ctx.strokeStyle = 'rgba(139, 69, 19, 0.8)';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.moveTo(x + width, y - height + headSize/2);
    this.ctx.lineTo(x + width, y - height + headSize/2 - flagPoleHeight);
    this.ctx.stroke();
    
    // Small flag
    this.ctx.fillStyle = 'rgba(255, 153, 51, 0.8)'; // Saffron color
    this.ctx.fillRect(x + width, y - height + headSize/2 - flagPoleHeight, 12, 8);
    
    // Other arm
    this.drawArm(x - width/2, y - height + headSize, height * 0.3, Math.PI/6, width/4);
    
    // Legs
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    this.ctx.fillRect(x - width/3, y - height/3, width/4, height/3);
    this.ctx.fillRect(x + width/12, y - height/3, width/4, height/3);
}

/**
 * Draw person clapping with slower animation
 */
drawPersonClapping(x, y, width, height, slowTime) {
    const headSize = width * 0.8;
    const bodyHeight = height * 0.6;
    const clapSpeed = this.projectiles.length > 0 ? 4 : 1.5; // Faster clapping during action
    const clapAnimation = Math.sin(slowTime * clapSpeed) * 0.15 + 0.85;
    
    this.ctx.fillStyle = 'rgba(80, 50, 25, 0.85)';
    
    // Head
    this.ctx.beginPath();
    this.ctx.arc(x, y - height, headSize/2, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Body
    this.ctx.fillRect(x - width/2, y - height + headSize/2, width, bodyHeight);
    
    // Arms positioned for clapping - slower movement
    const armSpread = width/3 * clapAnimation; // Reduced spread
    this.drawArm(x - armSpread, y - height + headSize + 5, height * 0.3, Math.PI/4, width/4);
    this.drawArm(x + armSpread, y - height + headSize + 5, height * 0.3, -Math.PI/4, width/4);
    
    // Legs
    this.ctx.fillRect(x - width/3, y - height/3, width/4, height/3);
    this.ctx.fillRect(x + width/12, y - height/3, width/4, height/3);
}

/**
 * Draw person pointing at stage
 */
drawPersonPointing(x, y, width, height, handRaise) {
    const headSize = width * 0.8;
    const bodyHeight = height * 0.6;
    
    this.ctx.fillStyle = 'rgba(80, 50, 25, 0.85)';
    
    // Head
    this.ctx.beginPath();
    this.ctx.arc(x, y - height, headSize/2, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Body
    this.ctx.fillRect(x - width/2, y - height + headSize/2, width, bodyHeight);
    
    // Pointing arm (toward center stage)
    const pointDirection = x < this.gameWidth/2 ? -Math.PI/6 : -Math.PI + Math.PI/6;
    this.drawArm(x + width/2, y - height + headSize, height * 0.4, pointDirection, width/4);
    
    // Other arm
    this.drawArm(x - width/2, y - height + headSize, height * 0.3, Math.PI/3 * handRaise, width/4);
    
    // Legs
    this.ctx.fillRect(x - width/3, y - height/3, width/4, height/3);
    this.ctx.fillRect(x + width/12, y - height/3, width/4, height/3);
}

/**
 * Helper method to draw an arm
 */
drawArm(startX, startY, length, angle, thickness) {
    this.ctx.save();
    this.ctx.translate(startX, startY);
    this.ctx.rotate(angle);
    this.ctx.fillStyle = 'rgba(101, 67, 33, 0.35)'; 
    this.ctx.fillRect(0, 0, thickness, length);
    this.ctx.restore();
}


/**
 * Draw enhanced stage with detailed podium and microphone
 */
drawEnhancedStage() {
    const centerX = this.gameWidth / 2;
    const groundY = this.gameHeight * 0.80;
    const stageY = groundY - 20; // Raise stage much higher (was -15)
    const stageWidth = this.isMobile ? 120 : 180;
    const stageHeight = this.isMobile ? 25 : 12; // Make stage taller (was 18)
    
    // Stage shadow - keep on ground
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
    this.ctx.fillRect(centerX - stageWidth/2 - 2, groundY - 2, stageWidth + 4, stageHeight + 4);
    
    // Stage platform - from stageY to groundY 
    const stageGradient = this.ctx.createLinearGradient(0, stageY, 0, groundY);
    stageGradient.addColorStop(0, '#A0522D');
    stageGradient.addColorStop(1, '#8B7355');
    
    this.ctx.fillStyle = stageGradient;
    this.ctx.fillRect(centerX - stageWidth/2, stageY, stageWidth, groundY - stageY); // Full height to ground
    
    // Stage edge highlight
    this.ctx.fillStyle = '#CD853F';
    this.ctx.fillRect(centerX - stageWidth/2, stageY, stageWidth, 2);
    
    // Simple stage supports
    this.ctx.fillStyle = '#654321';
    this.ctx.fillRect(centerX - stageWidth/2 + 10, stageY, 4, groundY - stageY);
    this.ctx.fillRect(centerX + stageWidth/2 - 14, stageY, 4, groundY - stageY);
    
    // Draw detailed podium with microphone
    this.drawDetailedPodium(centerX, stageY);
}

/**
 * Draw detailed wooden podium with microphone
 */
drawDetailedPodium(centerX, stageTop) {
    const podiumWidth = this.isMobile ? 30 : 48;
    const podiumHeight = this.isMobile ? 32 : 50;
    const podiumX = centerX - podiumWidth/2;
    const podiumY = stageTop - podiumHeight;
    
    // Podium shadow
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    this.ctx.fillRect(podiumX + 2, podiumY + 2, podiumWidth, podiumHeight);
    
    // Main podium body with wood gradient
    const woodGradient = this.ctx.createLinearGradient(podiumX, podiumY, podiumX + podiumWidth, podiumY);
    woodGradient.addColorStop(0, '#8B4513');
    woodGradient.addColorStop(0.5, '#A0522D');
    woodGradient.addColorStop(1, '#654321');
    
    this.ctx.fillStyle = woodGradient;
    this.ctx.fillRect(podiumX, podiumY, podiumWidth, podiumHeight);
    
    // Wood texture lines (vertical grain)
    this.ctx.strokeStyle = 'rgba(101, 67, 33, 0.5)';
    this.ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
        const x = podiumX + (i / 4) * podiumWidth;
        this.ctx.beginPath();
        this.ctx.moveTo(x, podiumY + 5);
        this.ctx.lineTo(x, podiumY + podiumHeight - 5);
        this.ctx.stroke();
    }
    
    // Podium top (lectern surface)
    const topGradient = this.ctx.createLinearGradient(0, podiumY - 5, 0, podiumY);
    topGradient.addColorStop(0, '#D2691E');
    topGradient.addColorStop(1, '#A0522D');
    
    this.ctx.fillStyle = topGradient;
    this.ctx.fillRect(podiumX - 3, podiumY - 5, podiumWidth + 6, 8);
    
    // Podium edge detail
    this.ctx.fillStyle = '#654321';
    this.ctx.fillRect(podiumX - 3, podiumY - 5, podiumWidth + 6, 2);
    
    // Podium front panel decoration
    this.ctx.strokeStyle = '#654321';
    this.ctx.lineWidth = 2;
    this.ctx.strokeRect(podiumX + 3, podiumY + 8, podiumWidth - 6, podiumHeight - 16);
    
    // Draw microphone stand and mic
    this.drawPodiumMicrophone(centerX, podiumY - 5);
}

/**
 * Draw detailed microphone on podium
 */
drawPodiumMicrophone(centerX, podiumTop) {
    const micStandHeight = this.isMobile ? 25 : 35;
    const micStandX = centerX;
    const micStandY = podiumTop - micStandHeight;
    
    // Microphone stand (thin metal pole)
    this.ctx.strokeStyle = '#696969';
    this.ctx.lineWidth = this.isMobile ? 2 : 3;
    this.ctx.beginPath();
    this.ctx.moveTo(micStandX, podiumTop);
    this.ctx.lineTo(micStandX, micStandY);
    this.ctx.stroke();
    
    // Microphone stand base (on podium)
    this.ctx.fillStyle = '#696969';
    this.ctx.fillRect(micStandX - 4, podiumTop - 2, 8, 4);
    
    // Microphone boom arm
    const boomLength = this.isMobile ? 12 : 15;
    this.ctx.strokeStyle = '#696969';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.moveTo(micStandX, micStandY);
    this.ctx.lineTo(micStandX + boomLength, micStandY - 3);
    this.ctx.stroke();
    
    // Microphone head
    const micX = micStandX + boomLength;
    const micY = micStandY - 3;
    const micRadius = this.isMobile ? 4 : 5;
    
    // Microphone windscreen (dark gray)
    this.ctx.fillStyle = '#404040';
    this.ctx.beginPath();
    this.ctx.arc(micX, micY, micRadius, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Microphone grille texture
    this.ctx.strokeStyle = '#606060';
    this.ctx.lineWidth = 0.5;
    for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        this.ctx.beginPath();
        this.ctx.moveTo(micX, micY);
        this.ctx.lineTo(
            micX + Math.cos(angle) * (micRadius - 1),
            micY + Math.sin(angle) * (micRadius - 1)
        );
        this.ctx.stroke();
    }
    
    // Microphone highlight
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    this.ctx.beginPath();
    this.ctx.arc(micX - 1, micY - 1, micRadius/2, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Microphone cable (subtle)
    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.moveTo(micX - 2, micY + 2);
    this.ctx.quadraticCurveTo(micX - 8, micY + 8, micStandX - 10, podiumTop);
    this.ctx.stroke();
}

/**
 * Draw enhanced ground with texture
 */
drawEnhancedGround() {
    const groundY = this.gameHeight * 0.80;
    
    // Ground gradient with texture
    const groundGradient = this.ctx.createLinearGradient(0, groundY, 0, this.gameHeight);
    groundGradient.addColorStop(0, '#DEB887');
    groundGradient.addColorStop(0.3, '#D2B48C');
    groundGradient.addColorStop(1, '#C19A6B');
    
    this.ctx.fillStyle = groundGradient;
    this.ctx.fillRect(0, groundY, this.gameWidth, this.gameHeight - groundY);
    
    // Simple ground texture (mobile-safe)
    if (!this.isMobile || this.projectiles.length > 0) {
        this.ctx.save();
        this.ctx.globalAlpha = 0.1;
        this.ctx.fillStyle = '#8B7355';
        
        // Add simple texture lines
        for (let i = 0; i < 8; i++) {
            const y = groundY + 10 + i * 8;
            this.ctx.fillRect(0, y, this.gameWidth, 1);
        }
        
        this.ctx.restore();
    }
}


/**
 * Draw dynamic sky with time-based changes
 * @param {number} groundY - Ground level Y position
 */
drawDynamicSky(groundY) {
    const sky = this.atmosphericSystem.skyGradient;
    
    // Update sky time and intensity based on game state
    sky.time += 0.0005;
    sky.intensity = Math.min(0.3, this.projectiles.length * 0.02); // Sky gets more dramatic with more projectiles
    
    // Create dynamic gradient
    const skyGradient = this.ctx.createLinearGradient(0, 0, 0, groundY);
    
    const hue1 = sky.baseHue + Math.sin(sky.time) * 15 + sky.intensity * 20;
    const hue2 = sky.baseHue + 30 + Math.cos(sky.time * 1.2) * 10 + sky.intensity * 15;
    
    const saturation1 = 50 + sky.intensity * 30;
    const saturation2 = 40 + sky.intensity * 25;
    
    const lightness1 = 80 - sky.intensity * 20;
    const lightness2 = 70 - sky.intensity * 15;
    
    skyGradient.addColorStop(0, `hsl(${hue1}, ${saturation1}%, ${lightness1}%)`);
    skyGradient.addColorStop(0.7, `hsl(${hue2}, ${saturation2}%, ${lightness2}%)`);
    skyGradient.addColorStop(1, `hsl(${hue2 + 10}, ${saturation2 - 10}%, ${lightness2 - 5}%)`);
    
    this.ctx.fillStyle = skyGradient;
    this.ctx.fillRect(0, 0, this.gameWidth, groundY);
}


/**
 * Draw animated procedural clouds
 */
drawAnimatedClouds() {
    // MOBILE: Skip animated clouds
    if (this.isMobile) {
        return;
    }
    
    const time = this.crowdAnimation.time * 0.0003; // Slower than crowd animation
    
    // Define cloud positions and properties
    const clouds = [
        { baseX: this.gameWidth * 0.15, y: this.gameHeight * 0.12, size: 60, speed: 0.8 },
        { baseX: this.gameWidth * 0.45, y: this.gameHeight * 0.08, size: 80, speed: 0.5 },
        { baseX: this.gameWidth * 0.75, y: this.gameHeight * 0.15, size: 70, speed: 0.6 },
        { baseX: this.gameWidth * 1.1, y: this.gameHeight * 0.10, size: 90, speed: 0.4 }
    ];
    
    clouds.forEach((cloud, index) => {
        // Calculate moving X position (clouds drift across screen)
        const moveX = (cloud.baseX + time * cloud.speed * 100) % (this.gameWidth + 200) - 100;
        
        // Subtle vertical bobbing
        const bobY = cloud.y + Math.sin(time * 2 + index) * 3;
        
        this.drawCloud(moveX, bobY, cloud.size);
    });
}

/**
 * Draw a single cloud
 * @param {number} x - X position
 * @param {number} y - Y position 
 * @param {number} size - Cloud size
 */
drawCloud(x, y, size) {
    this.ctx.save();
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
    this.ctx.shadowBlur = 10;
    
    // Draw cloud as multiple overlapping circles
    const circles = [
        { offsetX: 0, offsetY: 0, scale: 1.0 },
        { offsetX: size * 0.3, offsetY: size * 0.1, scale: 0.8 },
        { offsetX: -size * 0.2, offsetY: size * 0.15, scale: 0.7 },
        { offsetX: size * 0.1, offsetY: -size * 0.2, scale: 0.6 },
        { offsetX: -size * 0.3, offsetY: -size * 0.1, scale: 0.5 }
    ];
    
    circles.forEach(circle => {
        this.ctx.beginPath();
        this.ctx.arc(
            x + circle.offsetX, 
            y + circle.offsetY, 
            size * circle.scale * 0.5, 
            0, Math.PI * 2
        );
        this.ctx.fill();
    });
    
    this.ctx.restore();
}

/**
 * Update crowd animations
 * @param {number} deltaTime - Time delta
 */
updateCrowdAnimations(deltaTime) {
    this.crowdAnimation.time += deltaTime * 2000;

    // DEBUG: Simple verification that animation is running
    console.log('Animation time:', this.crowdAnimation.time);
    
    const projectileIntensity = Math.min(this.projectiles.length / 10, 1);
    this.crowdAnimation.waveAmplitude = 8 + projectileIntensity * 12;
    this.crowdAnimation.waveSpeed = 0.003 + projectileIntensity * 0.005;
}
   
    /**
     * Draw podium and microphone
     */
    drawPodiumAndMic() {
        const centerX = this.gameWidth / 2;
        const groundY = this.gameHeight * 0.65;
        const stageY = groundY - 15;
        const isMobileScreen = this.gameWidth < 768;
        const basePodiumScale = this.gameWidth / 1400;
        const podiumScale = isMobileScreen ? Math.max(0.8, basePodiumScale) : basePodiumScale;
        
        // Stage platform
        this.ctx.fillStyle = '#8B7355';
        this.ctx.fillRect(centerX - 100 * podiumScale, stageY, 200 * podiumScale, 15 * podiumScale);
        
        // Stage edge
        this.ctx.fillStyle = '#654321';
        this.ctx.fillRect(centerX - 100 * podiumScale, stageY + 15 * podiumScale, 200 * podiumScale, 3 * podiumScale);
        
        // Podium
        this.ctx.fillStyle = '#A0522D';
        this.ctx.fillRect(centerX - 40 * podiumScale, stageY - 50 * podiumScale, 80 * podiumScale, 50 * podiumScale);
        
        // Podium details
        this.ctx.fillStyle = '#654321';
        this.ctx.fillRect(centerX - 35 * podiumScale, stageY - 55 * podiumScale, 70 * podiumScale, 5 * podiumScale);
        
        // Microphone stand
        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 4 * podiumScale;
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, stageY - 50 * podiumScale);
        this.ctx.lineTo(centerX, stageY - 80 * podiumScale);
        this.ctx.stroke();
        
        // Microphone
        this.ctx.fillStyle = '#666';
        this.ctx.beginPath();
        this.ctx.arc(centerX, stageY - 85 * podiumScale, 8 * podiumScale, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Microphone windscreen
        this.ctx.fillStyle = '#444';
        this.ctx.beginPath();
        this.ctx.arc(centerX, stageY - 85 * podiumScale, 6 * podiumScale, 0, Math.PI * 2);
        this.ctx.fill();
    }

/**
 * Draw politician character with enhanced reactions
 */
drawPolitician() {
    const p = this.politician;
    
    // Update stress level based on health
    this.reactionSystem.politician.stressLevel = Math.max(0, 100 - this.politicianHealth);
    
    // Determine animation based on reaction state
    let animation = 'idle';
    let frameSpeed = 0.4;
    
    if (p.reactionTimer > 0) {
        frameSpeed = 0.15;
        animation = p.reactionState;
    } else if (this.projectiles.length > 5) {
        animation = 'panicked';
        frameSpeed = 0.2;
    } else if (this.politicianHealth < 20) {
        animation = 'critical';
        frameSpeed = 0.3;
    }
    
    this.setCharacterAnimation('politician', animation);
    
    // Draw politician with stress-based shake
    this.ctx.save();
    if (this.reactionSystem.politician.stressLevel > 70) {
        const shake = (this.reactionSystem.politician.stressLevel - 70) / 30 * 2;
        this.ctx.translate(
            (Math.random() - 0.5) * shake,
            (Math.random() - 0.5) * shake
        );
    }
    
    const spriteDrawn = this.drawCharacterSprite(
        'politician',
        p.x,
        p.y,
        90,
        130,
        animation
    );
    
    this.ctx.restore();
    
    // Draw reaction effects
    this.drawPoliticianReactionEffects();
    
    // Draw stains over the politician sprite
    if (spriteDrawn && p.stains.length > 0) {
        this.drawPoliticianStains(p);
    }
    
    // Fallback if sprite fails
    if (!spriteDrawn) {
        this.ctx.fillStyle = '#9370DB';
        this.ctx.fillRect(p.x, p.y, 75, 100);
        
        if (p.stains.length > 0) {
            this.drawPoliticianStains(p);
        }
    }
    
    // Draw message bubble after drawing the politician
    if (p.messageBubble.isVisible) {
        this.drawMessageBubble(p);
    }
}

/**
 * Draw politician reaction effects
 */
drawPoliticianReactionEffects() {
    const p = this.politician;
    const reactions = this.reactionSystem.politician;
    
    // Draw worry sweat when health is low
    if (this.politicianHealth < 50) {
        this.drawWorrySweat();
    }
    
    // Draw reaction circle when recently hit
    if (p.reactionTimer > 0) {
        this.drawReactionCircle();
    }
    
    // Draw stress indicators when health is critical
    if (this.politicianHealth < 25) {
        this.drawStressIndicators();
    }
    
    // Update and draw sweat drops
    this.updateAndDrawSweatDrops();
}

/**
 * Draw worry sweat drops
 */
drawWorrySweat() {
    const p = this.politician;
    const sweatPositions = [
        { x: p.x + 25, y: p.y + 20 },
        { x: p.x + 65, y: p.y + 30 }
    ];
    
    this.ctx.save();
    this.ctx.fillStyle = '#87CEEB';
    this.ctx.shadowColor = '#87CEEB';
    this.ctx.shadowBlur = 3;
    
    sweatPositions.forEach((pos, index) => {
        const time = Date.now() * 0.003 + index;
        const wobble = Math.sin(time) * 2;
        
        // Main sweat drop
        this.ctx.beginPath();
        this.ctx.arc(pos.x + wobble, pos.y, 3, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Drip animation
        this.ctx.beginPath();
        this.ctx.ellipse(pos.x + wobble, pos.y + 10, 1.5, 4, 0, 0, Math.PI * 2);
        this.ctx.fill();
    });
    
    this.ctx.restore();
}

/**
 * Draw reaction circle effect
 */
drawReactionCircle() {
    const p = this.politician;
    const time = Date.now() * 0.008;
    const reactionIntensity = p.reactionTimer / 2000; // Normalize to 0-1
    
    const radius = 50 + Math.sin(time) * 8 * reactionIntensity;
    const alpha = Math.max(0.1, reactionIntensity * 0.6);
    
    this.ctx.save();
    this.ctx.globalAlpha = alpha;
    this.ctx.strokeStyle = '#FF6B6B';
    this.ctx.lineWidth = 3 * reactionIntensity;
    this.ctx.setLineDash([8, 8]);
    this.ctx.lineDashOffset = time * 10;
    
    this.ctx.beginPath();
    this.ctx.arc(
        p.x + p.width/2,
        p.y + p.height/2,
        radius, 0, Math.PI * 2
    );
    this.ctx.stroke();
    
    this.ctx.setLineDash([]);
    this.ctx.restore();
}

/**
 * Draw stress indicators for critical health
 */
drawStressIndicators() {
    const p = this.politician;
    const time = Date.now() * 0.01;
    
    // Stress lines around head
    const stressLines = 8;
    const headCenterX = p.x + p.width/2;
    const headCenterY = p.y + 20;
    
    this.ctx.save();
    this.ctx.strokeStyle = '#FF4757';
    this.ctx.lineWidth = 2;
    this.ctx.globalAlpha = 0.7;
    
    for (let i = 0; i < stressLines; i++) {
        const angle = (i / stressLines) * Math.PI * 2 + time;
        const innerRadius = 35;
        const outerRadius = 45 + Math.sin(time * 3 + i) * 5;
        
        const startX = headCenterX + Math.cos(angle) * innerRadius;
        const startY = headCenterY + Math.sin(angle) * innerRadius;
        const endX = headCenterX + Math.cos(angle) * outerRadius;
        const endY = headCenterY + Math.sin(angle) * outerRadius;
        
        this.ctx.beginPath();
        this.ctx.moveTo(startX, startY);
        this.ctx.lineTo(endX, endY);
        this.ctx.stroke();
    }
    
    this.ctx.restore();
}

/**
 * Update and draw animated sweat drops
 */
updateAndDrawSweatDrops() {
    const reactions = this.reactionSystem.politician;
    
    // Add new sweat drops when stressed
    if (this.politicianHealth < 30 && Math.random() < 0.02) {
        reactions.sweatDrops.push({
            x: this.politician.x + 20 + Math.random() * 50,
            y: this.politician.y + 15 + Math.random() * 10,
            vy: 50 + Math.random() * 30,
            life: 2.0,
            size: 2 + Math.random() * 2
        });
    }
    
    // Update and draw sweat drops
    this.ctx.save();
    this.ctx.fillStyle = '#87CEEB';
    this.ctx.shadowColor = '#87CEEB';
    this.ctx.shadowBlur = 2;
    
    for (let i = reactions.sweatDrops.length - 1; i >= 0; i--) {
        const drop = reactions.sweatDrops[i];
        
        drop.y += drop.vy * 0.016;
        drop.life -= 0.016;
        
        if (drop.life <= 0 || drop.y > this.gameHeight) {
            reactions.sweatDrops.splice(i, 1);
            continue;
        }
        
        this.ctx.globalAlpha = Math.min(1, drop.life / 2.0);
        this.ctx.beginPath();
        this.ctx.arc(drop.x, drop.y, drop.size, 0, Math.PI * 2);
        this.ctx.fill();
    }
    
    this.ctx.restore();
}

drawMessageBubble() {
    const bubble = this.politician.messageBubble;
    const p = this.politician;
    
    // Bubble position (above politician's head)
    const bubbleX = p.x + p.width/2;
    const bubbleY = p.y - 60;
    const bubbleWidth = 200;
    const bubbleHeight = 40;
    
    this.ctx.save();
    this.ctx.globalAlpha = bubble.fadeIn;
    
    // Draw bubble background
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    this.ctx.strokeStyle = '#333';
    this.ctx.lineWidth = 2;
    
    // Rounded rectangle for bubble
    this.ctx.beginPath();
    this.ctx.roundRect(bubbleX - bubbleWidth/2, bubbleY - bubbleHeight/2, bubbleWidth, bubbleHeight, 10);
    this.ctx.fill();
    this.ctx.stroke();
    
    // Draw bubble tail (pointing to politician)
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    this.ctx.beginPath();
    this.ctx.moveTo(bubbleX - 10, bubbleY + bubbleHeight/2);
    this.ctx.lineTo(bubbleX, bubbleY + bubbleHeight/2 + 15);
    this.ctx.lineTo(bubbleX + 10, bubbleY + bubbleHeight/2);
    this.ctx.fill();
    this.ctx.stroke();
    
    // Draw text
    this.ctx.fillStyle = '#333';
    this.ctx.font = 'bold 14px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.textBaseline = 'middle';
    this.ctx.fillText(bubble.text, bubbleX, bubbleY);
    
    this.ctx.restore();
}
    
    /**
 * Draw aide character with enhanced reactions
 */
drawAide() {
    const a = this.aide;
    const reactions = this.reactionSystem.aide;
    
    // Update confidence based on recent performance
    const timeSinceLastSuccess = Date.now() - reactions.lastSuccessTime;
    if (timeSinceLastSuccess > 5000) {
        reactions.confidenceLevel = Math.max(50, reactions.confidenceLevel - 0.5);
    }
    
    let animation = 'idle';
    
    // Determine animation based on state and confidence
    if (reactions.victoryPose && reactions.victoryTimer > 0) {
        animation = 'victory';
    } else if (a.shield) {
        const hasProjectilesFromSide = this.projectiles.some(proj => 
            Math.abs(proj.x - a.x) > Math.abs(proj.y - a.y)
        );
        animation = hasProjectilesFromSide ? 'shield_side' : 'shield_up';
    } else if (this.projectiles.length > 5) {
        animation = 'crouch_cover';
    } else if (this.projectiles.some(proj => proj.y > a.y)) {
        animation = 'swat_down';
    } else if (reactions.confidenceLevel < 60) {
        animation = 'worried';
    } else if (a.expression === 'focused') {
        animation = 'focused';
    } else if (this.keys['KeyA'] || this.keys['KeyD'] || 
               this.keys['ArrowLeft'] || this.keys['ArrowRight']) {
        animation = 'walking';
    }
    
    this.setCharacterAnimation('aide', animation);
    
    // Draw aide with confidence-based effects
    this.ctx.save();
    
    // Add confidence glow effect
    if (reactions.confidenceLevel > 80) {
        this.ctx.shadowColor = '#00FFFF';
        this.ctx.shadowBlur = 8;
    }
    
    const spriteDrawn = this.drawCharacterSprite(
        'aide',
        a.x,
        a.y + a.bounceY,
        100,
        130,
        animation
    );
    
    this.ctx.restore();
    
    // Draw aide reaction effects
    this.drawAideReactionEffects();
    
    // Draw shield effect
    if (a.shield) {
        this.drawShieldEffect(a);
    }
}

/**
 * Draw aide reaction effects
 */
drawAideReactionEffects() {
    const a = this.aide;
    const reactions = this.reactionSystem.aide;
    
    // Draw confidence indicator
    this.drawConfidenceIndicator();
    
    // Draw victory effects
    if (reactions.victoryPose && reactions.victoryTimer > 0) {
        this.drawVictoryEffects();
    }
    
    // Draw focus lines when concentrated
    if (a.expression === 'focused' && a.shield) {
        this.drawFocusLines();
    }
}

/**
 * Draw confidence level indicator
 */
drawConfidenceIndicator() {
    const a = this.aide;
    const reactions = this.reactionSystem.aide;
    
    if (reactions.confidenceLevel < 70) {
        // Draw worry indicators
        const time = Date.now() * 0.005;
        const worryIntensity = (70 - reactions.confidenceLevel) / 70;
        
        this.ctx.save();
        this.ctx.strokeStyle = '#FFD700';
        this.ctx.lineWidth = 2;
        this.ctx.globalAlpha = worryIntensity * 0.6;
        
        // Worry lines above head
        for (let i = 0; i < 3; i++) {
            const x = a.x + 30 + i * 15 + Math.sin(time + i) * 3;
            const y = a.y - 10 - i * 5;
            
            this.ctx.beginPath();
            this.ctx.moveTo(x - 5, y);
            this.ctx.lineTo(x + 5, y);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }
}

/**
 * Draw victory celebration effects
 */
drawVictoryEffects() {
    const a = this.aide;
    const time = Date.now() * 0.01;
    
    // Victory sparkles
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + time;
        const radius = 40 + Math.sin(time * 2 + i) * 10;
        const x = a.x + 50 + Math.cos(angle) * radius;
        const y = a.y + 50 + Math.sin(angle) * radius;
        
        this.ctx.save();
        this.ctx.fillStyle = '#FFD700';
        this.ctx.globalAlpha = 0.8;
        this.ctx.shadowColor = '#FFD700';
        this.ctx.shadowBlur = 5;
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, 2 + Math.sin(time * 3 + i), 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.restore();
    }
}

/**
 * Draw focus concentration lines
 */
drawFocusLines() {
    const a = this.aide;
    const time = Date.now() * 0.008;
    
    this.ctx.save();
    this.ctx.strokeStyle = '#00FFFF';
    this.ctx.lineWidth = 1;
    this.ctx.globalAlpha = 0.6;
    
    // Focus lines emanating from eyes
    const eyeX = a.x + 50;
    const eyeY = a.y + 30;
    
    for (let i = 0; i < 6; i++) {
        const angle = -Math.PI/3 + (i / 5) * (2 * Math.PI/3) + Math.sin(time + i) * 0.1;
        const length = 25 + Math.sin(time * 2 + i) * 5;
        
        this.ctx.beginPath();
        this.ctx.moveTo(eyeX, eyeY);
        this.ctx.lineTo(
            eyeX + Math.cos(angle) * length,
            eyeY + Math.sin(angle) * length
        );
        this.ctx.stroke();
    }
    
    this.ctx.restore();
}

    /**
     * Draw shield effect
     * @param {Object} aide - Aide character object
     */
    drawShieldEffect(aide) {
        const time = Date.now() * 0.01;
        const radius = 55 + Math.sin(time) * 4;
        
        this.ctx.strokeStyle = '#00FFFF';
        this.ctx.lineWidth = 4;
        this.ctx.setLineDash([10, 5]);
        this.ctx.beginPath();
        this.ctx.arc(aide.x + 40, aide.y + 65 + aide.bounceY, radius, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        
        for (let i = 0; i < 10; i++) {
            const angle = (time + i * Math.PI / 5) % (Math.PI * 2);
            const sx = aide.x + 40 + Math.cos(angle) * (radius - 4);
            const sy = aide.y + 65 + aide.bounceY + Math.sin(angle) * (radius - 4);
            
            this.ctx.fillStyle = '#00FFFF';
            this.ctx.globalAlpha = 0.8;
            this.ctx.beginPath();
            this.ctx.arc(sx, sy, 3, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.globalAlpha = 1.0;
        }
    }


/**
 * Draw projectiles with all visual effects
 */
//drawProjectiles() {
    // Draw impact predictions first (behind projectiles)
  //  this.drawImpactPredictions();
    
    // Draw warning indicators
    //this.drawWarningIndicators();
    
    // Draw enhanced projectile trails
    // this.drawEnhancedTrails();
    
    // Draw projectiles with enhanced effects
    //this.projectiles.forEach(proj => {
      //  this.ctx.save();
        
        // Enhanced glow based on threat level
        // this.ctx.shadowColor = this.projectileEffects.threatLevels[proj.threatLevel].color;
        //this.ctx.shadowBlur = 10 + (proj.glowIntensity * 5);
        
        // Pulsing effect for high threat projectiles
        // if (proj.threatLevel === 'high' || proj.threatLevel === 'critical') {
           // const pulseScale = 1.0 + Math.sin(Date.now() * 0.01) * 0.1;
            //this.ctx.translate(proj.x, proj.y);
            //this.ctx.scale(pulseScale, pulseScale);
           // this.ctx.translate(-proj.x, -proj.y);
       // }
        
        // Draw main projectile
        //this.ctx.translate(proj.x, proj.y);
        //this.ctx.rotate(proj.rotation);
        //this.drawGlassmorphicProjectile(proj);
        //this.ctx.restore();
        
        // Draw priority rings (your existing method)
        // this.drawProjectilePriorityRings(proj);
        
        // Draw proximity warning
        // this.drawProximityWarning(proj);
    //});
 // }



/**
 * Draw proximity warning for close projectiles
 * @param {Object} proj - Projectile object
 */
drawProximityWarning(proj) {
    const warningDistance = 100;
    
    if (proj.distanceToPolitician <= warningDistance) {
        const intensity = 1 - (proj.distanceToPolitician / warningDistance);
        const time = Date.now() * 0.02;
        
        this.ctx.save();
        this.ctx.globalAlpha = intensity * 0.6 * (0.5 + Math.sin(time) * 0.5);
        this.ctx.strokeStyle = '#FF0000';
        this.ctx.lineWidth = 2 + intensity * 3;
        this.ctx.setLineDash([8, 8]);
        
        const warningRadius = proj.size + 15 + Math.sin(time) * 5;
        this.ctx.beginPath();
        this.ctx.arc(proj.x, proj.y, warningRadius, 0, Math.PI * 2);
        this.ctx.stroke();
        
        this.ctx.setLineDash([]);
        this.ctx.restore();
    }
}
drawProjectilePriorityRings(projectile) {
    // STEP 6: Performance optimization - skip rings for very distant projectiles
    const distanceToPolitician = projectile.distanceToPolitician || 999;
    
    // Skip ring rendering for very distant projectiles (performance)
    if (distanceToPolitician > 500 && !this.gameWidth >= 768) {
        return; // Skip on mobile for distant projectiles
    }
    
    const currentTime = Date.now();
    const age = currentTime - projectile.spawnTime;
    
    // STEP 1: Basic dynamic ring with #0097D7 color and distance calculation
    
    // FIXED: Much tighter ring - matches the golden glow example
    let baseRadius = (projectile.size / 2) + 2; // Ring sits just outside projectile edge
    const ringColor = '#0097D7';
    
    // STEP 2: Enhanced threat level scaling based on projectile damage
    let intensity = 1.0;
    let pulseSpeed = 1.0;

    // Base threat level scaling
    const threatMultiplier = projectile.damage ? (projectile.damage / 10) : 1.0;
    intensity *= (1.0 + threatMultiplier * 0.5); // High damage = brighter rings

    // Distance-based intensity enhancement
    if (distanceToPolitician < 200) {
        intensity += (200 - distanceToPolitician) / 200; // Additional intensity for proximity
    }

    // Threat-specific pulsing
    if (projectile.threatLevel === 'high' || (projectile.damage && projectile.damage >= 25)) {
        pulseSpeed = 2.0; // Faster pulse for high threat
    } else if (projectile.threatLevel === 'medium' || (projectile.damage && projectile.damage >= 15)) {
        pulseSpeed = 1.5; // Medium pulse
    } else {
        pulseSpeed = 1.0; // Normal pulse for low threat
    }

    // STEP 3: Add pulsation effects based on distance and time
    const timeMultiplier = currentTime * 0.001; // Convert to seconds
    let pulseFactor = 1.0;
    // Create pulsation based on distance to politician
    if (distanceToPolitician < 200) {
        // Close to politician - add pulsing effect
        pulseFactor = 1.0 + Math.sin(timeMultiplier * pulseSpeed * 2 * Math.PI) * 0.3;
    } else if (distanceToPolitician < 300) {
        // Medium distance - subtle pulsing
        pulseFactor = 1.0 + Math.sin(timeMultiplier * pulseSpeed * Math.PI) * 0.15;
    }
    // Critical distance - rapid pulsation
    if (distanceToPolitician < 100) {
        pulseFactor = 1.0 + Math.sin(timeMultiplier * pulseSpeed * 4 * Math.PI) * 0.5;
        intensity *= 1.5; // Extra brightness for critical threats
    }

    // STEP 4: Critical distance behavior with enhanced visual effects
    let criticalEffect = false;
    if (distanceToPolitician < 50) {
        criticalEffect = true;
        
        // Maximum pulsation for critical threats
        pulseFactor = 1.0 + Math.sin(timeMultiplier * pulseSpeed * 6 * Math.PI) * 0.8;
        intensity *= 2.0; // Double brightness
        
        // Add screen shake trigger (we'll implement this next)
        if (!projectile.criticalWarningTriggered) {
            projectile.criticalWarningTriggered = true;
            this.triggerScreenShake(200); // 200ms shake
            console.log(`ðŸš¨ CRITICAL DISTANCE REACHED for ${projectile.type}!`);
        }
        
        // Enhanced ring size for critical threats
        baseRadius += Math.sin(timeMultiplier * 8) * 3;
    }
    // Color transition for critical threats
    let finalRingColor = ringColor;
    if (criticalEffect) {
        // Transition from blue to red for critical threats
        const redIntensity = Math.min(1.0, (50 - distanceToPolitician) / 50);
        const r = Math.floor(255 * redIntensity);
        const g = Math.floor(151 * (1 - redIntensity));
        const b = Math.floor(215 * (1 - redIntensity));
        finalRingColor = `rgb(${r}, ${g}, ${b})`;
    }

    // STEP 5: Trajectory accuracy indicator - faster pulse for direct hits
    let trajectoryAccuracy = 0;
    if (projectile.targetX && projectile.targetY) {
        // Calculate if projectile is on collision course
        const projToTarget = Math.sqrt(
            Math.pow(projectile.targetX - projectile.x, 2) + 
            Math.pow(projectile.targetY - projectile.y, 2)
        );
        
        // Higher accuracy = closer to direct hit
        trajectoryAccuracy = Math.max(0, 1 - (projToTarget / 100));
        
        // Adjust pulse speed based on accuracy
        if (trajectoryAccuracy > 0.8) {
            pulseSpeed *= 1.5; // Much faster pulse for direct hits
            intensity *= 1.2; // Brighter for accurate threats
        } else if (trajectoryAccuracy > 0.5) {
            pulseSpeed *= 1.2; // Moderate pulse increase
        }
        
        // Enhanced ring for high-accuracy threats
        if (trajectoryAccuracy > 0.9) {
            baseRadius += 2; // Slightly larger ring for imminent hits
        }
    }

    this.ctx.save();
    this.ctx.globalAlpha = (0.9 * intensity * pulseFactor); // Apply pulsation to opacity
    // Enhanced glow for pulsing effect
    this.ctx.strokeStyle = finalRingColor; // Use dynamic color
    this.ctx.lineWidth = 3;
    this.ctx.shadowColor = finalRingColor; // Match shadow color
    this.ctx.shadowBlur = 8 + (pulseFactor * 4); // Pulsing glow
    this.ctx.beginPath();
    this.ctx.arc(projectile.x, projectile.y, baseRadius, 0, Math.PI * 2);
    this.ctx.stroke();
    this.ctx.restore();
    console.log(`Ring drawn for ${projectile.type}, distance: ${distanceToPolitician.toFixed(0)}, intensity: ${intensity.toFixed(2)}, threat: ${projectile.threatLevel}, damage: ${projectile.damage}, pulseSpeed: ${pulseSpeed}, pulseFactor: ${pulseFactor.toFixed(2)}, trajectory: ${trajectoryAccuracy.toFixed(2)}, critical: ${criticalEffect}`);
}

/**
 * Draw individual glassmorphic emoji-style projectile
 * @param {Object} proj - Projectile object
 */
drawGlassmorphicProjectile(proj) {
    const size = proj.size;
    
    // Enhanced glassmorphic background with modern gradient
    const gradient = this.ctx.createRadialGradient(-size/4, -size/4, 0, 0, 0, size/2);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
    gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
    gradient.addColorStop(0.7, proj.glassTint + '60');
    gradient.addColorStop(1, proj.color + '30');

    // Modern glassmorphic circle base
    this.ctx.fillStyle = gradient;
    this.ctx.shadowColor = proj.color;
    this.ctx.shadowBlur = 15;
    this.ctx.beginPath();
    this.ctx.arc(0, 0, size/2, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Glass border effect
    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    this.ctx.lineWidth = 2;
    this.ctx.stroke();
    
    // Draw emoji-style projectile content
    this.ctx.shadowBlur = 0;
    this.drawEmojiProjectile(proj, size);
    
    // Modern highlight
    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    this.ctx.beginPath();
    this.ctx.ellipse(-size/3, -size/3, size/4, size/6, 0, 0, Math.PI * 2);
    this.ctx.fill();
}

/**
 * Draw emoji-style projectile content
 * @param {Object} proj - Projectile object  
 * @param {number} size - Projectile size
 */
drawEmojiProjectile(proj, size) {
    const emojiSize = Math.max(size * 1.0, 20);
    
    this.ctx.textAlign = 'center';
    this.ctx.textBaseline = 'middle';
    this.ctx.font = `${emojiSize}px Arial, sans-serif`;
    
    const emojiMap = {
        tomato: 'ðŸ…', egg: 'ðŸ¥š', shoe: 'ðŸ‘ž', bottle: 'ðŸ¼',
        stone: 'ðŸª¨', banana: 'ðŸŒ', apple: 'ðŸŽ'
    };
    
    const emoji = emojiMap[proj.type] || 'âš«';
    
    // FIXED: Subtle dark backdrop for contrast without affecting emoji colors
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    this.ctx.beginPath();
    this.ctx.arc(0, 0, size * 0.75, 0, Math.PI * 2);
    this.ctx.fill();
    
    // FIXED: Strong dark shadow for depth
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    this.ctx.fillText(emoji, 2, 3);
    
    // REMOVED: White outline that was washing out colors
    // REMOVED: White fill that was making emojis bland
    
    // FIXED: Draw emoji with natural colors (no fill override)
    this.ctx.fillStyle = 'transparent'; // Let emoji render with native colors
    this.ctx.fillText(emoji, 0, 0);
}

/**
 * Get screen shake intensity by projectile type
 */
getShakeIntensity(projectileType) {
    const shakeMap = {
        tomato: 4,
        egg: 3,
        shoe: 8,
        bottle: 12,
        stone: 15,
        banana: 2,
        apple: 5
    };
    
    return shakeMap[projectileType] || 6;
}

/**
 * Darken color by factor
 */
darkenColor(color, factor) {
    if (color.startsWith('#')) {
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        
        return `rgb(${Math.floor(r * (1 - factor))}, ${Math.floor(g * (1 - factor))}, ${Math.floor(b * (1 - factor))})`;
    }
    return color;
}

    /**
 * Draw particles
 */
drawParticles() {
    // MOBILE: Skip all particle effects
    if (this.isMobile) {
        return;
    }

    this.drawTrailParticles();
    
    this.particles.forEach(particle => {
        this.ctx.save();
        this.ctx.globalAlpha = particle.alpha || (particle.life / 2.0);
        
        // ENHANCEMENTS:
        
        // Add glow effect for sparkle particles
        if (particle.sparkle || particle.type === 'sparkle') {
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = particle.twinkle ? 15 : 8;
        }
        
        this.ctx.fillStyle = particle.color;
        
        // Handle rotation for debris particles
        if (particle.rotation && particle.type === 'debris') {
            this.ctx.translate(particle.x, particle.y);
            this.ctx.rotate(particle.rotation);
            this.ctx.fillRect(-particle.size/2, -particle.size/2, particle.size, particle.size);
        } else {
            // Existing circle drawing
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        this.ctx.restore();
    });
}

    /**
     * Draw trail particles
     */
    drawTrailParticles() {
         // MOBILE: Skip trail particles
    if (this.isMobile) {
        return;
    }
    
        this.trailParticles.forEach(particle => {
            this.ctx.save();
            this.ctx.globalAlpha = particle.alpha;
            this.ctx.fillStyle = particle.color;
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = 8;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        });
    }

    /**
     * Draw visual effects
     */
    drawEffects() {
        // MOBILE: Skip all screen effects
    if (this.isMobile) {
        return;
    }
        // Slow motion effect
        if (this.activePowers.slowmo > 0) {
            this.ctx.save();
            this.ctx.globalAlpha = 0.3;
            this.ctx.fillStyle = '#4169E1';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.restore();
        }
        
        // Screen flash for hits
        if (this.cameraShake.intensity > 10) {
            this.ctx.save();
            this.ctx.globalAlpha = 0.2;
            this.ctx.fillStyle = '#FF0000';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.restore();
        }
    }
    /**
 * Set politician reaction based on projectile type
 */
setReactionForProjectile(projectileType) {
    const reactions = {
        tomato: { state: 'shocked', duration: 1500 },
        egg: { state: 'hit', duration: 1200 },
        shoe: { state: 'ducking', duration: 1800 },
        bottle: { state: 'hit', duration: 2000 },
        stone: { state: 'shocked', duration: 2500 },
        banana: { state: 'shocked', duration: 800 },
        apple: { state: 'hit', duration: 1000 }
    };
    
    const reaction = reactions[projectileType] || { state: 'hit', duration: 1000 };
    this.politician.reactionState = reaction.state;
    this.politician.reactionTimer = reaction.duration;
    
    console.log(`Politician reaction: ${reaction.state} for ${reaction.duration}ms`);
}
/**
 * Add stain to politician when hit
 */
addStainToPolitician(projectile) {
    // Calculate stain position relative to politician hitbox
    const hitX = projectile.x - this.politician.hitbox.x;
    const hitY = projectile.y - this.politician.hitbox.y;
    
   // Projectile-specific stain properties with natural colors
    const stainProperties = {
    tomato: { 
        size: 8, 
        type: 'splatter-drip',
        opacity: 0.85, 
        color: '#D22B2B'
    },
    egg: { 
        size: 10, 
        type: 'drip-drop',
        opacity: 0.9, 
        color: '#FFD700'
    },
    shoe: { 
        size: 7, 
        type: 'smudge-streak',
        opacity: 0.65, 
        color: '#4B3621'
    },
    bottle: { 
        size: 8, 
        type: 'splatter-ring',
        opacity: 0.7, 
        color: '#556B2F'
    },
    stone: { 
        size: 6, 
        type: 'smudge-blotch',
        opacity: 0.55, 
        color: '#2F4F4F'
    },
    banana: { 
        size: 9, 
        type: 'smudge-drip',
        opacity: 0.75, 
        color: '#DAA520'
    },
    apple: { 
        size: 7, 
        type: 'splatter-smudge',
        opacity: 0.8, 
        color: '#B22222'
    }
};
    
    const props = stainProperties[projectile.type] || { size: 10, type: 'splatter', opacity: 0.7, color: '#8B4513' };
    
    // Create stain spots
    const stainCount = projectile.type === 'tomato' || projectile.type === 'egg' ? 3 : 1;

for (let i = 0; i < stainCount; i++) {
    const baseX = hitX + (Math.random() - 0.5) * 20;
    const baseY = hitY + (Math.random() - 0.5) * 15;
    
    // Restrict to torso area only (center chest area)
    const torsoStartX = this.politician.hitbox.width * 0.2;   // 20% from left edge
    const torsoEndX = this.politician.hitbox.width * 0.8;     // 80% from left edge
    const clampedX = Math.max(torsoStartX, Math.min(torsoEndX, baseX));
    
    const torsoStartY = this.politician.hitbox.height * 0.1;  // 10% from top
    const torsoEndY = this.politician.hitbox.height * 0.4;    // 40% from top (upper torso only)
    const clampedY = Math.max(torsoStartY, Math.min(torsoEndY, baseY));
    
    const stain = {
        x: clampedX,
        y: clampedY,
        size: props.size + Math.random() * 3,
        color: props.color,
        type: props.type,
        opacity: props.opacity,
        age: 0
    };
    
    this.politician.stains.push(stain);
    console.log(`Added ${projectile.type} stain at (${stain.x}, ${stain.y})`);
}

// Limit total stains
if (this.politician.stains.length > 15) {
    this.politician.stains.splice(0, this.politician.stains.length - 15);
}
}

/**
 * Draw stains on politician
 */
drawPoliticianStains(politician) {
    this.ctx.save();
    
    politician.stains.forEach(stain => {
        // Add bounds validation
        const stainX = politician.hitbox.x + stain.x;
        const stainY = politician.hitbox.y + stain.y;

        // Skip stain if outside hitbox bounds
        if (stainX < politician.hitbox.x || 
            stainX > politician.hitbox.x + politician.hitbox.width ||
            stainY < politician.hitbox.y || 
            stainY > politician.hitbox.y + politician.hitbox.height) {
            return;
        }

        // Stain integration
        this.ctx.globalAlpha = stain.opacity;
        this.ctx.fillStyle = stain.color;
        
        const centerX = politician.hitbox.x + stain.x;
        const centerY = politician.hitbox.y + stain.y;

       
       // Updated switch with working methods
        switch(stain.type) {
             case 'splatter-drip':
                  this.drawSplatterDrip(centerX, centerY, stain.size);
             break;
        case 'drip-drop':
        case 'smudge-streak':
        case 'splatter-ring':
        case 'smudge-blotch':
        case 'smudge-drip':
        case 'splatter-smudge':
        case 'splatter':
        case 'drip':
        case 'smudge':
        default:
           this.drawRandomBlob(centerX, centerY, stain.size);
       }

        // WORKING FALLBACK - Simple irregular stain
        this.ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const radius = stain.size * (0.6 + Math.random() * 0.4);
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.closePath();
        this.ctx.fill();
        
        // Dark edge for depth
        this.ctx.globalAlpha = stain.opacity;
        this.ctx.strokeStyle = this.darkenColor(stain.color, 0.4);
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
    });
    
    this.ctx.restore();
}
drawRandomBlob(x, y, size) {
    this.ctx.beginPath();
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const radius = size * (0.4 + Math.random() * 0.4);
        const px = x + Math.cos(angle) * radius;
        const py = y + Math.sin(angle) * radius;
        if (i === 0) this.ctx.moveTo(px, py);
        else this.ctx.lineTo(px, py);
    }
    this.ctx.closePath();
    this.ctx.fill();
}
drawSplatterDrip(x, y, size) {
    // Central burst
    this.ctx.beginPath();
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const radius = size * (0.3 + Math.random() * 0.4);
        const px = x + Math.cos(angle) * radius;
        const py = y + Math.sin(angle) * radius;
        if (i === 0) this.ctx.moveTo(px, py);
        else this.ctx.lineTo(px, py);
    }
    this.ctx.closePath();
    this.ctx.fill();
    
    // Downward drips
    for (let i = 0; i < 2; i++) {
        const dripX = x + (Math.random() - 0.5) * size;
        const dripLength = size * (1.2 + Math.random() * 1);
        this.ctx.beginPath();
        this.ctx.ellipse(dripX, y + dripLength/2, size * 0.12, dripLength/2, 0, 0, Math.PI * 2);
        this.ctx.fill();
    }
}

    /**
     * Open Blinkit product page
     */
    openBlinkit() {
        const utmParams = new URLSearchParams({
            utm_source: 'stain_slayer_game',
            utm_medium: 'mobile_game',
            utm_campaign: 'fab_detergent_2025',
            utm_content: 'game_cta_button',
            utm_term: 'godrej_fab_purchase'
        });
        
        const blinkitUrl = `https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061?${utmParams.toString()}`;
        window.open(blinkitUrl, '_blank');
    }

    /**
     * Create trail particle
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} vx - X velocity
     * @param {number} vy - Y velocity
     */
   createTrailParticle(x, y, vx, vy) {
      // MOBILE: Skip ALL trail particle creation
    if (this.isMobile) return;

    
    const particle = {
        x: x,
        y: y,
        vx: vx * 0.3 + (Math.random() - 0.5) * 50,
        vy: vy * 0.3 + (Math.random() - 0.5) * 50,
        life: this.isMobile ? 0.3 : 0.8,        // Much shorter life on mobile
        maxLife: this.isMobile ? 0.3 : 0.8,
        size: this.isMobile ? 1 + Math.random() * 0.5 : 2 + Math.random() * 2, // Smaller particles
        alpha: 1.0,
        color: `hsl(${180 + Math.random() * 40}, 80%, ${60 + Math.random() * 20}%)`
    };
    
    this.trailParticles.push(particle);
    
    // Aggressive cleanup for mobile
    const maxParticles = this.mobileOptimizations ? this.mobileOptimizations.maxTrailParticles : 10;
    if (this.trailParticles.length > maxParticles) {
        this.trailParticles.splice(0, this.trailParticles.length - maxParticles);
    }
}

    // SPRITE SYSTEM METHODS

    /**
     * Initialize sprite system
     */
   initSpriteSystem() {
    // Enhanced mobile detection
    const userAgentMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const screenSizeMobile = window.innerWidth < 768;
    const touchDevice = 'ontouchstart' in window;
    const lowMemory = navigator.deviceMemory && navigator.deviceMemory < 4;
    
    this.isMobile = userAgentMobile || screenSizeMobile || touchDevice;
    this.isLowEndDevice = lowMemory || this.isMobile;
    
    // Unified sprite configuration - same for both mobile and desktop
    this.spriteConfigs = {
        politician: {
            src: 'https://assets.codepen.io/t-24779/politics-sprite-sheet-v2.png',
            frameWidth: 768,     // Correct: 1536Ã·2 = 768
            frameHeight: 1024,   // Correct: matches actual height
            totalFrames: 2,      // 2 frame only for Desktop (animation)
            layout: 'horizontal',
            scale: this.isMobile ? 0.7 : 1.0
        },
        aide: {
            src: 'https://assets.codepen.io/t-24779/aide_sprite_sheet_vertical.png',
            frameWidth: 128,     // Correct: matches actual sprite width
            frameHeight: 128,    
            totalFrames: 6,      // 6 frame only (animation)
            layout: 'vertical',
            scale: this.isMobile ? 1.0 : 1.5
        }
    };

    this.currentAnimations = {
        politician: { name: 'idle', frame: 0, timer: 0 },
        aide: { name: 'idle', frame: 0, timer: 0 }
    };

    this.spriteSystem = {
        loaded: false,
        images: {},
        animations: {},
        currentFrames: { politician: 0, aide: 0 } // Always use frame 0
    };

    console.log('Unified sprite system initialized:', {
        isMobile: this.isMobile,
        politicianFrameSize: `${this.spriteConfigs.politician.frameWidth}x${this.spriteConfigs.politician.frameHeight}`,
        aideFrameSize: `${this.spriteConfigs.aide.frameWidth}x${this.spriteConfigs.aide.frameHeight}`
    });

    this.loadSprites();
}
    /**
     * Load sprite images
     */
    loadSprites() {
        let loadedCount = 0;
        const totalSprites = Object.keys(this.spriteConfigs).length;

        Object.entries(this.spriteConfigs).forEach(([name, config]) => {
            const img = new Image();
            img.onload = () => {
                loadedCount++;
                this.debugLog('info', `Sprite loaded: ${name} (${img.width}x${img.height})`);
                if (loadedCount === totalSprites) {
                    this.spriteSystem.loaded = true;
                    this.debugLog('info', 'All sprites loaded successfully');
                    this.initializeCharacterAnimations();
                }
            };
            img.onerror = () => {
                this.debugLog('error', `Failed to load sprite: ${name} from ${config.src}`);
            };
            img.src = config.src;
            this.spriteSystem.images[name] = img;
        });
    }

    /**
     * Draw character sprite
     * @param {string} spriteName - Sprite name
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width
     * @param {number} height - Height
     * @param {string} animation - Animation name
     * @returns {boolean} Success status
     */
  drawCharacterSprite(spriteName, x, y, width, height, animation = 'idle') {
    const image = this.spriteSystem.images[spriteName];
    const config = this.spriteConfigs[spriteName];
    
    if (!image || !config) {
        return false;
    }

    let frameIndex = this.spriteSystem.currentFrames[spriteName] || 0;

    const frameWidth = config.frameWidth;
    const frameHeight = config.frameHeight;
    
    let frameX = 0;
    let frameY = 0;
    
    if (config.layout === 'horizontal') {
        frameX = frameIndex * frameWidth;
        frameY = 0;
    } else if (config.layout === 'vertical') {
        frameX = 0;
        frameY = frameIndex * frameHeight;
    }

    // FIXED: Apply scaling for both mobile and desktop
        const renderWidth = width * (config.scale || 1.0);
        const renderHeight = height * (config.scale || 1.0);

    this.ctx.save();
    
    try {
        // Handle sprite flipping for aide
        if (spriteName === 'aide' && this.aide.spriteFlipped) {
            this.ctx.translate(x + renderWidth, y);
            this.ctx.scale(-1, 1);
            this.ctx.drawImage(
                image,
                frameX, frameY, frameWidth, frameHeight,
                0, 0, renderWidth, renderHeight
            );
        } else {
            this.ctx.drawImage(
                image,
                frameX, frameY, frameWidth, frameHeight,
                x, y, renderWidth, renderHeight
            );
        }
        
        this.ctx.restore();
        return true;
        
    } catch (error) {
        console.warn(`Sprite rendering error for ${spriteName}:`, error);
        this.ctx.restore();
        return false;
    }
}

    /**
     * Extract sprite frames from image
     * @param {string} imageName - Image name
     * @param {number} frameWidth - Frame width
     * @param {number} frameHeight - Frame height
     * @param {number} totalFrames - Total frames
     * @param {string} layout - Layout type
     * @returns {Array} Frame array
     */
    extractSpriteFrames(imageName, frameWidth, frameHeight, totalFrames, layout = 'horizontal') {
    const image = this.spriteSystem.images[imageName];
    if (!image) return [];
    
    const frames = [];
    
    // Mobile: Extract only first frame
    if (this.isMobile) {
        frames.push({
            x: 0,
            y: 0,
            width: frameWidth,
            height: frameHeight
        });
        return frames;
    }
    
    // Desktop: Extract all frames (your existing logic)
    if (layout === 'horizontal') {
        for (let i = 0; i < totalFrames; i++) {
            frames.push({
                x: i * frameWidth,
                y: 0,
                width: frameWidth,
                height: frameHeight
            });
        }
    } else if (layout === 'vertical') {
        for (let i = 0; i < totalFrames; i++) {
            frames.push({
                x: 0,
                y: i * frameHeight,
                width: frameWidth,
                height: frameHeight
            });
        }
    }
    
    return frames;
}

    /**
     * Initialize character animations
     */
    initializeCharacterAnimations() {
        if (!this.spriteSystem.loaded) return;
        
        const politicianConfig = this.spriteConfigs.politician;
        const politicianFrames = this.extractSpriteFrames(
            'politician', 
            politicianConfig.frameWidth,
            politicianConfig.frameHeight,
            politicianConfig.totalFrames, 
            politicianConfig.layout
        );
        
        this.spriteSystem.animations.politician = {
            idle: politicianFrames,
            excited: politicianFrames,
            dodge: politicianFrames,
            panicked: politicianFrames,
            critical: politicianFrames
        };
        
        const aideFrames = this.extractSpriteFrames(
            'aide', 512, 600, 4, 'vertical'
        );
        
        this.spriteSystem.animations.aide = {
            idle: aideFrames,
            shield_side: aideFrames,
            shield_up: aideFrames,
            crouch_cover: aideFrames,
            swat_down: aideFrames,
            worried: aideFrames,
            focused: aideFrames,
            walking: aideFrames,
            victory: aideFrames
        };
        
        this.spriteSystem.currentFrames = {
            politician: 0,
            aide: 0
        };
    }

 /**
 * Update character animations
 * @param {number} deltaTime - Time delta
 */
updateCharacterAnimations(deltaTime = 0.016) {
    const isDesktop = this.gameWidth >= 768;
    
    // POLITICIAN ANIMATION
    if (isDesktop) {
        // Desktop: Enable frame cycling for politician animation
        if (!this.politician.animationTimer) this.politician.animationTimer = 0;
        this.politician.animationTimer += deltaTime * 1000;
        
        const frameInterval = 400;
        const currentFrame = Math.floor(this.politician.animationTimer / frameInterval) % 2;
        
        if (this.politicianHealth < 25) {
            this.politician.expression = 'critical';
            this.spriteSystem.currentFrames.politician = currentFrame;
        } else if (this.politicianHealth < 50) {
            this.politician.expression = 'worried';
            this.spriteSystem.currentFrames.politician = currentFrame;
        } else if (this.projectiles.length > 3) {
            this.politician.expression = 'nervous';
            this.spriteSystem.currentFrames.politician = currentFrame;
        } else {
            this.politician.expression = 'speaking';
            this.spriteSystem.currentFrames.politician = currentFrame;
        }
    } else {
        // Mobile: Keep politician static
        this.spriteSystem.currentFrames.politician = 0;
        if (this.politicianHealth < 50) {
            this.politician.expression = 'worried';
        } else {
            this.politician.expression = 'speaking';
        }
    }
    
    // AIDE ANIMATION - FIXED: Single logic for both mobile and desktop
    if (!this.aide.animationTimer) this.aide.animationTimer = 0;
    this.aide.animationTimer += deltaTime * 1000;
    
    if (isDesktop) {
        // Desktop: 6-frame animation
        const frameInterval = 600;
        const currentFrame = Math.floor(this.aide.animationTimer / frameInterval) % 6;
        this.spriteSystem.currentFrames.aide = currentFrame;
        console.log("Desktop aide frame:", currentFrame);
    } else {
        // Mobile: 2-frame animation
        const frameInterval = 800;
        const currentFrame = Math.floor(this.aide.animationTimer / frameInterval) % 2;
        this.spriteSystem.currentFrames.aide = currentFrame;
        console.log("Mobile aide frame:", currentFrame);
    }
    
    // Set aide expression
    if (this.aide.shield) {
        this.aide.expression = 'focused';
    } else if (this.projectiles.length > 3) {
        this.aide.expression = 'worried';
    } else {
        this.aide.expression = 'determined';
    }
}

    /**
     * Optimize rendering performance
     * @returns {boolean} Should render this frame
     */
    optimizeRenderingPerformance() {
        const now = performance.now();
        if (now - this.lastFrameTime < 16.67) return false;
        this.lastFrameTime = now;
        return true;
    }
}

// Add this debug function before the Product3DViewer class
function debug3DViewer(action, details = '') {
    console.log(`[3D DEBUG] ${new Date().toISOString().substr(11, 12)} - ${action} - ${details}`);
}

/**
 * 3D Product Viewer for Fab refill pack - Front & Back views only
 */
class Product3DViewer {
    constructor(canvasId, containerId) {
        debug3DViewer('CONSTRUCTOR_START', `canvasId: ${canvasId}, containerId: ${containerId}`);
        
        if (typeof THREE === 'undefined') {
            debug3DViewer('ERROR', 'THREE.js is not available');
            console.error('THREE.js is not available');
            return;
        }
        
        this.canvas = document.getElementById(canvasId);
        this.container = document.getElementById(containerId);
        
        debug3DViewer('ELEMENT_CHECK', `canvas: ${!!this.canvas}, container: ${!!this.container}`);
        
        if (!this.canvas) {
            debug3DViewer('ERROR', `Canvas element '${canvasId}' not found in DOM`);
            console.error(`3D viewer canvas or container not found - Canvas '${canvasId}' missing`);
            return;
        }
        
        if (!this.container) {
            debug3DViewer('ERROR', `Container element '${containerId}' not found in DOM`);
            console.error(`3D viewer canvas or container not found - Container '${containerId}' missing`);
            return;
        }
        
        // Check if elements are attached to DOM
        if (!document.body.contains(this.canvas)) {
            debug3DViewer('ERROR', 'Canvas element not attached to DOM');
            console.error('3D viewer canvas or container not found - Canvas not attached to DOM');
            return;
        }
        
        if (!document.body.contains(this.container)) {
            debug3DViewer('ERROR', 'Container element not attached to DOM');
            console.error('3D viewer canvas or container not found - Container not attached to DOM');
            return;
        }
        
        // Check visibility
        const containerRect = this.container.getBoundingClientRect();
        debug3DViewer('DIMENSIONS', `width: ${containerRect.width}, height: ${containerRect.height}`);
        
        if (containerRect.width === 0 || containerRect.height === 0) {
            debug3DViewer('ERROR', 'Container has zero dimensions');
            console.error('3D viewer canvas or container not found - Container has zero dimensions');
            return;
        }
        
        debug3DViewer('SUCCESS', 'All validation checks passed, proceeding with initialization');
        
        // Rest of your existing constructor code...
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.productPlane = null;
        this.isMouseDown = false;
        this.mouseX = 0;
        this.rotationY = 0;
        this.targetRotationY = 0;
        this.frontTexture = null;
        this.backTexture = null;
        this.texturesLoaded = false;
        
        this.loadTextures().then(() => {
            this.init();
        });
    }
    
    async loadTextures() {
        const textureLoader = new THREE.TextureLoader();
        
        try {
            const [front, back] = await Promise.all([
                this.loadSingleTexture(textureLoader, 'https://assets.codepen.io/t-24779/fab-front-view-image.png'),
                this.loadSingleTexture(textureLoader, 'https://assets.codepen.io/t-24779/fab-back-side-view.png')
            ]);
            
            this.frontTexture = front;
            this.backTexture = back;
            this.texturesLoaded = true;
            console.log('Front and back textures loaded successfully');
        } catch (error) {
            console.warn('Failed to load textures:', error);
            this.texturesLoaded = false;
        }
    }
    
    loadSingleTexture(loader, url) {
        return new Promise((resolve, reject) => {
            loader.load(
                url,
                (texture) => {
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    resolve(texture);
                },
                undefined,
                reject
            );
        });
    }
    
    init() {
        this.setupScene();
        this.createProduct();
        this.setupLighting();
        this.setupControls();
        this.animate();
        
        console.log('3D Product Viewer initialized - Front & Back only');
    }
    
    setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = null;
        
        this.camera = new THREE.PerspectiveCamera(
            50, 
            this.container.offsetWidth / this.container.offsetHeight, 
            0.1, 
            1000
        );
        this.camera.position.set(0, 0, 4);
        
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas,
            antialias: true,
            alpha: true
        });
        this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
    }
    
    createProduct() {
        if (!this.texturesLoaded) {
            console.warn('Textures not loaded, using fallback');
            this.createFallbackProduct();
            return;
        }
        
        // Create geometry for the product plane
        const planeGeometry = new THREE.PlaneGeometry(2.5, 3.2);
        
        // Create shader material that switches between textures based on viewing angle
        const material = new THREE.ShaderMaterial({
            uniforms: {
                frontTexture: { value: this.frontTexture },
                backTexture: { value: this.backTexture },
                cameraPosition: { value: this.camera.position }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vViewDirection;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewDirection = normalize(-modelViewPosition.xyz);
                    gl_Position = projectionMatrix * modelViewPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D frontTexture;
                uniform sampler2D backTexture;
                varying vec3 vNormal;
                varying vec3 vViewDirection;
                
                void main() {
                    vec2 uv = gl_PointCoord;
                    
                    // Use UV coordinates from vertex shader
                    uv = vec2(gl_FragCoord.x / 1024.0, gl_FragCoord.y / 1024.0);
                    
                    // Determine which texture to use based on normal direction
                    float facing = dot(vNormal, vViewDirection);
                    
                    vec4 frontColor = texture2D(frontTexture, uv);
                    vec4 backColor = texture2D(backTexture, uv);
                    
                    // Blend between front and back based on viewing angle
                    gl_FragColor = mix(backColor, frontColor, smoothstep(-0.1, 0.1, facing));
                }
            `,
            side: THREE.DoubleSide,
            transparent: true
        });
        
        // Fallback to simpler approach if shaders are complex
        this.createSimpleDoubleSided();
    }
    
    createSimpleDoubleSided() {
        const planeGeometry = new THREE.PlaneGeometry(2.5, 3.2);
        
        // Create a group to hold front and back planes
        this.productPlane = new THREE.Group();
        
        // Front plane
        const frontMaterial = new THREE.MeshBasicMaterial({
            map: this.frontTexture,
            transparent: true,
            side: THREE.FrontSide
        });
        
        const frontPlane = new THREE.Mesh(planeGeometry, frontMaterial);
        frontPlane.position.z = 0.001; // Slight offset to prevent z-fighting
        this.productPlane.add(frontPlane);
        
        // Back plane
        const backMaterial = new THREE.MeshBasicMaterial({
            map: this.backTexture,
            transparent: true,
            side: THREE.BackSide
        });
        
        const backPlane = new THREE.Mesh(planeGeometry, backMaterial);
        backPlane.position.z = -0.001; // Slight offset to prevent z-fighting
        backPlane.scale.x = -1; 
        this.productPlane.add(backPlane);
        
        this.scene.add(this.productPlane);
    }
    
    createFallbackProduct() {
        const planeGeometry = new THREE.PlaneGeometry(2.5, 3.2);
        
        const frontMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00A859, 
            transparent: true, 
            opacity: 0.8 
        });
        
        this.productPlane = new THREE.Mesh(planeGeometry, frontMaterial);
        this.scene.add(this.productPlane);
    }
    
    setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(1, 1, 1);
        this.scene.add(directionalLight);
    }
    
    setupControls() {
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.onMouseUp());
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
        
        this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
        this.canvas.addEventListener('touchend', () => this.onTouchEnd());
        
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        window.addEventListener('resize', () => this.onResize());
    }
    
    onMouseDown(event) {
        this.isMouseDown = true;
        this.mouseX = event.clientX;
    }
    
    onMouseMove(event) {
        if (!this.isMouseDown) return;
        
        const deltaX = event.clientX - this.mouseX;
        const deltaY = event.clientY - this.mouseY;
        this.targetRotationY += deltaX * 0.08;
       
     if (!this.targetRotationX) this.targetRotationX = 0;
        this.targetRotationX += deltaY * 0.01;
        this.targetRotationX = Math.max(-Math.PI/6, Math.min(Math.PI/6, this.targetRotationX));
    
        this.mouseX = event.clientX;
        this.mouseY = event.clientY; 
    }
    
    onMouseUp() {
        this.isMouseDown = false;
    }
    
    onTouchStart(event) {
        event.preventDefault();
        if (event.touches.length === 1) {
            this.isMouseDown = true;
            this.mouseX = event.touches[0].clientX;
        }
    }
    
    onTouchMove(event) {
        event.preventDefault();
        if (!this.isMouseDown || event.touches.length !== 1) return;
        
        const deltaX = event.touches[0].clientX - this.mouseX;
        this.targetRotationY += deltaX * 0.02;
        this.mouseX = event.touches[0].clientX;
    }
    
    onTouchEnd() {
        this.isMouseDown = false;
    }
    
    onWheel(event) {
        event.preventDefault();
        const zoom = event.deltaY * 0.002;
        this.camera.position.z = Math.max(2.5, Math.min(6, this.camera.position.z + zoom));
    }
    
    onResize() {
    if (!this.container) return;
    
    // Get the fixed container dimensions
    const containerWidth = this.container.offsetWidth;
    const containerHeight = this.container.offsetHeight;
    
    this.camera.aspect = containerWidth / containerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(containerWidth, containerHeight);
    
    // Reset any scaling issues with responsive scaling
    if (this.productPlane) {
        const isMobile = containerWidth < 280;
        const scale = isMobile ? 0.8 : 1.0;
        this.productPlane.scale.set(scale, scale, scale);
    }
}
    
   animate() {
    // Check if viewer has been destroyed
    if (!this.renderer || !this.scene || !this.camera) {
        return; // Stop animation loop if destroyed
    }
    
    requestAnimationFrame(() => this.animate());
    
    if (this.productPlane) {
        // Smooth rotation interpolation
        this.rotationY += (this.targetRotationY - this.rotationY) * 0.1;
        this.productPlane.rotation.y = this.rotationY;
        
        // Add vertical rotation support
        if (this.targetRotationX !== undefined) {
            if (!this.rotationX) this.rotationX = 0;
            this.rotationX += (this.targetRotationX - this.rotationX) * 0.1;
            this.productPlane.rotation.x = this.rotationX;
        }
        
        // Gentle idle rotation when not interacting
        if (!this.isMouseDown) {
            this.productPlane.rotation.y += 0.08;
            this.targetRotationY = this.productPlane.rotation.y;
        }
    }
    
    // Error handling for WebGL rendering
    try {
        if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    } catch (error) {
        console.warn('3D viewer render error (non-critical):', error.message);
        // Track error count to prevent infinite error loops
        this.errorCount = (this.errorCount || 0) + 1;
        
        // If too many errors occur, disable the 3D viewer
        if (this.errorCount > 5) { // Reduced threshold
            console.warn('Too many 3D viewer errors, disabling...');
            this.destroy();
            return;
        }
    }
}
    
   destroy() {
    console.log('Destroying 3D Product Viewer...');
    
    // Stop animation loop
    this.isDestroyed = true;
    
    if (this.renderer) {
        this.renderer.dispose();
        this.renderer.domElement.remove();
        this.renderer = null;
    }
    
    if (this.frontTexture) {
        this.frontTexture.dispose();
        this.frontTexture = null;
    }
    
    if (this.backTexture) {
        this.backTexture.dispose();
        this.backTexture = null;
    }
    
    if (this.scene) {
        this.scene.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(material => material.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
        this.scene = null;
    }
    
    this.camera = null;
    this.productPlane = null;
    this.container = null;
    this.canvas = null;
}
}

/**
 * Stain Slayer Game Analytics System
 */
class StainSlayerAnalytics {
    constructor(gameInstance) {
        this.game = gameInstance;
        this.sessionData = this.initializeSession();
        this.performanceMetrics = this.initializePerformanceTracking();
        this.projectileAnalytics = [];
        this.reactionTimeData = [];
        this.defensePatterns = [];
        this.streakAnalytics = {
            currentStreak: 0,
            bestStreak: 0,
            streakHistory: []
        };
        
        console.log("ðŸŽ¯ Stain Slayer Analytics initialized");
    }

    initializeSession() {
        return {
            sessionId: this.generateSessionId(),
            gameStartTime: Date.now(),
            playerActions: [],
            waveProgression: [],
            healthEvents: [],
            powerUpUsage: {
                shield: { used: 0, effectiveness: [] },
                slowmo: { used: 0, effectiveness: [] },
                speed: { used: 0, effectiveness: [] }
            }
        };
    }

    initializePerformanceTracking() {
        return {
            frameRateHistory: [],
            inputLatency: [],
            renderingPerformance: {
                particleCount: [],
                projectileCount: [],
                frameDrops: 0
            }
        };
    }

    generateSessionId() {
        return `SS_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    // Track projectile spawn and lifecycle
    trackProjectileSpawn(projectile) {
        const projectileData = {
            id: `proj_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            type: projectile.type,
            spawnTime: Date.now(),
            spawnPosition: { x: projectile.x, y: projectile.y },
            threatLevel: projectile.threatLevel,
            damage: projectile.damage,
            size: projectile.size,
            outcome: null, // Will be set when resolved
            reactionTime: null,
            defenseMethod: null
        };

        this.projectileAnalytics.push(projectileData);
        return projectileData.id;
    }

    // Track projectile defense/hit resolution
    trackProjectileResolution(projectileId, outcome, defenseMethod = null) {
        const projectileData = this.projectileAnalytics.find(p => p.id === projectileId);
        if (!projectileData) return;

        const resolutionTime = Date.now();
        const reactionTime = resolutionTime - projectileData.spawnTime;

        projectileData.outcome = outcome; // 'blocked', 'hit_politician', 'missed'
        projectileData.reactionTime = reactionTime;
        projectileData.defenseMethod = defenseMethod;

        // Update streak tracking
        if (outcome === 'blocked') {
            this.streakAnalytics.currentStreak++;
            this.streakAnalytics.bestStreak = Math.max(
                this.streakAnalytics.bestStreak, 
                this.streakAnalytics.currentStreak
            );
        } else if (outcome === 'hit_politician') {
            if (this.streakAnalytics.currentStreak > 0) {
                this.streakAnalytics.streakHistory.push(this.streakAnalytics.currentStreak);
            }
            this.streakAnalytics.currentStreak = 0;
        }

        // Record reaction time for performance analysis
        this.reactionTimeData.push({
            time: reactionTime,
            projectileType: projectileData.type,
            threatLevel: projectileData.threatLevel,
            outcome: outcome
        });
    }

    // Track player movement and positioning
    trackPlayerMovement(aidePosition, timestamp = Date.now()) {
        this.defensePatterns.push({
            timestamp: timestamp,
            position: { x: aidePosition.x, y: aidePosition.y },
            facing: aidePosition.facingDirection,
            activeShield: aidePosition.shield,
            expression: aidePosition.expression
        });

        // Keep only last 100 movement records to manage memory
        if (this.defensePatterns.length > 100) {
            this.defensePatterns.shift();
        }
    }

    // Track power-up usage and effectiveness
    trackPowerUpUsage(powerType, effectivenessScore = null) {
        const usage = this.sessionData.powerUpUsage[powerType];
        if (usage) {
            usage.used++;
            if (effectivenessScore !== null) {
                usage.effectiveness.push({
                    timestamp: Date.now(),
                    score: effectivenessScore,
                    gameContext: {
                        activeProjectiles: this.game.projectiles.length,
                        politicianHealth: this.game.politicianHealth,
                        currentWave: this.game.wave,
                        currentLevel: this.game.level
                    }
                });
            }
        }
    }

    // Track health events (damage taken, close calls)
    trackHealthEvent(eventType, damage = 0, projectileType = null) {
        this.sessionData.healthEvents.push({
            timestamp: Date.now(),
            eventType: eventType, // 'damage_taken', 'close_call', 'critical_health'
            damage: damage,
            projectileType: projectileType,
            healthBefore: this.game.politicianHealth + damage,
            healthAfter: this.game.politicianHealth,
            gameContext: {
                wave: this.game.wave,
                level: this.game.level,
                activeProjectiles: this.game.projectiles.length
            }
        });
    }

    // Track wave progression and difficulty scaling
    trackWaveCompletion(waveNumber, levelNumber, performance) {
        this.sessionData.waveProgression.push({
            wave: waveNumber,
            level: levelNumber,
            completionTime: Date.now(),
            performance: {
                projectilesBlocked: performance.blocked || 0,
                projectilesMissed: performance.missed || 0,
                healthRemaining: this.game.politicianHealth,
                scoreGained: performance.scoreGained || 0,
                accuracyRate: performance.accuracy || 0
            },
            difficultyMetrics: {
                spawnRate: this.game.projectileSpawnRate,
                projectileSpeed: performance.avgProjectileSpeed || 0,
                threatDistribution: performance.threatLevels || {}
            }
        });
    }

    // Performance monitoring
    trackPerformanceMetrics(frameRate, inputLatency) {
        this.performanceMetrics.frameRateHistory.push({
            timestamp: Date.now(),
            fps: frameRate
        });

        if (inputLatency) {
            this.performanceMetrics.inputLatency.push(inputLatency);
        }

        // Track rendering load
        this.performanceMetrics.renderingPerformance.particleCount.push(
            this.game.particles.length + this.game.trailParticles.length
        );
        this.performanceMetrics.renderingPerformance.projectileCount.push(
            this.game.projectiles.length
        );

        // Detect frame drops
        if (frameRate < 45) {
            this.performanceMetrics.renderingPerformance.frameDrops++;
        }

        // Keep performance history manageable
        const maxHistory = 300; // ~5 minutes at 60fps
        if (this.performanceMetrics.frameRateHistory.length > maxHistory) {
            this.performanceMetrics.frameRateHistory.shift();
        }
    }

    // Calculate comprehensive analytics
    calculateSessionAnalytics() {
        const sessionDuration = Date.now() - this.sessionData.gameStartTime;
        const totalProjectiles = this.projectileAnalytics.length;
        const blockedProjectiles = this.projectileAnalytics.filter(p => p.outcome === 'blocked').length;
        const hitProjectiles = this.projectileAnalytics.filter(p => p.outcome === 'hit_politician').length;

        return {
            session: {
                sessionId: this.sessionData.sessionId,
                duration: sessionDuration,
                gameEndTime: new Date().toISOString(),
                finalScore: this.game.score,
                finalLevel: this.game.level,
                finalWave: this.game.wave,
                survivedWaves: this.game.survivedWaves
            },
            
            combat: {
                totalProjectiles: totalProjectiles,
                projectilesBlocked: blockedProjectiles,
                projectilesHit: hitProjectiles,
                accuracy: totalProjectiles > 0 ? (blockedProjectiles / totalProjectiles * 100).toFixed(1) : 0,
                bestDefenseStreak: this.streakAnalytics.bestStreak,
                averageReactionTime: this.calculateAverageReactionTime(),
                defenseEfficiency: this.calculateDefenseEfficiency()
            },

            health: {
                finalHealth: this.game.politicianHealth,
                healthLost: 100 - this.game.politicianHealth,
                damageEvents: this.sessionData.healthEvents.filter(e => e.eventType === 'damage_taken').length,
                closeCalls: this.sessionData.healthEvents.filter(e => e.eventType === 'close_call').length,
                criticalMoments: this.sessionData.healthEvents.filter(e => e.eventType === 'critical_health').length
            },

            powerUps: {
                shieldUsage: this.sessionData.powerUpUsage.shield.used,
                slowmoUsage: this.sessionData.powerUpUsage.slowmo.used,
                speedUsage: this.sessionData.powerUpUsage.speed.used,
                overallEffectiveness: this.calculatePowerUpEffectiveness()
            },

            projectileBreakdown: this.analyzeProjectileTypes(),
            
            performance: {
                averageFPS: this.calculateAverageFPS(),
                frameDrops: this.performanceMetrics.renderingPerformance.frameDrops,
                averageInputLatency: this.calculateAverageInputLatency(),
                peakComplexity: this.calculatePeakComplexity()
            },

            gameplayPatterns: {
                favoriteDefensePosition: this.calculateFavoritePosition(),
                movementStyle: this.analyzeMovementStyle(),
                threatPrioritization: this.analyzeThreatPrioritization()
            }
        };
    }

    // Helper calculation methods
    calculateAverageReactionTime() {
        if (this.reactionTimeData.length === 0) return 0;
        const sum = this.reactionTimeData.reduce((acc, data) => acc + data.time, 0);
        return Math.round(sum / this.reactionTimeData.length);
    }

    calculateDefenseEfficiency() {
        const shieldBlocks = this.projectileAnalytics.filter(p => 
            p.outcome === 'blocked' && p.defenseMethod === 'shield'
        ).length;
        
        const totalShieldUse = this.sessionData.powerUpUsage.shield.used;
        
        return totalShieldUse > 0 ? (shieldBlocks / totalShieldUse).toFixed(2) : 0;
    }

    calculatePowerUpEffectiveness() {
        const allEffectiveness = [];
        Object.values(this.sessionData.powerUpUsage).forEach(powerUp => {
            powerUp.effectiveness.forEach(eff => allEffectiveness.push(eff.score));
        });
        
        if (allEffectiveness.length === 0) return 0;
        const sum = allEffectiveness.reduce((acc, score) => acc + score, 0);
        return (sum / allEffectiveness.length).toFixed(1);
    }

    analyzeProjectileTypes() {
        const typeAnalysis = {};
        this.projectileAnalytics.forEach(proj => {
            if (!typeAnalysis[proj.type]) {
                typeAnalysis[proj.type] = {
                    total: 0,
                    blocked: 0,
                    hit: 0,
                    avgReactionTime: 0,
                    threatLevel: proj.threatLevel
                };
            }
            
            typeAnalysis[proj.type].total++;
            if (proj.outcome === 'blocked') typeAnalysis[proj.type].blocked++;
            if (proj.outcome === 'hit_politician') typeAnalysis[proj.type].hit++;
        });

        // Calculate accuracy for each type
        Object.keys(typeAnalysis).forEach(type => {
            const data = typeAnalysis[type];
            data.accuracy = data.total > 0 ? ((data.blocked / data.total) * 100).toFixed(1) : 0;
            
            // Calculate average reaction time for this type
            const typeReactions = this.reactionTimeData.filter(r => r.projectileType === type);
            if (typeReactions.length > 0) {
                const sum = typeReactions.reduce((acc, r) => acc + r.time, 0);
                data.avgReactionTime = Math.round(sum / typeReactions.length);
            }
        });

        return typeAnalysis;
    }

    calculateAverageFPS() {
        if (this.performanceMetrics.frameRateHistory.length === 0) return 60;
        const sum = this.performanceMetrics.frameRateHistory.reduce((acc, frame) => acc + frame.fps, 0);
        return Math.round(sum / this.performanceMetrics.frameRateHistory.length);
    }

    calculateAverageInputLatency() {
        if (this.performanceMetrics.inputLatency.length === 0) return 0;
        const sum = this.performanceMetrics.inputLatency.reduce((acc, latency) => acc + latency, 0);
        return Math.round(sum / this.performanceMetrics.inputLatency.length);
    }

    calculatePeakComplexity() {
        const maxParticles = Math.max(...this.performanceMetrics.renderingPerformance.particleCount, 0);
        const maxProjectiles = Math.max(...this.performanceMetrics.renderingPerformance.projectileCount, 0);
        return { maxParticles, maxProjectiles };
    }

    calculateFavoritePosition() {
        if (this.defensePatterns.length === 0) return { x: 0, y: 0 };
        
        const sumX = this.defensePatterns.reduce((acc, pattern) => acc + pattern.position.x, 0);
        const sumY = this.defensePatterns.reduce((acc, pattern) => acc + pattern.position.y, 0);
        
        return {
            x: Math.round(sumX / this.defensePatterns.length),
            y: Math.round(sumY / this.defensePatterns.length)
        };
    }

    analyzeMovementStyle() {
        if (this.defensePatterns.length < 10) return 'insufficient_data';
        
        const movements = this.defensePatterns.slice(1).map((pattern, index) => {
            const prev = this.defensePatterns[index];
            return {
                distance: Math.sqrt(
                    Math.pow(pattern.position.x - prev.position.x, 2) + 
                    Math.pow(pattern.position.y - prev.position.y, 2)
                ),
                time: pattern.timestamp - prev.timestamp
            };
        });

        const avgMovement = movements.reduce((acc, move) => acc + move.distance, 0) / movements.length;
        
        if (avgMovement < 5) return 'stationary';
        if (avgMovement < 15) return 'conservative';
        if (avgMovement < 30) return 'active';
        return 'highly_mobile';
    }

    analyzeThreatPrioritization() {
        const threatResponses = this.reactionTimeData.reduce((acc, reaction) => {
            if (!acc[reaction.threatLevel]) {
                acc[reaction.threatLevel] = [];
            }
            acc[reaction.threatLevel].push(reaction.time);
            return acc;
        }, {});

        const prioritization = {};
        Object.keys(threatResponses).forEach(level => {
            const times = threatResponses[level];
            const avgTime = times.reduce((acc, time) => acc + time, 0) / times.length;
            prioritization[level] = Math.round(avgTime);
        });

        return prioritization;
    }

    // Export analytics for external use
    exportAnalytics(format = 'json') {
        const analytics = this.calculateSessionAnalytics();
        
        if (format === 'json') {
            return JSON.stringify(analytics, null, 2);
        } else if (format === 'csv') {
            return this.convertToCSV(analytics);
        }
        
        return analytics;
    }

    convertToCSV(analytics) {
        // Convert key metrics to CSV format
        const csvLines = [
            'Metric,Value',
            `Session Duration,${analytics.session.duration}`,
            `Final Score,${analytics.session.finalScore}`,
            `Accuracy,${analytics.combat.accuracy}%`,
            `Projectiles Blocked,${analytics.combat.projectilesBlocked}`,
            `Best Streak,${analytics.combat.bestDefenseStreak}`,
            `Average Reaction Time,${analytics.combat.averageReactionTime}ms`,
            `Final Health,${analytics.health.finalHealth}`,
            `Shield Usage,${analytics.powerUps.shieldUsage}`,
            `Average FPS,${analytics.performance.averageFPS}`
        ];
        
        return csvLines.join('\n');
    }

    // Reset analytics for new session
    resetAnalytics() {
        this.sessionData = this.initializeSession();
        this.performanceMetrics = this.initializePerformanceTracking();
        this.projectileAnalytics = [];
        this.reactionTimeData = [];
        this.defensePatterns = [];
        this.streakAnalytics = {
            currentStreak: 0,
            bestStreak: 0,
            streakHistory: []
        };
        
        console.log("ðŸŽ¯ Analytics reset for new session");
    }
}

// GLOBAL UTILITY FUNCTIONS

/**
 * Generate QR code with game score
 */
function generateQRCode() {
    try {
        console.log("ðŸŽ¯ Generating QR code...");
        
        const qrDiv = document.getElementById('qrCode');
        if (!qrDiv || typeof QRious === 'undefined') {
            console.log("ðŸŽ¯ QR code generation failed - missing elements");
            return;
        }
        
        qrDiv.innerHTML = '';
        const canvas = document.createElement('canvas');
        qrDiv.appendChild(canvas);
        
        // Use the actual game score from the game instance
        const gameScore = window.game ? window.game.score : 0;
        const utmParams = new URLSearchParams({
            utm_source: 'stain_slayer_qr',
            utm_medium: 'qr_code',
            utm_campaign: 'fab_detergent_2025',
            utm_content: 'results_qr',
            utm_term: 'godrej_fab_purchase',
            score: gameScore
        });
        
        new QRious({
            element: canvas,
            value: `https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061?${utmParams.toString()}`,
            size: 90, 
            background: '#ffffff',
            foreground: '#000000',
            level: 'H'
        });
        
        console.log(`QR code generated with score: ${gameScore}`);
    } catch (error) {
        console.error('QR Code generation failed:', error);
        // Fallback display
        const qrDiv = document.getElementById('qrCode');
        if (qrDiv) {
            qrDiv.innerHTML = '<div style="font-size: 0.7em; color: #666;">QR<br>Code<br>Error</div>';
        }
    }
}

/**
 * Save game code to clipboard
 */
function saveGameCode() {
    try {
        const qrCanvas = document.querySelector('#qrCode canvas');
        if (!qrCanvas) {
            alert('QR code not found. Please wait for it to load.');
            return;
        }

        // Create download link
        const link = document.createElement('a');
        link.download = `FAB-Stain-Slayer-QR-Score-${window.game ? window.game.score : 0}.png`;
        link.href = qrCanvas.toDataURL('image/png');
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        alert('QR code downloaded successfully!');
    } catch (error) {
        console.error('Download failed:', error);
        // Fallback to text code
        const gameCode = `FAB-${Math.random().toString(36).substr(2, 8).toUpperCase()}`;
        alert(`Download failed. Your game code: ${gameCode}`);
    }
}

/**
 * Open Fab product purchase page
 */
function buyFabProduct() {
    const utmParams = new URLSearchParams({
        utm_source: 'stain_slayer_results',
        utm_medium: 'mobile_game',
        utm_campaign: 'fab_detergent_2025',
        utm_content: 'buy_fab_button',
        utm_term: 'godrej_fab_purchase'
    });
    
    const blinkitUrl = `https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061?${utmParams.toString()}`;
    window.open(blinkitUrl, '_blank');
}

/**
 * Share game results on WhatsApp
 */
/**
 * Share game results on WhatsApp
 */
function shareOnWhatsApp() {
    const finalScore = document.getElementById('finalScore')?.textContent || '0';
    const blockedCount = document.getElementById('blockedCount')?.textContent || '0';
    
    // 8 Array integrated
    const messages = [
        `Yaar maine Stain Slayer khela - Political Rally mein ${finalScore} score kiya! ${blockedCount} projectiles block kiye!\n\nNeta ji ka safed kurta bachaya Godrej Fab se! Daag toh bhag gaye bhai!\n\nTu bhi khel aur Fab wala magic le: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Bro! Stain Slayer mein ${finalScore} points banaye! ${blockedCount} ande-tamatar se neta ko bachaya!\n\nFab ki power se politician ka reputation clean! Democracy bachao, Fab lagao!\n\nGame try kar aur Fab wala Power order kar: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Dekh bhai! Political Rally mein ${finalScore} score - ${blockedCount} missiles block kiye maine!\n\nNeta ji ka white shirt = Fab se protected! Stains ka kya haal kiya maine!\n\nTu bhi hero ban aur Fab wala magic le ja: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Yaar maine neta ki bodyguard bana! Score: ${finalScore}, Blocked: ${blockedCount} attacks!\n\nPublic ka gussa vs Fab ka power - guess kaun jeeta? Fab FTW!\n\nGame khel aur Fab ka Power mangwa: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Stain Slayer champion alert! ${finalScore} points, ${blockedCount} projectiles defeated!\n\nPolitician ka kurta = spotless! Fab ka kamaal dekha ki nahi?\n\nAb tera turn hai - game try kar aur Fab wala magic order kar: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Bhai sahab! Rally mein ${finalScore} score kiya - ${blockedCount} stain attacks rokiye!\n\nNeta ji ka white dress code = Fab se maintained! Democracy is safe yaar!\n\nTu bhi defensive player ban aur Fab wala Power le: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Yaar Stain Slayer mein mast performance! Score: ${finalScore}, Defense: ${blockedCount} blocks!\n\nPolitical rally mein neta ka reputation bachaya - Fab ke saath full swag!\n\nAb tu khel aur Fab wala magic manga: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`,
        
        `Dekho mere skills! Stain Slayer mein ${finalScore} points - ${blockedCount} dirty attacks blocked!\n\nNeta ji ka pristine image = Fab protected! Clean politics ka naya level!\n\nTera number hai - game khelo aur Fab ka Power lo: https://blinkit.com/prn/godrej-fab-liquid-detergent-refill/prid/654061\n\n#FabDefender #StainSlayer #GodrejFab #PoliticalRally`
    ];
    
    // Select random message
    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
    const message = encodeURIComponent(randomMessage);
    
    const whatsappUrl = `https://wa.me/?text=${message}`;
    window.open(whatsappUrl, '_blank');
}

/**
 * Restart the game
 */
function playAgain() {
    debug3DViewer('PLAY_AGAIN_START', 'Play Again button clicked');
    
    // STEP 1: IMMEDIATELY CANCEL ANY PENDING 3D VIEWER INITIALIZATION
    if (window.pending3DViewerTimeouts) {
        debug3DViewer('CANCELLING_TIMEOUTS', `Found ${window.pending3DViewerTimeouts.length} pending timeouts`);
        window.pending3DViewerTimeouts.forEach(timeoutId => {
            clearTimeout(timeoutId);
            debug3DViewer('TIMEOUT_CANCELLED', `Cancelled timeout ID: ${timeoutId}`);
        });
        window.pending3DViewerTimeouts = [];
        console.log('Cancelled pending 3D viewer initialization timeouts');
    } else {
        debug3DViewer('NO_TIMEOUTS', 'No pending timeouts to cancel');
    }
    
    // STEP 2: CLEANUP EXISTING 3D VIEWER
    if (window.product3DViewer) {
        debug3DViewer('DESTROYING_VIEWER', 'Destroying existing 3D viewer');
        try {
            window.product3DViewer.destroy();
            debug3DViewer('DESTROY_SUCCESS', '3D viewer destroyed successfully');
            console.log('3D viewer destroyed successfully');
        } catch (error) {
            debug3DViewer('DESTROY_ERROR', error.message);
            console.warn('Error destroying 3D viewer:', error);
        }
        window.product3DViewer = null;
    } else {
        debug3DViewer('NO_VIEWER', 'No existing 3D viewer to destroy');
    }
    
    // STEP 3: HIDE RESULTS SCREEN
    const resultsScreen = document.getElementById('resultsScreen');
    if (resultsScreen) {
        resultsScreen.classList.remove('show');
        debug3DViewer('RESULTS_HIDDEN', 'Results screen hidden');
    }
    
    // SetTimeout with aggressive time conditions
setTimeout(() => {
    if (window.game) {
        // Hide canvas initially
        window.game.canvas.style.display = 'none';
        window.game.canvas.style.visibility = 'hidden';
        
        // Reset game state
        window.game.politicianHealth = 100;
        window.game.projectiles = [];
        window.game.particles = [];
        window.game.trailParticles = [];
        window.game.politician.stains = [];
        window.game.currentState = window.game.gameStates.START_SCREEN;
        window.game.isRunning = false;
        window.game.ctx.clearRect(0, 0, window.game.canvas.width, window.game.canvas.height);
        
        // Clear touch controls
        window.game.touchControls = {
            up: false, down: false, left: false, right: false, shield: false, slowmo: false
        };
        
        // Hide HUD elements first
        const hudElements = ['gameHUD', 'levelInfo', 'powerIndicators'];
        hudElements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.classList.remove('show');
            }
        });
        
        window.game.resetGameState();
        window.game.startGame(); // This will handle the proper canvas timing
    }
}, 100);
}

/**
 * Initialize game when DOM is loaded
 */
window.addEventListener('load', () => {
    try {
        window.game = new StainSlayerGame();
        console.log('[GAME] Stain Slayer initialized successfully');
    } catch (error) {
        console.error('[GAME] Failed to initialize:', error);
        alert('Game failed to load. Check console for details.');
    }
});

// Add after window.addEventListener('load', () => {...})
window.debugGameIssues = {
    findYellowBorders: function() {
        const allElements = document.querySelectorAll('*');
        const yellowElements = [];
        
        allElements.forEach(el => {
            const styles = getComputedStyle(el);
            const borderColor = styles.borderColor;
            
            if (borderColor.includes('255, 215') || 
                borderColor.includes('#FFD') ||
                el.style.borderColor && el.style.borderColor.includes('gold')) {
                yellowElements.push({
                    element: el,
                    borderColor: borderColor,
                    id: el.id || 'no-id',
                    className: el.className || 'no-class'
                });
            }
        });
        
        console.table(yellowElements);
        return yellowElements;
    }
};

/**
 * Global error handler
 */
window.addEventListener('error', (event) => {
    console.error('[GLOBAL ERROR]', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
    });
});

// DEBUG UTILITIES

if (typeof window !== 'undefined') {
    /**
     * Debug utilities for development
     */
    window.gameDebug = {
        toggleDebug: () => {
            if (window.game) {
                window.game.debug.enabled = !window.game.debug.enabled;
                console.log('Debug logging:', window.game.debug.enabled ? 'ENABLED' : 'DISABLED');
            }
        },
        setLogLevel: (level) => {
            if (window.game) {
                window.game.debug.logLevel = level;
                console.log('Debug level set to:', level);
            }
        },
        spawnProjectile: () => {
            if (window.game) {
                window.game.spawnProjectile();
            }
        },
        getGameState: () => {
            if (window.game) {
                return {
                    state: window.game.currentState,
                    score: window.game.score,
                    health: window.game.politicianHealth,
                    projectiles: window.game.projectiles.length,
                    particles: window.game.particles.length + window.game.trailParticles.length
                };
            }
            return null;
        },
        forceLevelUp: () => {
            if (window.game) {
                window.game.level++;
                window.game.wave = 1;
                console.log('Forced level up to:', window.game.level);
            }
        },
        debugFlags: () => {
            if (window.game) {
                return window.game.debugFlags();
            }
        },
        toggleFlagDebug: () => {
            if (window.game) {
                return window.game.toggleFlagDebug();
            }
        }
    };
    
    console.log('Debug commands available: window.gameDebug');
}

    </script>
</body>
</html>